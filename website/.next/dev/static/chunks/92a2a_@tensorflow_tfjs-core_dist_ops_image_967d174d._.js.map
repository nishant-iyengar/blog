{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@tensorflow+tfjs-core@4.22.0/node_modules/@tensorflow/tfjs-core/dist/ops/image/resize_bilinear.js","sources":["file:///Users/nishant/Documents/software/blog/node_modules/.pnpm/tfjs-core/src/ops/image/resize_bilinear.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {ResizeBilinear, ResizeBilinearAttrs, ResizeBilinearInputs} from '../../kernel_names';\nimport {NamedAttrMap} from '../../kernel_registry';\nimport {Tensor3D, Tensor4D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\n\nimport {op} from '../operation';\nimport {reshape} from '../reshape';\n\n/**\n * Bilinear resize a single 3D image or a batch of 3D images to a new shape.\n *\n * @param images The images, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param size The new shape `[newHeight, newWidth]` to resize the\n *     images to. Each channel is resized individually.\n * @param alignCorners Defaults to `false`. If true, rescale\n *     input by `(new_height - 1) / (height - 1)`, which exactly aligns the 4\n *     corners of images and resized images. If false, rescale by\n *     `new_height / height`. Treat similarly the width dimension.\n * @param halfPixelCenters Defaults to `false`. Whether to assume pixel centers\n *     are at 0.5, which would make the floating point coordinates of the top\n *     left pixel 0.5, 0.5.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction resizeBilinear_<T extends Tensor3D|Tensor4D>(\n    images: T|TensorLike, size: [number, number], alignCorners = false,\n    halfPixelCenters = false): T {\n  const $images = convertToTensor(images, 'images', 'resizeBilinear');\n\n  util.assert(\n      $images.rank === 3 || $images.rank === 4,\n      () => `Error in resizeBilinear: x must be rank 3 or 4, but got ` +\n          `rank ${$images.rank}.`);\n  util.assert(\n      size.length === 2,\n      () => `Error in resizeBilinear: new shape must 2D, but got shape ` +\n          `${size}.`);\n  util.assert(\n      halfPixelCenters === false || alignCorners === false,\n      () => `Error in resizeBilinear: If halfPixelCenters is true, ` +\n          `alignCorners must be false.`);\n\n  let batchImages = $images as Tensor4D;\n  let reshapedTo4D = false;\n  if ($images.rank === 3) {\n    reshapedTo4D = true;\n    batchImages = reshape(\n        $images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);\n  }\n\n  const [] = size;\n\n  const inputs: ResizeBilinearInputs = {images: batchImages};\n  const attrs: ResizeBilinearAttrs = {alignCorners, halfPixelCenters, size};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const res = ENGINE.runKernel(\n                  ResizeBilinear, inputs as unknown as NamedTensorMap,\n                  attrs as unknown as NamedAttrMap) as T;\n\n  if (reshapedTo4D) {\n    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]) as T;\n  }\n  return res;\n}\n\nexport const resizeBilinear = /* @__PURE__ */ op({resizeBilinear_});\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;GAeG,CAEH,OAAO,EAAC,MAAM,EAAC,MAAM,cAAc,CAAC;AACpC,OAAO,EAAC,cAAc,EAA4C,MAAM,oBAAoB,CAAC;AAI7F,OAAO,EAAC,eAAe,EAAC,MAAM,uBAAuB,CAAC;AAEtD,OAAO,KAAK,IAAI,MAAM,YAAY,CAAC;AAEnC,OAAO,EAAC,EAAE,EAAC,MAAM,cAAc,CAAC;AAChC,OAAO,EAAC,OAAO,EAAC,MAAM,YAAY,CAAC;;;;;;;AAEnC;;;;;;;;;;;;;;;;GAgBG,CACH,SAAS,eAAe,CACpB,MAAoB,EAAE,IAAsB,EAAE,YAAY,GAAG,KAAK,EAClE,gBAAgB,GAAG,KAAK;IAC1B,MAAM,OAAO,OAAG,uQAAe,EAAC,MAAM,EAAE,QAAQ,EAAE,gBAAgB,CAAC,CAAC;IAEpE,IAAI,CAAC,mPAAM,CACP,OAAO,CAAC,IAAI,KAAK,CAAC,IAAI,OAAO,CAAC,IAAI,KAAK,CAAC,EACxC,GAAG,CAAG,CAAD,AAAC,wDAAA,CAA0D,GAC5D,CAAA,KAAA,EAAQ,OAAO,CAAC,IAAI,CAAA,CAAA,CAAG,CAAC,CAAC;IACjC,IAAI,CAAC,mPAAM,CACP,IAAI,CAAC,MAAM,KAAK,CAAC,EACjB,GAAG,CAAG,CAAD,AAAC,0DAAA,CAA4D,GAC9D,GAAG,IAAI,CAAA,CAAA,CAAG,CAAC,CAAC;IACpB,IAAI,CAAC,mPAAM,CACP,gBAAgB,KAAK,KAAK,IAAI,YAAY,KAAK,KAAK,EACpD,GAAG,CAAG,CAAD,AAAC,sDAAA,CAAwD,GAC1D,CAAA,2BAAA,CAA6B,CAAC,CAAC;IAEvC,IAAI,WAAW,GAAG,OAAmB,CAAC;IACtC,IAAI,YAAY,GAAG,KAAK,CAAC;IACzB,IAAI,OAAO,CAAC,IAAI,KAAK,CAAC,EAAE;QACtB,YAAY,GAAG,IAAI,CAAC;QACpB,WAAW,OAAG,8PAAO,EACjB,OAAO,EAAE;YAAC,CAAC;YAAE,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;YAAE,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;YAAE,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;SAAC,CAAC,CAAC;KACzE;IAED,MAAM,EAAE,GAAG,IAAI,CAAC;IAEhB,MAAM,MAAM,GAAyB;QAAC,MAAM,EAAE,WAAW;IAAA,CAAC,CAAC;IAC3D,MAAM,KAAK,GAAwB;QAAC,YAAY;QAAE,gBAAgB;QAAE,IAAI;IAAA,CAAC,CAAC;IAE1E,0DAA0D;IAC1D,MAAM,GAAG,GAAG,qPAAM,CAAC,SAAS,CACZ,mQAAc,EAAE,MAAmC,EACnD,KAAgC,CAAM,CAAC;IAEvD,IAAI,YAAY,EAAE;QAChB,WAAO,8PAAO,EAAC,GAAG,EAAE;YAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;YAAE,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;YAAE,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;SAAC,CAAM,CAAC;KACtE;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAEM,MAAM,cAAc,GAAG,aAAA,EAAe,KAAC,2PAAE,EAAC;IAAC,eAAe;AAAA,CAAC,CAAC,CAAC"}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@tensorflow+tfjs-core@4.22.0/node_modules/@tensorflow/tfjs-core/dist/ops/image/resize_nearest_neighbor.js","sources":["file:///Users/nishant/Documents/software/blog/node_modules/.pnpm/tfjs-core/src/ops/image/resize_nearest_neighbor.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {ResizeNearestNeighbor, ResizeNearestNeighborAttrs, ResizeNearestNeighborInputs} from '../../kernel_names';\nimport {NamedAttrMap} from '../../kernel_registry';\nimport {Tensor3D, Tensor4D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\n\nimport {op} from '../operation';\nimport {reshape} from '../reshape';\n\n/**\n * NearestNeighbor resize a batch of 3D images to a new shape.\n *\n * @param images The images, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param size The new shape `[newHeight, newWidth]` to resize the\n *     images to. Each channel is resized individually.\n * @param alignCorners Defaults to False. If true, rescale\n *     input by `(new_height - 1) / (height - 1)`, which exactly aligns the 4\n *     corners of images and resized images. If false, rescale by\n *     `new_height / height`. Treat similarly the width dimension.\n * @param halfPixelCenters Defaults to `false`. Whether to assume pixels are of\n *      half the actual dimensions, and yield more accurate resizes. This flag\n *      would also make the floating point coordinates of the top left pixel\n *      0.5, 0.5.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction resizeNearestNeighbor_<T extends Tensor3D|Tensor4D>(\n    images: T|TensorLike, size: [number, number], alignCorners = false,\n    halfPixelCenters = false): T {\n  const $images = convertToTensor(images, 'images', 'resizeNearestNeighbor');\n\n  util.assert(\n      $images.rank === 3 || $images.rank === 4,\n      () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got ` +\n          `rank ${$images.rank}.`);\n  util.assert(\n      size.length === 2,\n      () =>\n          `Error in resizeNearestNeighbor: new shape must 2D, but got shape ` +\n          `${size}.`);\n  util.assert(\n      $images.dtype === 'float32' || $images.dtype === 'int32',\n      () => '`images` must have `int32` or `float32` as dtype');\n  util.assert(\n      halfPixelCenters === false || alignCorners === false,\n      () => `Error in resizeNearestNeighbor: If halfPixelCenters is true, ` +\n          `alignCorners must be false.`);\n  let batchImages = $images as Tensor4D;\n  let reshapedTo4D = false;\n  if ($images.rank === 3) {\n    reshapedTo4D = true;\n    batchImages = reshape(\n        $images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);\n  }\n  const [] = size;\n\n  const inputs: ResizeNearestNeighborInputs = {images: batchImages};\n  const attrs:\n      ResizeNearestNeighborAttrs = {alignCorners, halfPixelCenters, size};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const res = ENGINE.runKernel(\n                  ResizeNearestNeighbor, inputs as unknown as NamedTensorMap,\n                  attrs as unknown as NamedAttrMap) as T;\n\n  if (reshapedTo4D) {\n    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]) as T;\n  }\n  return res;\n}\n\nexport const resizeNearestNeighbor = /* @__PURE__ */ op({resizeNearestNeighbor_});\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;GAeG,CAEH,OAAO,EAAC,MAAM,EAAC,MAAM,cAAc,CAAC;AACpC,OAAO,EAAC,qBAAqB,EAA0D,MAAM,oBAAoB,CAAC;AAIlH,OAAO,EAAC,eAAe,EAAC,MAAM,uBAAuB,CAAC;AAEtD,OAAO,KAAK,IAAI,MAAM,YAAY,CAAC;AAEnC,OAAO,EAAC,EAAE,EAAC,MAAM,cAAc,CAAC;AAChC,OAAO,EAAC,OAAO,EAAC,MAAM,YAAY,CAAC;;;;;;;AAEnC;;;;;;;;;;;;;;;;;GAiBG,CACH,SAAS,sBAAsB,CAC3B,MAAoB,EAAE,IAAsB,EAAE,YAAY,GAAG,KAAK,EAClE,gBAAgB,GAAG,KAAK;IAC1B,MAAM,OAAO,OAAG,uQAAe,EAAC,MAAM,EAAE,QAAQ,EAAE,uBAAuB,CAAC,CAAC;IAE3E,IAAI,CAAC,mPAAM,CACP,OAAO,CAAC,IAAI,KAAK,CAAC,IAAI,OAAO,CAAC,IAAI,KAAK,CAAC,EACxC,GAAG,CAAG,CAAD,AAAC,+DAAA,CAAiE,GACnE,CAAA,KAAA,EAAQ,OAAO,CAAC,IAAI,CAAA,CAAA,CAAG,CAAC,CAAC;IACjC,IAAI,CAAC,mPAAM,CACP,IAAI,CAAC,MAAM,KAAK,CAAC,EACjB,GAAG,CACC,CADC,AACD,iEAAA,CAAmE,GACnE,GAAG,IAAI,CAAA,CAAA,CAAG,CAAC,CAAC;IACpB,IAAI,CAAC,mPAAM,CACP,OAAO,CAAC,KAAK,KAAK,SAAS,IAAI,OAAO,CAAC,KAAK,KAAK,OAAO,EACxD,GAAG,CAAG,CAAD,iDAAmD,CAAC,CAAC;IAC9D,IAAI,CAAC,mPAAM,CACP,gBAAgB,KAAK,KAAK,IAAI,YAAY,KAAK,KAAK,EACpD,GAAG,CAAG,CAAD,AAAC,6DAAA,CAA+D,GACjE,CAAA,2BAAA,CAA6B,CAAC,CAAC;IACvC,IAAI,WAAW,GAAG,OAAmB,CAAC;IACtC,IAAI,YAAY,GAAG,KAAK,CAAC;IACzB,IAAI,OAAO,CAAC,IAAI,KAAK,CAAC,EAAE;QACtB,YAAY,GAAG,IAAI,CAAC;QACpB,WAAW,OAAG,8PAAO,EACjB,OAAO,EAAE;YAAC,CAAC;YAAE,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;YAAE,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;YAAE,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;SAAC,CAAC,CAAC;KACzE;IACD,MAAM,EAAE,GAAG,IAAI,CAAC;IAEhB,MAAM,MAAM,GAAgC;QAAC,MAAM,EAAE,WAAW;IAAA,CAAC,CAAC;IAClE,MAAM,KAAK,GACsB;QAAC,YAAY;QAAE,gBAAgB;QAAE,IAAI;IAAA,CAAC,CAAC;IAExE,0DAA0D;IAC1D,MAAM,GAAG,GAAG,qPAAM,CAAC,SAAS,CACZ,0QAAqB,EAAE,MAAmC,EAC1D,KAAgC,CAAM,CAAC;IAEvD,IAAI,YAAY,EAAE;QAChB,WAAO,8PAAO,EAAC,GAAG,EAAE;YAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;YAAE,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;YAAE,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;SAAC,CAAM,CAAC;KACtE;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAEM,MAAM,qBAAqB,GAAG,aAAA,EAAe,KAAC,2PAAE,EAAC;IAAC,sBAAsB;AAAA,CAAC,CAAC,CAAC"}},
    {"offset": {"line": 186, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@tensorflow+tfjs-core@4.22.0/node_modules/@tensorflow/tfjs-core/dist/ops/image/crop_and_resize.js","sources":["file:///Users/nishant/Documents/software/blog/node_modules/.pnpm/tfjs-core/src/ops/image/crop_and_resize.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {CropAndResize, CropAndResizeAttrs, CropAndResizeInputs} from '../../kernel_names';\nimport {NamedAttrMap} from '../../kernel_registry';\nimport {Tensor1D, Tensor2D, Tensor4D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\n\nimport {op} from '../operation';\n\n/**\n * Extracts crops from the input image tensor and resizes them using bilinear\n * sampling or nearest neighbor sampling (possibly with aspect ratio change)\n * to a common output size specified by cropSize.\n *\n * @param image 4d tensor of shape `[batch,imageHeight,imageWidth, depth]`,\n *     where imageHeight and imageWidth must be positive, specifying the\n *     batch of images from which to take crops\n * @param boxes 2d float32 tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the normalized\n *     coordinates of the box in the `boxInd[i]`th image in the batch\n * @param boxInd 1d int32 tensor of shape `[numBoxes]` with values in range\n *     `[0, batch)` that specifies the image that the `i`-th box refers to.\n * @param cropSize 1d int32 tensor of 2 elements `[cropHeigh, cropWidth]`\n *     specifying the size to which all crops are resized to.\n * @param method Optional string from `'bilinear' | 'nearest'`,\n *     defaults to bilinear, which specifies the sampling method for resizing\n * @param extrapolationValue A threshold for deciding when to remove boxes based\n *     on score. Defaults to 0.\n * @return A 4D tensor of the shape `[numBoxes,cropHeight,cropWidth,depth]`\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction cropAndResize_(\n    image: Tensor4D|TensorLike,\n    boxes: Tensor2D|TensorLike,\n    boxInd: Tensor1D|TensorLike,\n    cropSize: [number, number],\n    method: 'bilinear'|'nearest' = 'bilinear',\n    extrapolationValue = 0,\n    ): Tensor4D {\n  const $image = convertToTensor(image, 'image', 'cropAndResize');\n  const $boxes = convertToTensor(boxes, 'boxes', 'cropAndResize', 'float32');\n  const $boxInd = convertToTensor(boxInd, 'boxInd', 'cropAndResize', 'int32');\n\n  const numBoxes = $boxes.shape[0];\n\n  util.assert(\n      $image.rank === 4,\n      () => 'Error in cropAndResize: image must be rank 4,' +\n          `but got rank ${$image.rank}.`);\n  util.assert(\n      $boxes.rank === 2 && $boxes.shape[1] === 4,\n      () => `Error in cropAndResize: boxes must be have size [${numBoxes},4] ` +\n          `but had shape ${$boxes.shape}.`);\n  util.assert(\n      $boxInd.rank === 1 && $boxInd.shape[0] === numBoxes,\n      () => `Error in cropAndResize: boxInd must be have size [${numBoxes}] ` +\n          `but had shape ${$boxes.shape}.`);\n  util.assert(\n      cropSize.length === 2,\n      () => `Error in cropAndResize: cropSize must be of length 2, but got ` +\n          `length ${cropSize.length}.`);\n  util.assert(\n      cropSize[0] >= 1 && cropSize[1] >= 1,\n      () => `cropSize must be atleast [1,1], but was ${cropSize}`);\n  util.assert(\n      method === 'bilinear' || method === 'nearest',\n      () => `method must be bilinear or nearest, but was ${method}`);\n\n  const inputs:\n      CropAndResizeInputs = {image: $image, boxes: $boxes, boxInd: $boxInd};\n  const attrs: CropAndResizeAttrs = {method, extrapolationValue, cropSize};\n  const res = ENGINE.runKernel(\n      CropAndResize, inputs as unknown as NamedTensorMap,\n      attrs as unknown as NamedAttrMap);\n  return res as Tensor4D;\n}\n\nexport const cropAndResize = /* @__PURE__ */ op({cropAndResize_});\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 268, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@tensorflow+tfjs-core@4.22.0/node_modules/@tensorflow/tfjs-core/dist/ops/image/flip_left_right.js","sources":["file:///Users/nishant/Documents/software/blog/node_modules/.pnpm/tfjs-core/src/ops/image/flip_left_right.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {FlipLeftRight, FlipLeftRightInputs} from '../../kernel_names';\nimport {Tensor4D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\nimport {op} from '../operation';\n\n/**\n * Flips the image left to right. Currently available in the CPU, WebGL, and\n * WASM backends.\n *\n * @param image 4d tensor of shape `[batch, imageHeight, imageWidth, depth]`.\n */\n/** @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'} */\nfunction flipLeftRight_(image: Tensor4D|TensorLike): Tensor4D {\n  const $image = convertToTensor(image, 'image', 'flipLeftRight', 'float32');\n\n  util.assert(\n      $image.rank === 4,\n      () => 'Error in flipLeftRight: image must be rank 4,' +\n          `but got rank ${$image.rank}.`);\n\n  const inputs: FlipLeftRightInputs = {image: $image};\n  const res =\n      ENGINE.runKernel(FlipLeftRight, inputs as unknown as NamedTensorMap, {});\n  return res as Tensor4D;\n}\n\nexport const flipLeftRight = /* @__PURE__ */ op({flipLeftRight_});\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;GAeG,CAEH,OAAO,EAAC,MAAM,EAAC,MAAM,cAAc,CAAC;AACpC,OAAO,EAAC,aAAa,EAAsB,MAAM,oBAAoB,CAAC;AAGtE,OAAO,EAAC,eAAe,EAAC,MAAM,uBAAuB,CAAC;AAEtD,OAAO,KAAK,IAAI,MAAM,YAAY,CAAC;AACnC,OAAO,EAAC,EAAE,EAAC,MAAM,cAAc,CAAC;;;;;;AAEhC;;;;;GAKG,CACH,2EAAA,EAA6E,CAC7E,SAAS,cAAc,CAAC,KAA0B;IAChD,MAAM,MAAM,OAAG,uQAAe,EAAC,KAAK,EAAE,OAAO,EAAE,eAAe,EAAE,SAAS,CAAC,CAAC;IAE3E,IAAI,CAAC,mPAAM,CACP,MAAM,CAAC,IAAI,KAAK,CAAC,EACjB,GAAG,CAAG,CAAD,8CAAgD,GACjD,CAAA,aAAA,EAAgB,MAAM,CAAC,IAAI,CAAA,CAAA,CAAG,CAAC,CAAC;IAExC,MAAM,MAAM,GAAwB;QAAC,KAAK,EAAE,MAAM;IAAA,CAAC,CAAC;IACpD,MAAM,GAAG,GACL,qPAAM,CAAC,SAAS,CAAC,kQAAa,EAAE,MAAmC,EAAE,CAAA,CAAE,CAAC,CAAC;IAC7E,OAAO,GAAe,CAAC;AACzB,CAAC;AAEM,MAAM,aAAa,GAAG,aAAA,EAAe,KAAC,2PAAE,EAAC;IAAC,cAAc;AAAA,CAAC,CAAC,CAAC"}},
    {"offset": {"line": 318, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@tensorflow+tfjs-core@4.22.0/node_modules/@tensorflow/tfjs-core/dist/ops/image/grayscale_to_rgb.js","sources":["file:///Users/nishant/Documents/software/blog/node_modules/.pnpm/tfjs-core/src/ops/image/grayscale_to_rgb.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor2D, Tensor3D, Tensor4D, Tensor5D, Tensor6D} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\n\nimport {op} from '../operation';\nimport {tile} from '../tile';\n\n/**\n * Converts images from grayscale to RGB format.\n *\n * @param image A grayscale tensor to convert. The `image`'s last dimension must\n *     be size 1 with at least a two-dimensional shape.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction grayscaleToRGB_<T extends Tensor2D|Tensor3D|Tensor4D|Tensor5D|\n                         Tensor6D>(image: T|TensorLike): T {\n  const $image = convertToTensor(image, 'image', 'grayscaleToRGB');\n\n  const lastDimsIdx = $image.rank - 1;\n  const lastDims = $image.shape[lastDimsIdx];\n\n  util.assert(\n      $image.rank >= 2,\n      () => 'Error in grayscaleToRGB: images must be at least rank 2, ' +\n          `but got rank ${$image.rank}.`);\n\n  util.assert(\n      lastDims === 1,\n      () => 'Error in grayscaleToRGB: last dimension of a grayscale image ' +\n          `should be size 1, but got size ${lastDims}.`);\n\n  const reps = new Array($image.rank);\n\n  reps.fill(1, 0, lastDimsIdx);\n  reps[lastDimsIdx] = 3;\n\n  return tile($image, reps);\n}\n\nexport const grayscaleToRGB = /* @__PURE__ */ op({grayscaleToRGB_});\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;GAeG,CAGH,OAAO,EAAC,eAAe,EAAC,MAAM,uBAAuB,CAAC;AAEtD,OAAO,KAAK,IAAI,MAAM,YAAY,CAAC;AAEnC,OAAO,EAAC,EAAE,EAAC,MAAM,cAAc,CAAC;AAChC,OAAO,EAAC,IAAI,EAAC,MAAM,SAAS,CAAC;;;;;AAE7B;;;;;;;GAOG,CACH,SAAS,eAAe,CACW,KAAmB;IACpD,MAAM,MAAM,OAAG,uQAAe,EAAC,KAAK,EAAE,OAAO,EAAE,gBAAgB,CAAC,CAAC;IAEjE,MAAM,WAAW,GAAG,MAAM,CAAC,IAAI,GAAG,CAAC,CAAC;IACpC,MAAM,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;IAE3C,IAAI,CAAC,mPAAM,CACP,MAAM,CAAC,IAAI,IAAI,CAAC,EAChB,GAAG,CAAG,CAAD,0DAA4D,GAC7D,CAAA,aAAA,EAAgB,MAAM,CAAC,IAAI,CAAA,CAAA,CAAG,CAAC,CAAC;IAExC,IAAI,CAAC,mPAAM,CACP,QAAQ,KAAK,CAAC,EACd,GAAG,CAAG,CAAD,8DAAgE,GACjE,CAAA,+BAAA,EAAkC,QAAQ,CAAA,CAAA,CAAG,CAAC,CAAC;IAEvD,MAAM,IAAI,GAAG,IAAI,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAEpC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,WAAW,CAAC,CAAC;IAC7B,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;IAEtB,WAAO,wPAAI,EAAC,MAAM,EAAE,IAAI,CAAC,CAAC;AAC5B,CAAC;AAEM,MAAM,cAAc,GAAG,aAAA,EAAe,KAAC,2PAAE,EAAC;IAAC,eAAe;AAAA,CAAC,CAAC,CAAC"}},
    {"offset": {"line": 370, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@tensorflow+tfjs-core@4.22.0/node_modules/@tensorflow/tfjs-core/dist/ops/image/rgb_to_grayscale.js","sources":["file:///Users/nishant/Documents/software/blog/node_modules/.pnpm/tfjs-core/src/ops/image/rgb_to_grayscale.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor2D, Tensor3D, Tensor4D, Tensor5D, Tensor6D} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\nimport {cast} from '../cast';\nimport {einsum} from '../einsum';\nimport {expandDims} from '../expand_dims';\nimport {op} from '../operation';\nimport {tensor1d} from '../tensor1d';\n\n/**\n * Converts images from RGB format to grayscale.\n *\n * @param image A RGB tensor to convert. The `image`'s last dimension must\n *     be size 3 with at least a two-dimensional shape.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction rgbToGrayscale_<T extends Tensor2D|Tensor3D|Tensor4D|Tensor5D|\n                         Tensor6D>(image: T|TensorLike): T {\n  const $image = convertToTensor(image, 'image', 'RGBToGrayscale');\n\n  const lastDimsIdx = $image.rank - 1;\n  const lastDims = $image.shape[lastDimsIdx];\n\n  util.assert(\n      $image.rank >= 2,\n      () => 'Error in RGBToGrayscale: images must be at least rank 2, ' +\n          `but got rank ${$image.rank}.`);\n\n  util.assert(\n      lastDims === 3,\n      () => 'Error in RGBToGrayscale: last dimension of an RGB image ' +\n          `should be size 3, but got size ${lastDims}.`);\n\n  // Remember original dtype so we can convert back if needed\n  const origDtype = $image.dtype;\n  const fltImage = cast($image, 'float32');\n\n  const rgbWeights = tensor1d([0.2989, 0.5870, 0.1140]);\n\n  let grayFloat;\n  switch ($image.rank) {\n    case 2:\n      grayFloat = einsum('ij,j->i', fltImage, rgbWeights);\n      break;\n    case 3:\n      grayFloat = einsum('ijk,k->ij', fltImage, rgbWeights);\n      break;\n    case 4:\n      grayFloat = einsum('ijkl,l->ijk', fltImage, rgbWeights);\n      break;\n    case 5:\n      grayFloat = einsum('ijklm,m->ijkl', fltImage, rgbWeights);\n      break;\n    case 6:\n      grayFloat = einsum('ijklmn,n->ijklm', fltImage, rgbWeights);\n      break;\n    default:\n      throw new Error('Not a valid tensor rank.');\n  }\n  grayFloat = expandDims(grayFloat, -1);\n\n  return cast(grayFloat, origDtype) as T;\n}\n\nexport const rgbToGrayscale = /* @__PURE__ */ op({rgbToGrayscale_});\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;GAeG,CAGH,OAAO,EAAC,eAAe,EAAC,MAAM,uBAAuB,CAAC;AAEtD,OAAO,KAAK,IAAI,MAAM,YAAY,CAAC;AACnC,OAAO,EAAC,IAAI,EAAC,MAAM,SAAS,CAAC;AAC7B,OAAO,EAAC,MAAM,EAAC,MAAM,WAAW,CAAC;AACjC,OAAO,EAAC,UAAU,EAAC,MAAM,gBAAgB,CAAC;AAC1C,OAAO,EAAC,EAAE,EAAC,MAAM,cAAc,CAAC;AAChC,OAAO,EAAC,QAAQ,EAAC,MAAM,aAAa,CAAC;;;;;;;;AAErC;;;;;;;GAOG,CACH,SAAS,eAAe,CACW,KAAmB;IACpD,MAAM,MAAM,OAAG,uQAAe,EAAC,KAAK,EAAE,OAAO,EAAE,gBAAgB,CAAC,CAAC;IAEjE,MAAM,WAAW,GAAG,MAAM,CAAC,IAAI,GAAG,CAAC,CAAC;IACpC,MAAM,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;IAE3C,IAAI,CAAC,mPAAM,CACP,MAAM,CAAC,IAAI,IAAI,CAAC,EAChB,GAAG,CAAG,CAAD,0DAA4D,GAC7D,CAAA,aAAA,EAAgB,MAAM,CAAC,IAAI,CAAA,CAAA,CAAG,CAAC,CAAC;IAExC,IAAI,CAAC,mPAAM,CACP,QAAQ,KAAK,CAAC,EACd,GAAG,CAAG,CAAD,yDAA2D,GAC5D,CAAA,+BAAA,EAAkC,QAAQ,CAAA,CAAA,CAAG,CAAC,CAAC;IAEvD,2DAA2D;IAC3D,MAAM,SAAS,GAAG,MAAM,CAAC,KAAK,CAAC;IAC/B,MAAM,QAAQ,OAAG,wPAAI,EAAC,MAAM,EAAE,SAAS,CAAC,CAAC;IAEzC,MAAM,UAAU,OAAG,gQAAQ,EAAC;QAAC,MAAM;QAAE,MAAM;QAAE,MAAM;KAAC,CAAC,CAAC;IAEtD,IAAI,SAAS,CAAC;IACd,OAAQ,MAAM,CAAC,IAAI,EAAE;QACnB,KAAK,CAAC;YACJ,SAAS,OAAG,4PAAM,EAAC,SAAS,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAC;YACpD,MAAM;QACR,KAAK,CAAC;YACJ,SAAS,OAAG,4PAAM,EAAC,WAAW,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAC;YACtD,MAAM;QACR,KAAK,CAAC;YACJ,SAAS,OAAG,4PAAM,EAAC,aAAa,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAC;YACxD,MAAM;QACR,KAAK,CAAC;YACJ,SAAS,OAAG,4PAAM,EAAC,eAAe,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAC;YAC1D,MAAM;QACR,KAAK,CAAC;YACJ,SAAS,OAAG,4PAAM,EAAC,iBAAiB,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAC;YAC5D,MAAM;QACR;YACE,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;KAC/C;IACD,SAAS,OAAG,qQAAU,EAAC,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC;IAEtC,WAAO,wPAAI,EAAC,SAAS,EAAE,SAAS,CAAM,CAAC;AACzC,CAAC;AAEM,MAAM,cAAc,GAAG,aAAA,EAAe,KAAC,2PAAE,EAAC;IAAC,eAAe;AAAA,CAAC,CAAC,CAAC"}},
    {"offset": {"line": 454, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@tensorflow+tfjs-core@4.22.0/node_modules/@tensorflow/tfjs-core/dist/ops/image/rotate_with_offset.js","sources":["file:///Users/nishant/Documents/software/blog/node_modules/.pnpm/tfjs-core/src/ops/image/rotate_with_offset.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {RotateWithOffset, RotateWithOffsetAttrs, RotateWithOffsetInputs} from '../../kernel_names';\nimport {NamedAttrMap} from '../../kernel_registry';\nimport {Tensor4D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\n\nimport {op} from '../operation';\n\n/**\n * Rotates the input image tensor counter-clockwise with an optional offset\n * center of rotation. Currently available in the CPU, WebGL, and WASM backends.\n *\n * @param image 4d tensor of shape `[batch, imageHeight, imageWidth, depth]`.\n * @param radians The amount of rotation.\n * @param fillValue The value to fill in the empty space leftover\n *     after rotation. Can be either a single grayscale value (0-255), or an\n *     array of three numbers `[red, green, blue]` specifying the red, green,\n *     and blue channels. Defaults to `0` (black).\n * @param center The center of rotation. Can be either a single value (0-1), or\n *     an array of two numbers `[centerX, centerY]`. Defaults to `0.5` (rotates\n *     the image around its center).\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction rotateWithOffset_(\n    image: Tensor4D|TensorLike, radians: number,\n    fillValue: number|[number, number, number] = 0,\n    center: number|[number, number] = 0.5): Tensor4D {\n  const $image = convertToTensor(image, 'image', 'rotateWithOffset', 'float32');\n\n  util.assert(\n      $image.rank === 4,\n      () => 'Error in rotateWithOffset: image must be rank 4,' +\n          `but got rank ${$image.rank}.`);\n\n  const inputs: RotateWithOffsetInputs = {image: $image};\n  const attrs: RotateWithOffsetAttrs = {radians, fillValue, center};\n  const res = ENGINE.runKernel(\n      RotateWithOffset, inputs as unknown as NamedTensorMap,\n      attrs as unknown as NamedAttrMap);\n  return res as Tensor4D;\n}\n\nexport const rotateWithOffset = /* @__PURE__ */ op({rotateWithOffset_});\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;GAeG,CAEH,OAAO,EAAC,MAAM,EAAC,MAAM,cAAc,CAAC;AACpC,OAAO,EAAC,gBAAgB,EAAgD,MAAM,oBAAoB,CAAC;AAInG,OAAO,EAAC,eAAe,EAAC,MAAM,uBAAuB,CAAC;AAEtD,OAAO,KAAK,IAAI,MAAM,YAAY,CAAC;AAEnC,OAAO,EAAC,EAAE,EAAC,MAAM,cAAc,CAAC;;;;;;AAEhC;;;;;;;;;;;;;;;GAeG,CACH,SAAS,iBAAiB,CACtB,KAA0B,EAAE,OAAe,EAC3C,YAA6C,CAAC,EAC9C,SAAkC,GAAG;IACvC,MAAM,MAAM,OAAG,uQAAe,EAAC,KAAK,EAAE,OAAO,EAAE,kBAAkB,EAAE,SAAS,CAAC,CAAC;IAE9E,IAAI,CAAC,mPAAM,CACP,MAAM,CAAC,IAAI,KAAK,CAAC,EACjB,GAAG,CAAG,CAAD,iDAAmD,GACpD,CAAA,aAAA,EAAgB,MAAM,CAAC,IAAI,CAAA,CAAA,CAAG,CAAC,CAAC;IAExC,MAAM,MAAM,GAA2B;QAAC,KAAK,EAAE,MAAM;IAAA,CAAC,CAAC;IACvD,MAAM,KAAK,GAA0B;QAAC,OAAO;QAAE,SAAS;QAAE,MAAM;IAAA,CAAC,CAAC;IAClE,MAAM,GAAG,GAAG,qPAAM,CAAC,SAAS,CACxB,qQAAgB,EAAE,MAAmC,EACrD,KAAgC,CAAC,CAAC;IACtC,OAAO,GAAe,CAAC;AACzB,CAAC;AAEM,MAAM,gBAAgB,GAAG,aAAA,EAAe,KAAC,2PAAE,EAAC;IAAC,iBAAiB;AAAA,CAAC,CAAC,CAAC"}},
    {"offset": {"line": 519, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@tensorflow+tfjs-core@4.22.0/node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression.js","sources":["file:///Users/nishant/Documents/software/blog/node_modules/.pnpm/tfjs-core/src/ops/image/non_max_suppression.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {NonMaxSuppressionV3} from '../../kernel_names';\nimport {Tensor1D, Tensor2D} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {nonMaxSuppSanityCheck} from '../nonmax_util';\nimport {op} from '../operation';\n\n/**\n * Performs non maximum suppression of bounding boxes based on\n * iou (intersection over union).\n *\n * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\n *     the bounding box.\n * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.\n * @param maxOutputSize The maximum number of boxes to be selected.\n * @param iouThreshold A float representing the threshold for deciding whether\n *     boxes overlap too much with respect to IOU. Must be between [0, 1].\n *     Defaults to 0.5 (50% box overlap).\n * @param scoreThreshold A threshold for deciding when to remove boxes based\n *     on score. Defaults to -inf, which means any score is accepted.\n * @return A 1D tensor with the selected box indices.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction nonMaxSuppression_(\n    boxes: Tensor2D|TensorLike, scores: Tensor1D|TensorLike,\n    maxOutputSize: number, iouThreshold = 0.5,\n    scoreThreshold = Number.NEGATIVE_INFINITY): Tensor1D {\n  const $boxes =\n      convertToTensor(boxes, 'boxes', 'nonMaxSuppression', 'float32');\n  const $scores =\n      convertToTensor(scores, 'scores', 'nonMaxSuppression', 'float32');\n\n  const inputs = nonMaxSuppSanityCheck(\n      $boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);\n  maxOutputSize = inputs.maxOutputSize;\n  iouThreshold = inputs.iouThreshold;\n  scoreThreshold = inputs.scoreThreshold;\n\n  const attrs = {maxOutputSize, iouThreshold, scoreThreshold};\n  return ENGINE.runKernel(\n      NonMaxSuppressionV3, {boxes: $boxes, scores: $scores}, attrs);\n}\n\nexport const nonMaxSuppression = /* @__PURE__ */ op({nonMaxSuppression_});\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;GAeG,CAEH,OAAO,EAAC,MAAM,EAAC,MAAM,cAAc,CAAC;AACpC,OAAO,EAAC,mBAAmB,EAAC,MAAM,oBAAoB,CAAC;AAEvD,OAAO,EAAC,eAAe,EAAC,MAAM,uBAAuB,CAAC;AAEtD,OAAO,EAAC,qBAAqB,EAAC,MAAM,gBAAgB,CAAC;AACrD,OAAO,EAAC,EAAE,EAAC,MAAM,cAAc,CAAC;;;;;;AAEhC;;;;;;;;;;;;;;;;;GAiBG,CACH,SAAS,kBAAkB,CACvB,KAA0B,EAAE,MAA2B,EACvD,aAAqB,EAAE,YAAY,GAAG,GAAG,EACzC,cAAc,GAAG,MAAM,CAAC,iBAAiB;IAC3C,MAAM,MAAM,OACR,uQAAe,EAAC,KAAK,EAAE,OAAO,EAAE,mBAAmB,EAAE,SAAS,CAAC,CAAC;IACpE,MAAM,OAAO,OACT,uQAAe,EAAC,MAAM,EAAE,QAAQ,EAAE,mBAAmB,EAAE,SAAS,CAAC,CAAC;IAEtE,MAAM,MAAM,OAAG,gRAAqB,EAChC,MAAM,EAAE,OAAO,EAAE,aAAa,EAAE,YAAY,EAAE,cAAc,CAAC,CAAC;IAClE,aAAa,GAAG,MAAM,CAAC,aAAa,CAAC;IACrC,YAAY,GAAG,MAAM,CAAC,YAAY,CAAC;IACnC,cAAc,GAAG,MAAM,CAAC,cAAc,CAAC;IAEvC,MAAM,KAAK,GAAG;QAAC,aAAa;QAAE,YAAY;QAAE,cAAc;IAAA,CAAC,CAAC;IAC5D,OAAO,qPAAM,CAAC,SAAS,CACnB,wQAAmB,EAAE;QAAC,KAAK,EAAE,MAAM;QAAE,MAAM,EAAE,OAAO;IAAA,CAAC,EAAE,KAAK,CAAC,CAAC;AACpE,CAAC;AAEM,MAAM,iBAAiB,GAAG,aAAA,EAAe,KAAC,2PAAE,EAAC;IAAC,kBAAkB;AAAA,CAAC,CAAC,CAAC"}},
    {"offset": {"line": 589, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@tensorflow+tfjs-core@4.22.0/node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_async.js","sources":["file:///Users/nishant/Documents/software/blog/node_modules/.pnpm/tfjs-core/src/ops/image/non_max_suppression_async.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {nonMaxSuppressionV3Impl} from '../../backends/non_max_suppression_impl';\nimport {Tensor1D, Tensor2D} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {nonMaxSuppSanityCheck} from '../nonmax_util';\nimport {tensor1d} from '../tensor1d';\n\n/**\n * Performs non maximum suppression of bounding boxes based on\n * iou (intersection over union).\n *\n * This is the async version of `nonMaxSuppression`\n *\n * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\n *     the bounding box.\n * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.\n * @param maxOutputSize The maximum number of boxes to be selected.\n * @param iouThreshold A float representing the threshold for deciding whether\n *     boxes overlap too much with respect to IOU. Must be between [0, 1].\n *     Defaults to 0.5 (50% box overlap).\n * @param scoreThreshold A threshold for deciding when to remove boxes based\n *     on score. Defaults to -inf, which means any score is accepted.\n * @return A 1D tensor with the selected box indices.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nasync function nonMaxSuppressionAsync_(\n    boxes: Tensor2D|TensorLike, scores: Tensor1D|TensorLike,\n    maxOutputSize: number, iouThreshold = 0.5,\n    scoreThreshold = Number.NEGATIVE_INFINITY): Promise<Tensor1D> {\n  const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppressionAsync');\n  const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppressionAsync');\n\n  const inputs = nonMaxSuppSanityCheck(\n      $boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);\n  maxOutputSize = inputs.maxOutputSize;\n  iouThreshold = inputs.iouThreshold;\n  scoreThreshold = inputs.scoreThreshold;\n\n  const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);\n  const boxesVals = boxesAndScores[0];\n  const scoresVals = boxesAndScores[1];\n\n  // We call a cpu based impl directly with the typedarray data  here rather\n  // than a kernel because all kernels are synchronous (and thus cannot await\n  // .data()).\n  const {selectedIndices} = nonMaxSuppressionV3Impl(\n      boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);\n  if ($boxes !== boxes) {\n    $boxes.dispose();\n  }\n  if ($scores !== scores) {\n    $scores.dispose();\n  }\n\n  return tensor1d(selectedIndices, 'int32');\n}\n\nexport const nonMaxSuppressionAsync = nonMaxSuppressionAsync_;\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;GAeG,CAEH,OAAO,EAAC,uBAAuB,EAAC,MAAM,yCAAyC,CAAC;AAEhF,OAAO,EAAC,eAAe,EAAC,MAAM,uBAAuB,CAAC;AAEtD,OAAO,EAAC,qBAAqB,EAAC,MAAM,gBAAgB,CAAC;AACrD,OAAO,EAAC,QAAQ,EAAC,MAAM,aAAa,CAAC;;;;;AAErC;;;;;;;;;;;;;;;;;;;GAmBG,CACH,KAAK,UAAU,uBAAuB,CAClC,KAA0B,EAAE,MAA2B,EACvD,aAAqB,EAAE,YAAY,GAAG,GAAG,EACzC,cAAc,GAAG,MAAM,CAAC,iBAAiB;IAC3C,MAAM,MAAM,OAAG,uQAAe,EAAC,KAAK,EAAE,OAAO,EAAE,wBAAwB,CAAC,CAAC;IACzE,MAAM,OAAO,OAAG,uQAAe,EAAC,MAAM,EAAE,QAAQ,EAAE,wBAAwB,CAAC,CAAC;IAE5E,MAAM,MAAM,OAAG,gRAAqB,EAChC,MAAM,EAAE,OAAO,EAAE,aAAa,EAAE,YAAY,EAAE,cAAc,CAAC,CAAC;IAClE,aAAa,GAAG,MAAM,CAAC,aAAa,CAAC;IACrC,YAAY,GAAG,MAAM,CAAC,YAAY,CAAC;IACnC,cAAc,GAAG,MAAM,CAAC,cAAc,CAAC;IAEvC,MAAM,cAAc,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC;QAAC,MAAM,CAAC,IAAI,EAAE;QAAE,OAAO,CAAC,IAAI,EAAE;KAAC,CAAC,CAAC;IAC1E,MAAM,SAAS,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;IACpC,MAAM,UAAU,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;IAErC,0EAA0E;IAC1E,2EAA2E;IAC3E,YAAY;IACZ,MAAM,EAAC,eAAe,EAAC,OAAG,oSAAuB,EAC7C,SAAS,EAAE,UAAU,EAAE,aAAa,EAAE,YAAY,EAAE,cAAc,CAAC,CAAC;IACxE,IAAI,MAAM,KAAK,KAAK,EAAE;QACpB,MAAM,CAAC,OAAO,EAAE,CAAC;KAClB;IACD,IAAI,OAAO,KAAK,MAAM,EAAE;QACtB,OAAO,CAAC,OAAO,EAAE,CAAC;KACnB;IAED,WAAO,gQAAQ,EAAC,eAAe,EAAE,OAAO,CAAC,CAAC;AAC5C,CAAC;AAEM,MAAM,sBAAsB,GAAG,uBAAuB,CAAC"}},
    {"offset": {"line": 665, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@tensorflow+tfjs-core@4.22.0/node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_with_score.js","sources":["file:///Users/nishant/Documents/software/blog/node_modules/.pnpm/tfjs-core/src/ops/image/non_max_suppression_with_score.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {NonMaxSuppressionV5, NonMaxSuppressionV5Attrs, NonMaxSuppressionV5Inputs} from '../../kernel_names';\nimport {NamedAttrMap} from '../../kernel_registry';\nimport {Tensor, Tensor1D, Tensor2D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\n\nimport {nonMaxSuppSanityCheck} from '../nonmax_util';\nimport {op} from '../operation';\n\n/**\n * Performs non maximum suppression of bounding boxes based on\n * iou (intersection over union).\n *\n * This op also supports a Soft-NMS mode (cf.\n * Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score\n * of other overlapping boxes, therefore favoring different regions of the image\n * with high scores. To enable this Soft-NMS mode, set the `softNmsSigma`\n * parameter to be larger than 0.\n *\n * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\n *     the bounding box.\n * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.\n * @param maxOutputSize The maximum number of boxes to be selected.\n * @param iouThreshold A float representing the threshold for deciding whether\n *     boxes overlap too much with respect to IOU. Must be between [0, 1].\n *     Defaults to 0.5 (50% box overlap).\n * @param scoreThreshold A threshold for deciding when to remove boxes based\n *     on score. Defaults to -inf, which means any score is accepted.\n * @param softNmsSigma A float representing the sigma parameter for Soft NMS.\n *     When sigma is 0, it falls back to nonMaxSuppression.\n * @return A map with the following properties:\n *     - selectedIndices: A 1D tensor with the selected box indices.\n *     - selectedScores: A 1D tensor with the corresponding scores for each\n *       selected box.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction nonMaxSuppressionWithScore_(\n    boxes: Tensor2D|TensorLike, scores: Tensor1D|TensorLike,\n    maxOutputSize: number, iouThreshold = 0.5,\n    scoreThreshold = Number.NEGATIVE_INFINITY,\n    softNmsSigma = 0.0): NamedTensorMap {\n  const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppression');\n  const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppression');\n\n  const params = nonMaxSuppSanityCheck(\n      $boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold,\n      softNmsSigma);\n  maxOutputSize = params.maxOutputSize;\n  iouThreshold = params.iouThreshold;\n  scoreThreshold = params.scoreThreshold;\n  softNmsSigma = params.softNmsSigma;\n\n  const inputs: NonMaxSuppressionV5Inputs = {boxes: $boxes, scores: $scores};\n  const attrs: NonMaxSuppressionV5Attrs =\n      {maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const result = ENGINE.runKernel(\n                     NonMaxSuppressionV5, inputs as unknown as NamedTensorMap,\n                     attrs as unknown as NamedAttrMap) as Tensor[];\n\n  return {selectedIndices: result[0], selectedScores: result[1]};\n}\n\nexport const nonMaxSuppressionWithScore = /* @__PURE__ */ op({nonMaxSuppressionWithScore_});\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;GAeG,CAEH,OAAO,EAAC,MAAM,EAAC,MAAM,cAAc,CAAC;AACpC,OAAO,EAAC,mBAAmB,EAAsD,MAAM,oBAAoB,CAAC;AAI5G,OAAO,EAAC,eAAe,EAAC,MAAM,uBAAuB,CAAC;AAGtD,OAAO,EAAC,qBAAqB,EAAC,MAAM,gBAAgB,CAAC;AACrD,OAAO,EAAC,EAAE,EAAC,MAAM,cAAc,CAAC;;;;;;AAEhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA4BG,CACH,SAAS,2BAA2B,CAChC,KAA0B,EAAE,MAA2B,EACvD,aAAqB,EAAE,YAAY,GAAG,GAAG,EACzC,cAAc,GAAG,MAAM,CAAC,iBAAiB,EACzC,YAAY,GAAG,GAAG;IACpB,MAAM,MAAM,OAAG,uQAAe,EAAC,KAAK,EAAE,OAAO,EAAE,mBAAmB,CAAC,CAAC;IACpE,MAAM,OAAO,OAAG,uQAAe,EAAC,MAAM,EAAE,QAAQ,EAAE,mBAAmB,CAAC,CAAC;IAEvE,MAAM,MAAM,OAAG,gRAAqB,EAChC,MAAM,EAAE,OAAO,EAAE,aAAa,EAAE,YAAY,EAAE,cAAc,EAC5D,YAAY,CAAC,CAAC;IAClB,aAAa,GAAG,MAAM,CAAC,aAAa,CAAC;IACrC,YAAY,GAAG,MAAM,CAAC,YAAY,CAAC;IACnC,cAAc,GAAG,MAAM,CAAC,cAAc,CAAC;IACvC,YAAY,GAAG,MAAM,CAAC,YAAY,CAAC;IAEnC,MAAM,MAAM,GAA8B;QAAC,KAAK,EAAE,MAAM;QAAE,MAAM,EAAE,OAAO;IAAA,CAAC,CAAC;IAC3E,MAAM,KAAK,GACP;QAAC,aAAa;QAAE,YAAY;QAAE,cAAc;QAAE,YAAY;IAAA,CAAC,CAAC;IAEhE,0DAA0D;IAC1D,MAAM,MAAM,GAAG,qPAAM,CAAC,SAAS,CACZ,wQAAmB,EAAE,MAAmC,EACxD,KAAgC,CAAa,CAAC;IAEjE,OAAO;QAAC,eAAe,EAAE,MAAM,CAAC,CAAC,CAAC;QAAE,cAAc,EAAE,MAAM,CAAC,CAAC,CAAC;IAAA,CAAC,CAAC;AACjE,CAAC;AAEM,MAAM,0BAA0B,GAAG,aAAA,EAAe,KAAC,2PAAE,EAAC;IAAC,2BAA2B;AAAA,CAAC,CAAC,CAAC"}},
    {"offset": {"line": 754, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@tensorflow+tfjs-core@4.22.0/node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_with_score_async.js","sources":["file:///Users/nishant/Documents/software/blog/node_modules/.pnpm/tfjs-core/src/ops/image/non_max_suppression_with_score_async.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {nonMaxSuppressionV5Impl} from '../../backends/non_max_suppression_impl';\nimport {Tensor1D, Tensor2D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {nonMaxSuppSanityCheck} from '../nonmax_util';\nimport {tensor1d} from '../tensor1d';\n\n/**\n * Asynchronously performs non maximum suppression of bounding boxes based on\n * iou (intersection over union).\n *\n * This op also supports a Soft-NMS mode (cf.\n * Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score\n * of other overlapping boxes, therefore favoring different regions of the image\n * with high scores. To enable this Soft-NMS mode, set the `softNmsSigma`\n * parameter to be larger than 0.\n *\n * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\n *     the bounding box.\n * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.\n * @param maxOutputSize The maximum number of boxes to be selected.\n * @param iouThreshold A float representing the threshold for deciding whether\n *     boxes overlap too much with respect to IOU. Must be between [0, 1].\n *     Defaults to 0.5 (50% box overlap).\n * @param scoreThreshold A threshold for deciding when to remove boxes based\n *     on score. Defaults to -inf, which means any score is accepted.\n * @param softNmsSigma A float representing the sigma parameter for Soft NMS.\n *     When sigma is 0, it falls back to nonMaxSuppression.\n * @return A map with the following properties:\n *     - selectedIndices: A 1D tensor with the selected box indices.\n *     - selectedScores: A 1D tensor with the corresponding scores for each\n *       selected box.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nasync function nonMaxSuppressionWithScoreAsync_(\n    boxes: Tensor2D|TensorLike, scores: Tensor1D|TensorLike,\n    maxOutputSize: number, iouThreshold = 0.5,\n    scoreThreshold = Number.NEGATIVE_INFINITY,\n    softNmsSigma = 0.0): Promise<NamedTensorMap> {\n  const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppressionAsync');\n  const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppressionAsync');\n\n  const params = nonMaxSuppSanityCheck(\n      $boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold,\n      softNmsSigma);\n  maxOutputSize = params.maxOutputSize;\n  iouThreshold = params.iouThreshold;\n  scoreThreshold = params.scoreThreshold;\n  softNmsSigma = params.softNmsSigma;\n\n  const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);\n  const boxesVals = boxesAndScores[0];\n  const scoresVals = boxesAndScores[1];\n\n  // We call a cpu based impl directly with the typedarray data  here rather\n  // than a kernel because all kernels are synchronous (and thus cannot await\n  // .data()).\n  const {selectedIndices, selectedScores} = nonMaxSuppressionV5Impl(\n      boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold,\n      softNmsSigma);\n\n  if ($boxes !== boxes) {\n    $boxes.dispose();\n  }\n  if ($scores !== scores) {\n    $scores.dispose();\n  }\n\n  return {\n    selectedIndices: tensor1d(selectedIndices, 'int32'),\n    selectedScores: tensor1d(selectedScores)\n  };\n}\n\nexport const nonMaxSuppressionWithScoreAsync = nonMaxSuppressionWithScoreAsync_;\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;GAeG,CACH,OAAO,EAAC,uBAAuB,EAAC,MAAM,yCAAyC,CAAC;AAGhF,OAAO,EAAC,eAAe,EAAC,MAAM,uBAAuB,CAAC;AAEtD,OAAO,EAAC,qBAAqB,EAAC,MAAM,gBAAgB,CAAC;AACrD,OAAO,EAAC,QAAQ,EAAC,MAAM,aAAa,CAAC;;;;;AAErC;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA4BG,CACH,KAAK,UAAU,gCAAgC,CAC3C,KAA0B,EAAE,MAA2B,EACvD,aAAqB,EAAE,YAAY,GAAG,GAAG,EACzC,cAAc,GAAG,MAAM,CAAC,iBAAiB,EACzC,YAAY,GAAG,GAAG;IACpB,MAAM,MAAM,OAAG,uQAAe,EAAC,KAAK,EAAE,OAAO,EAAE,wBAAwB,CAAC,CAAC;IACzE,MAAM,OAAO,OAAG,uQAAe,EAAC,MAAM,EAAE,QAAQ,EAAE,wBAAwB,CAAC,CAAC;IAE5E,MAAM,MAAM,OAAG,gRAAqB,EAChC,MAAM,EAAE,OAAO,EAAE,aAAa,EAAE,YAAY,EAAE,cAAc,EAC5D,YAAY,CAAC,CAAC;IAClB,aAAa,GAAG,MAAM,CAAC,aAAa,CAAC;IACrC,YAAY,GAAG,MAAM,CAAC,YAAY,CAAC;IACnC,cAAc,GAAG,MAAM,CAAC,cAAc,CAAC;IACvC,YAAY,GAAG,MAAM,CAAC,YAAY,CAAC;IAEnC,MAAM,cAAc,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC;QAAC,MAAM,CAAC,IAAI,EAAE;QAAE,OAAO,CAAC,IAAI,EAAE;KAAC,CAAC,CAAC;IAC1E,MAAM,SAAS,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;IACpC,MAAM,UAAU,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;IAErC,0EAA0E;IAC1E,2EAA2E;IAC3E,YAAY;IACZ,MAAM,EAAC,eAAe,EAAE,cAAc,EAAC,OAAG,oSAAuB,EAC7D,SAAS,EAAE,UAAU,EAAE,aAAa,EAAE,YAAY,EAAE,cAAc,EAClE,YAAY,CAAC,CAAC;IAElB,IAAI,MAAM,KAAK,KAAK,EAAE;QACpB,MAAM,CAAC,OAAO,EAAE,CAAC;KAClB;IACD,IAAI,OAAO,KAAK,MAAM,EAAE;QACtB,OAAO,CAAC,OAAO,EAAE,CAAC;KACnB;IAED,OAAO;QACL,eAAe,MAAE,gQAAQ,EAAC,eAAe,EAAE,OAAO,CAAC;QACnD,cAAc,MAAE,gQAAQ,EAAC,cAAc,CAAC;KACzC,CAAC;AACJ,CAAC;AAEM,MAAM,+BAA+B,GAAG,gCAAgC,CAAC"}},
    {"offset": {"line": 843, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@tensorflow+tfjs-core@4.22.0/node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_padded.js","sources":["file:///Users/nishant/Documents/software/blog/node_modules/.pnpm/tfjs-core/src/ops/image/non_max_suppression_padded.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {NonMaxSuppressionV4, NonMaxSuppressionV4Attrs, NonMaxSuppressionV4Inputs} from '../../kernel_names';\nimport {NamedAttrMap} from '../../kernel_registry';\nimport {Tensor, Tensor1D, Tensor2D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\n\nimport {nonMaxSuppSanityCheck} from '../nonmax_util';\nimport {op} from '../operation';\n\n/**\n * Asynchronously performs non maximum suppression of bounding boxes based on\n * iou (intersection over union), with an option to pad results.\n *\n * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\n *     the bounding box.\n * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.\n * @param maxOutputSize The maximum number of boxes to be selected.\n * @param iouThreshold A float representing the threshold for deciding whether\n *     boxes overlap too much with respect to IOU. Must be between [0, 1].\n *     Defaults to 0.5 (50% box overlap).\n * @param scoreThreshold A threshold for deciding when to remove boxes based\n *     on score. Defaults to -inf, which means any score is accepted.\n * @param padToMaxOutputSize Defaults to false. If true, size of output\n *     `selectedIndices` is padded to maxOutputSize.\n * @return A map with the following properties:\n *     - selectedIndices: A 1D tensor with the selected box indices.\n *     - validOutputs: A scalar denoting how many elements in `selectedIndices`\n *       are valid. Valid elements occur first, then padding.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction nonMaxSuppressionPadded_(\n    boxes: Tensor2D|TensorLike, scores: Tensor1D|TensorLike,\n    maxOutputSize: number, iouThreshold = 0.5,\n    scoreThreshold = Number.NEGATIVE_INFINITY,\n    padToMaxOutputSize = false): NamedTensorMap {\n  const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppression');\n  const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppression');\n\n  const params = nonMaxSuppSanityCheck(\n      $boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold,\n      null /* softNmsSigma */);\n  const $maxOutputSize = params.maxOutputSize;\n  const $iouThreshold = params.iouThreshold;\n  const $scoreThreshold = params.scoreThreshold;\n\n  const inputs: NonMaxSuppressionV4Inputs = {boxes: $boxes, scores: $scores};\n  const attrs: NonMaxSuppressionV4Attrs = {\n    maxOutputSize: $maxOutputSize,\n    iouThreshold: $iouThreshold,\n    scoreThreshold: $scoreThreshold,\n    padToMaxOutputSize\n  };\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const result = ENGINE.runKernel(\n                     NonMaxSuppressionV4, inputs as unknown as NamedTensorMap,\n                     attrs as unknown as NamedAttrMap) as Tensor[];\n\n  return {selectedIndices: result[0], validOutputs: result[1]};\n}\n\nexport const nonMaxSuppressionPadded = /* @__PURE__ */ op({nonMaxSuppressionPadded_});\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;GAeG,CAEH,OAAO,EAAC,MAAM,EAAC,MAAM,cAAc,CAAC;AACpC,OAAO,EAAC,mBAAmB,EAAsD,MAAM,oBAAoB,CAAC;AAI5G,OAAO,EAAC,eAAe,EAAC,MAAM,uBAAuB,CAAC;AAGtD,OAAO,EAAC,qBAAqB,EAAC,MAAM,gBAAgB,CAAC;AACrD,OAAO,EAAC,EAAE,EAAC,MAAM,cAAc,CAAC;;;;;;AAEhC;;;;;;;;;;;;;;;;;;;;;;GAsBG,CACH,SAAS,wBAAwB,CAC7B,KAA0B,EAAE,MAA2B,EACvD,aAAqB,EAAE,YAAY,GAAG,GAAG,EACzC,cAAc,GAAG,MAAM,CAAC,iBAAiB,EACzC,kBAAkB,GAAG,KAAK;IAC5B,MAAM,MAAM,OAAG,uQAAe,EAAC,KAAK,EAAE,OAAO,EAAE,mBAAmB,CAAC,CAAC;IACpE,MAAM,OAAO,OAAG,uQAAe,EAAC,MAAM,EAAE,QAAQ,EAAE,mBAAmB,CAAC,CAAC;IAEvE,MAAM,MAAM,OAAG,gRAAqB,EAChC,MAAM,EAAE,OAAO,EAAE,aAAa,EAAE,YAAY,EAAE,cAAc,EAC5D,IAAI,CAAC,kBAAkB,CAAC,CAAC;IAC7B,MAAM,cAAc,GAAG,MAAM,CAAC,aAAa,CAAC;IAC5C,MAAM,aAAa,GAAG,MAAM,CAAC,YAAY,CAAC;IAC1C,MAAM,eAAe,GAAG,MAAM,CAAC,cAAc,CAAC;IAE9C,MAAM,MAAM,GAA8B;QAAC,KAAK,EAAE,MAAM;QAAE,MAAM,EAAE,OAAO;IAAA,CAAC,CAAC;IAC3E,MAAM,KAAK,GAA6B;QACtC,aAAa,EAAE,cAAc;QAC7B,YAAY,EAAE,aAAa;QAC3B,cAAc,EAAE,eAAe;QAC/B,kBAAkB;KACnB,CAAC;IAEF,0DAA0D;IAC1D,MAAM,MAAM,GAAG,qPAAM,CAAC,SAAS,CACZ,wQAAmB,EAAE,MAAmC,EACxD,KAAgC,CAAa,CAAC;IAEjE,OAAO;QAAC,eAAe,EAAE,MAAM,CAAC,CAAC,CAAC;QAAE,YAAY,EAAE,MAAM,CAAC,CAAC,CAAC;IAAA,CAAC,CAAC;AAC/D,CAAC;AAEM,MAAM,uBAAuB,GAAG,aAAA,EAAe,KAAC,2PAAE,EAAC;IAAC,wBAAwB;AAAA,CAAC,CAAC,CAAC"}},
    {"offset": {"line": 925, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@tensorflow+tfjs-core@4.22.0/node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_padded_async.js","sources":["file:///Users/nishant/Documents/software/blog/node_modules/.pnpm/tfjs-core/src/ops/image/non_max_suppression_padded_async.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {nonMaxSuppressionV4Impl} from '../../backends/non_max_suppression_impl';\nimport {Tensor1D, Tensor2D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {nonMaxSuppSanityCheck} from '../nonmax_util';\nimport {scalar} from '../scalar';\nimport {tensor1d} from '../tensor1d';\n\n/**\n * Asynchronously performs non maximum suppression of bounding boxes based on\n * iou (intersection over union), with an option to pad results.\n *\n * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\n *     the bounding box.\n * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.\n * @param maxOutputSize The maximum number of boxes to be selected.\n * @param iouThreshold A float representing the threshold for deciding whether\n *     boxes overlap too much with respect to IOU. Must be between [0, 1].\n *     Defaults to 0.5 (50% box overlap).\n * @param scoreThreshold A threshold for deciding when to remove boxes based\n *     on score. Defaults to -inf, which means any score is accepted.\n * @param padToMaxOutputSize Defaults to false. If true, size of output\n *     `selectedIndices` is padded to maxOutputSize.\n * @return A map with the following properties:\n *     - selectedIndices: A 1D tensor with the selected box indices.\n *     - validOutputs: A scalar denoting how many elements in `selectedIndices`\n *       are valid. Valid elements occur first, then padding.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nasync function nonMaxSuppressionPaddedAsync_(\n    boxes: Tensor2D|TensorLike, scores: Tensor1D|TensorLike,\n    maxOutputSize: number, iouThreshold = 0.5,\n    scoreThreshold = Number.NEGATIVE_INFINITY,\n    padToMaxOutputSize = false): Promise<NamedTensorMap> {\n  const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppressionAsync');\n  const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppressionAsync');\n\n  const params = nonMaxSuppSanityCheck(\n      $boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold,\n      null /* softNmsSigma */);\n  const $maxOutputSize = params.maxOutputSize;\n  const $iouThreshold = params.iouThreshold;\n  const $scoreThreshold = params.scoreThreshold;\n\n  const [boxesVals, scoresVals] =\n      await Promise.all([$boxes.data(), $scores.data()]);\n\n  // We call a cpu based impl directly with the typedarray data here rather\n  // than a kernel because all kernels are synchronous (and thus cannot await\n  // .data()).\n  const {selectedIndices, validOutputs} = nonMaxSuppressionV4Impl(\n      boxesVals, scoresVals, $maxOutputSize, $iouThreshold, $scoreThreshold,\n      padToMaxOutputSize);\n\n  if ($boxes !== boxes) {\n    $boxes.dispose();\n  }\n  if ($scores !== scores) {\n    $scores.dispose();\n  }\n\n  return {\n    selectedIndices: tensor1d(selectedIndices, 'int32'),\n    validOutputs: scalar(validOutputs, 'int32')\n  };\n}\n\nexport const nonMaxSuppressionPaddedAsync = nonMaxSuppressionPaddedAsync_;\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;GAeG,CACH,OAAO,EAAC,uBAAuB,EAAC,MAAM,yCAAyC,CAAC;AAGhF,OAAO,EAAC,eAAe,EAAC,MAAM,uBAAuB,CAAC;AAEtD,OAAO,EAAC,qBAAqB,EAAC,MAAM,gBAAgB,CAAC;AACrD,OAAO,EAAC,MAAM,EAAC,MAAM,WAAW,CAAC;AACjC,OAAO,EAAC,QAAQ,EAAC,MAAM,aAAa,CAAC;;;;;;AAErC;;;;;;;;;;;;;;;;;;;;;;GAsBG,CACH,KAAK,UAAU,6BAA6B,CACxC,KAA0B,EAAE,MAA2B,EACvD,aAAqB,EAAE,YAAY,GAAG,GAAG,EACzC,cAAc,GAAG,MAAM,CAAC,iBAAiB,EACzC,kBAAkB,GAAG,KAAK;IAC5B,MAAM,MAAM,OAAG,uQAAe,EAAC,KAAK,EAAE,OAAO,EAAE,wBAAwB,CAAC,CAAC;IACzE,MAAM,OAAO,OAAG,uQAAe,EAAC,MAAM,EAAE,QAAQ,EAAE,wBAAwB,CAAC,CAAC;IAE5E,MAAM,MAAM,OAAG,gRAAqB,EAChC,MAAM,EAAE,OAAO,EAAE,aAAa,EAAE,YAAY,EAAE,cAAc,EAC5D,IAAI,CAAC,kBAAkB,CAAC,CAAC;IAC7B,MAAM,cAAc,GAAG,MAAM,CAAC,aAAa,CAAC;IAC5C,MAAM,aAAa,GAAG,MAAM,CAAC,YAAY,CAAC;IAC1C,MAAM,eAAe,GAAG,MAAM,CAAC,cAAc,CAAC;IAE9C,MAAM,CAAC,SAAS,EAAE,UAAU,CAAC,GACzB,MAAM,OAAO,CAAC,GAAG,CAAC;QAAC,MAAM,CAAC,IAAI,EAAE;QAAE,OAAO,CAAC,IAAI,EAAE;KAAC,CAAC,CAAC;IAEvD,yEAAyE;IACzE,2EAA2E;IAC3E,YAAY;IACZ,MAAM,EAAC,eAAe,EAAE,YAAY,EAAC,OAAG,oSAAuB,EAC3D,SAAS,EAAE,UAAU,EAAE,cAAc,EAAE,aAAa,EAAE,eAAe,EACrE,kBAAkB,CAAC,CAAC;IAExB,IAAI,MAAM,KAAK,KAAK,EAAE;QACpB,MAAM,CAAC,OAAO,EAAE,CAAC;KAClB;IACD,IAAI,OAAO,KAAK,MAAM,EAAE;QACtB,OAAO,CAAC,OAAO,EAAE,CAAC;KACnB;IAED,OAAO;QACL,eAAe,MAAE,gQAAQ,EAAC,eAAe,EAAE,OAAO,CAAC;QACnD,YAAY,MAAE,4PAAM,EAAC,YAAY,EAAE,OAAO,CAAC;KAC5C,CAAC;AACJ,CAAC;AAEM,MAAM,4BAA4B,GAAG,6BAA6B,CAAC"}},
    {"offset": {"line": 1007, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@tensorflow+tfjs-core@4.22.0/node_modules/@tensorflow/tfjs-core/dist/ops/image/threshold.js","sources":["file:///Users/nishant/Documents/software/blog/node_modules/.pnpm/tfjs-core/src/ops/image/threshold.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport { Tensor1D, Tensor3D } from '../../tensor';\nimport { tensor1d } from '../tensor1d';\nimport { TensorLike } from '../../types';\nimport { op } from '../operation';\nimport { cast } from '../cast';\nimport { split } from '../split';\nimport { bincount } from '../bincount';\nimport { lessEqual } from '../less_equal';\nimport { greater } from '../greater';\nimport { sum } from '../sum';\nimport { add } from '../add';\nimport { mul } from '../mul';\nimport { div } from '../div';\nimport { sub } from '../sub';\nimport { round } from '../round';\nimport { where } from '../where';\nimport { fill } from '../fill';\nimport {slice} from '../slice';\nimport { range } from '../range';\nimport { tensor } from '../tensor';\nimport * as util from '../../util';\nimport { convertToTensor } from '../../tensor_util_env';\n\n/**\n * Performs image binarization with corresponding threshold\n * (depends on the method)value, which creates a binary image from a grayscale.\n * @param image 3d tensor of shape [imageHeight,imageWidth, depth],\n * where imageHeight and imageWidth must be positive.The image color\n * range should be [0, 255].\n * @param method Optional string from `'binary' | 'otsu'`\n * which specifies the method for thresholding. Defaults to 'binary'.\n * @param inverted Optional boolean whichspecifies\n * if colours should be inverted. Defaults to false.\n * @param threshValue Optional number which defines threshold value from 0 to 1.\n * Defaults to 0.5.\n * @return A 3d tensor of shape [imageHeight,imageWidth, depth], which\n * contains binarized image.\n */\n\nfunction threshold_(\n    image: Tensor3D | TensorLike,\n    method = 'binary',\n    inverted = false,\n    threshValue = 0.5\n): Tensor3D {\n    const $image = convertToTensor(image, 'image', 'threshold');\n\n    /* 0.2989, 0.5870, 0.1140 are represent luma coefficients in CCIR601.\n\tReference for converting between RGB and grayscale: https://en.wikipedia.org/wiki/Luma_%28video%29  */\n\n    const RED_INTENCITY_COEF = 0.2989;\n    const GREEN_INTENCITY_COEF = 0.5870;\n    const BLUE_INTENCITY_COEF = 0.1140;\n    const totalPixelsInImage = $image.shape[0] * $image.shape[1];\n\n    let $threshold = mul(tensor1d([threshValue]), 255);\n    let r, g, b, grayscale;\n\n    util.assert(\n        $image.rank === 3,\n        () => 'Error in threshold: image must be rank 3,' +\n            `but got rank ${$image.rank}.`);\n\n    util.assert(\n        $image.shape[2] === 3 || $image.shape[2]=== 1,\n        () => 'Error in threshold: ' +\n            'image color channel must be equal to 3 or 1' +\n            `but got ${$image.shape[2]}.`);\n\n    util.assert(\n      $image.dtype === 'int32' || $image.dtype === 'float32',\n      () => 'Error in dtype: image dtype must be int32 or float32,' +\n          `but got dtype ${$image.dtype}.`);\n\n    util.assert(\n      method === 'otsu' || method === 'binary',\n      () => `Method must be binary or otsu, but was ${method}`);\n\n    if ($image.shape[2] === 3) {\n        [r, g, b] = split($image, [1, 1, 1], -1);\n        const $r = mul(r,RED_INTENCITY_COEF);\n        const $g = mul(g,GREEN_INTENCITY_COEF);\n        const $b = mul(b,BLUE_INTENCITY_COEF);\n        grayscale = add(add($r, $g), $b);\n    } else {\n        grayscale = image;\n    }\n\n    if (method === 'otsu') {\n        const $histogram = bincount(cast(round(grayscale), 'int32') as Tensor1D,\n            tensor([]),\n            256);\n        $threshold = otsu($histogram, totalPixelsInImage);\n    }\n\n    const invCondition = inverted ?\n        lessEqual(grayscale, $threshold) : greater(grayscale, $threshold);\n\n    const result = cast(mul(invCondition,255), 'int32');\n\n    return result as Tensor3D;\n}\n\nfunction otsu(histogram: Tensor1D, total: number):Tensor1D {\n\n    let bestThresh = tensor1d([-1]);\n    let bestInBetVar = tensor1d([0]);\n    let cInBetVar = tensor1d([0]);\n    let classFirst, classSecond, meanFirst,\n        meanSec, weightForeground, weightBack;\n\n    for (let index = 0; index < histogram.size-1; index++) {\n\n        classFirst = slice(histogram, 0, index + 1);\n\n        classSecond = slice(histogram,index + 1);\n\n        weightForeground = div(sum(classFirst),total);\n\n        weightBack = div(sum(classSecond),total);\n\n        const meanFirstDivA = sum(mul(classFirst, range(0, classFirst.size)));\n\n        meanFirst = div(meanFirstDivA, sum(classFirst) );\n\n        const meanSecFill = fill(classSecond.shape, classFirst.size);\n        const meanSecAdd = add(range(0,classSecond.size),meanSecFill);\n        const meanSecMul = mul(classSecond, (meanSecAdd));\n        meanSec = div(sum(meanSecMul), sum(classSecond));\n\n        const cInBetVarSubA = sub(meanFirst, meanSec);\n        const cInBetVarSubB = sub(meanFirst, meanSec);\n        const cInBetVarMul = mul(weightForeground, weightBack);\n        cInBetVar = mul(mul(cInBetVarMul,cInBetVarSubA), cInBetVarSubB);\n\n        const condition = greater(cInBetVar, bestInBetVar);\n\n        bestInBetVar = where(condition, cInBetVar, bestInBetVar);\n\n        bestThresh = where(condition, tensor1d([index]), bestThresh);\n\n    }\n    return bestThresh;\n}\n\nexport const threshold = /* @__PURE__ */ op({ threshold_ });\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1157, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@tensorflow+tfjs-core@4.22.0/node_modules/@tensorflow/tfjs-core/dist/ops/image/transform.js","sources":["file:///Users/nishant/Documents/software/blog/node_modules/.pnpm/tfjs-core/src/ops/image/transform.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../../engine';\nimport {Transform, TransformAttrs, TransformInputs} from '../../kernel_names';\nimport {NamedAttrMap} from '../../kernel_registry';\nimport {Tensor2D, Tensor4D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\n\nimport {op} from '../operation';\n\n/**\n * Applies the given transform(s) to the image(s).\n *\n * @param image 4d tensor of shape `[batch, imageHeight, imageWidth, depth]`.\n * @param transforms Projective transform matrix/matrices. A tensor1d of length\n *     8 or tensor of size N x 8. If one row of transforms is [a0, a1, a2, b0,\n *     b1, b2, c0, c1], then it maps the output point (x, y) to a transformed\n *     input point (x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k),\n *     where k = c0 x + c1 y + 1. The transforms are inverted compared to the\n *     transform mapping input points to output points.\n * @param interpolation Interpolation mode.\n *     Supported values: 'nearest', 'bilinear'. Default to 'nearest'.\n * @param fillMode Points outside the boundaries of the input are filled\n *     according to the given mode, one of 'constant', 'reflect', 'wrap',\n *     'nearest'. Default to 'constant'.\n *     'reflect': (d c b a | a b c d | d c b a ) The input is extended by\n *     reflecting about the edge of the last pixel.\n *     'constant': (k k k k | a b c d | k k k k) The input is extended by\n *     filling all values beyond the edge with the same constant value k.\n *     'wrap': (a b c d | a b c d | a b c d) The input is extended by\n *     wrapping around to the opposite edge.\n *     'nearest': (a a a a | a b c d | d d d d) The input is extended by\n *     the nearest pixel.\n * @param fillValue A float represents the value to be filled outside the\n *     boundaries when fillMode is 'constant'.\n * @param Output dimension after the transform, [height, width]. If undefined,\n *     output is the same size as input image.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction transform_(\n    image: Tensor4D|TensorLike, transforms: Tensor2D|TensorLike,\n    interpolation: 'nearest'|'bilinear' = 'nearest',\n    fillMode: 'constant'|'reflect'|'wrap'|'nearest' = 'constant', fillValue = 0,\n    outputShape?: [number, number]): Tensor4D {\n  const $image = convertToTensor(image, 'image', 'transform', 'float32');\n  const $transforms =\n      convertToTensor(transforms, 'transforms', 'transform', 'float32');\n\n  util.assert(\n      $image.rank === 4,\n      () => 'Error in transform: image must be rank 4,' +\n          `but got rank ${$image.rank}.`);\n\n  util.assert(\n      $transforms.rank === 2 &&\n          ($transforms.shape[0] === $image.shape[0] ||\n           $transforms.shape[0] === 1) &&\n          $transforms.shape[1] === 8,\n      () => `Error in transform: Input transform should be batch x 8 or 1 x 8`);\n\n  util.assert(\n      outputShape == null || outputShape.length === 2,\n      () =>\n          'Error in transform: outputShape must be [height, width] or null, ' +\n          `but got ${outputShape}.`);\n\n  const inputs: TransformInputs = {image: $image, transforms: $transforms};\n  const attrs:\n      TransformAttrs = {interpolation, fillMode, fillValue, outputShape};\n\n  return ENGINE.runKernel(\n      Transform, inputs as unknown as NamedTensorMap,\n      attrs as unknown as NamedAttrMap);\n}\n\nexport const transform = /* @__PURE__ */ op({transform_});\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;GAeG,CACH,OAAO,EAAC,MAAM,EAAC,MAAM,cAAc,CAAC;AACpC,OAAO,EAAC,SAAS,EAAkC,MAAM,oBAAoB,CAAC;AAI9E,OAAO,EAAC,eAAe,EAAC,MAAM,uBAAuB,CAAC;AAEtD,OAAO,KAAK,IAAI,MAAM,YAAY,CAAC;AAEnC,OAAO,EAAC,EAAE,EAAC,MAAM,cAAc,CAAC;;;;;;AAEhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BG,CACH,SAAS,UAAU,CACf,KAA0B,EAAE,UAA+B,EAC3D,gBAAsC,SAAS,EAC/C,WAAkD,UAAU,EAAE,SAAS,GAAG,CAAC,EAC3E,WAA8B;IAChC,MAAM,MAAM,OAAG,uQAAe,EAAC,KAAK,EAAE,OAAO,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;IACvE,MAAM,WAAW,OACb,uQAAe,EAAC,UAAU,EAAE,YAAY,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;IAEtE,IAAI,CAAC,mPAAM,CACP,MAAM,CAAC,IAAI,KAAK,CAAC,EACjB,GAAG,CAAG,CAAD,0CAA4C,GAC7C,CAAA,aAAA,EAAgB,MAAM,CAAC,IAAI,CAAA,CAAA,CAAG,CAAC,CAAC;IAExC,IAAI,CAAC,mPAAM,CACP,WAAW,CAAC,IAAI,KAAK,CAAC,IAClB,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,IACxC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,IAC5B,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,EAC9B,GAAG,CAAG,CAAD,AAAC,gEAAA,CAAkE,CAAC,CAAC;IAE9E,IAAI,CAAC,mPAAM,CACP,WAAW,IAAI,IAAI,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,EAC/C,GAAG,CACC,CADC,kEACkE,GACnE,CAAA,QAAA,EAAW,WAAW,CAAA,CAAA,CAAG,CAAC,CAAC;IAEnC,MAAM,MAAM,GAAoB;QAAC,KAAK,EAAE,MAAM;QAAE,UAAU,EAAE,WAAW;IAAA,CAAC,CAAC;IACzE,MAAM,KAAK,GACU;QAAC,aAAa;QAAE,QAAQ;QAAE,SAAS;QAAE,WAAW;IAAA,CAAC,CAAC;IAEvE,OAAO,qPAAM,CAAC,SAAS,CACnB,8PAAS,EAAE,MAAmC,EAC9C,KAAgC,CAAC,CAAC;AACxC,CAAC;AAEM,MAAM,SAAS,GAAG,aAAA,EAAe,KAAC,2PAAE,EAAC;IAAC,UAAU;AAAA,CAAC,CAAC,CAAC"}}]
}