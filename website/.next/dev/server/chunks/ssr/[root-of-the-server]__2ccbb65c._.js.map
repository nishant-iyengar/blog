{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/components/Navigation.tsx"],"sourcesContent":["'use client';\n\nimport Link from 'next/link';\nimport { usePathname } from 'next/navigation';\n\nexport default function Navigation() {\n  const pathname = usePathname();\n  \n  const isBlogPosts = pathname === '/' || pathname.startsWith('/posts/');\n  const isPhotos = pathname === '/photos';\n  const isAnimals = pathname === '/animals';\n  const isGames = pathname.startsWith('/games');\n\n  return (\n    <nav className=\"flex flex-row md:flex-col gap-2 md:gap-4 justify-center md:justify-start\">\n      <Link\n        href=\"/\"\n        className={`px-3 py-2 md:px-4 rounded-lg transition-colors text-sm font-medium whitespace-nowrap ${\n          isBlogPosts\n            ? 'bg-[#629C77] !text-white'\n            : 'text-[#718096] hover:bg-[#EDF2F7] hover:text-[#4A5568]'\n        }`}\n      >\n        Posts\n      </Link>\n      <Link\n        href=\"/photos\"\n        className={`px-3 py-2 md:px-4 rounded-lg transition-colors text-sm font-medium whitespace-nowrap ${\n          isPhotos\n            ? 'bg-[#629C77] !text-white'\n            : 'text-[#718096] hover:bg-[#EDF2F7] hover:text-[#4A5568]'\n        }`}\n      >\n        Photos\n      </Link>\n      <Link\n        href=\"/animals\"\n        className={`px-3 py-2 md:px-4 rounded-lg transition-colors text-sm font-medium whitespace-nowrap ${\n          isAnimals\n            ? 'bg-[#629C77] !text-white'\n            : 'text-[#718096] hover:bg-[#EDF2F7] hover:text-[#4A5568]'\n        }`}\n      >\n        Animals\n      </Link>\n      <Link\n        href=\"/games\"\n        className={`hidden md:block px-3 py-2 md:px-4 rounded-lg transition-colors text-sm font-medium whitespace-nowrap ${\n          isGames\n            ? 'bg-[#629C77] !text-white'\n            : 'text-[#718096] hover:bg-[#EDF2F7] hover:text-[#4A5568]'\n        }`}\n      >\n        Games\n      </Link>\n    </nav>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAHA;;;;AAKe,SAAS;IACtB,MAAM,WAAW,IAAA,kTAAW;IAE5B,MAAM,cAAc,aAAa,OAAO,SAAS,UAAU,CAAC;IAC5D,MAAM,WAAW,aAAa;IAC9B,MAAM,YAAY,aAAa;IAC/B,MAAM,UAAU,SAAS,UAAU,CAAC;IAEpC,qBACE,+YAAC;QAAI,WAAU;;0BACb,+YAAC,wUAAI;gBACH,MAAK;gBACL,WAAW,CAAC,qFAAqF,EAC/F,cACI,6BACA,0DACJ;0BACH;;;;;;0BAGD,+YAAC,wUAAI;gBACH,MAAK;gBACL,WAAW,CAAC,qFAAqF,EAC/F,WACI,6BACA,0DACJ;0BACH;;;;;;0BAGD,+YAAC,wUAAI;gBACH,MAAK;gBACL,WAAW,CAAC,qFAAqF,EAC/F,YACI,6BACA,0DACJ;0BACH;;;;;;0BAGD,+YAAC,wUAAI;gBACH,MAAK;gBACL,WAAW,CAAC,qGAAqG,EAC/G,UACI,6BACA,0DACJ;0BACH;;;;;;;;;;;;AAKP"}},
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/components/Sidebar.tsx"],"sourcesContent":["'use client';\n\nimport { useState, useRef, useEffect } from 'react';\nimport Navigation from './Navigation';\n\nexport default function Sidebar() {\n  const [isOpen, setIsOpen] = useState(true);\n  const [isDragging, setIsDragging] = useState(false);\n  const sidebarRef = useRef<HTMLDivElement>(null);\n  const startXRef = useRef<number>(0);\n\n  useEffect(() => {\n    const handleMouseMove = (e: MouseEvent) => {\n      if (!isDragging || !sidebarRef.current) return;\n\n      const deltaX = e.clientX - startXRef.current;\n      const threshold = 30; // Minimum drag distance\n\n      if (isOpen) {\n        // If open, dragging left closes it\n        if (deltaX < -threshold) {\n          setIsOpen(false);\n          setIsDragging(false);\n        }\n      } else {\n        // If closed, dragging right opens it\n        if (deltaX > threshold) {\n          setIsOpen(true);\n          setIsDragging(false);\n        }\n      }\n    };\n\n    const handleMouseUp = () => {\n      setIsDragging(false);\n    };\n\n    if (isDragging) {\n      document.addEventListener('mousemove', handleMouseMove);\n      document.addEventListener('mouseup', handleMouseUp);\n      document.body.style.cursor = 'ew-resize';\n      document.body.style.userSelect = 'none';\n    }\n\n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n    };\n  }, [isDragging, isOpen]);\n\n  const handleMouseDown = (e: React.MouseEvent) => {\n    e.preventDefault();\n    startXRef.current = e.clientX;\n    setIsDragging(true);\n  };\n\n  return (\n    <>\n      {/* Mobile Navigation Bar - Always visible at top on mobile */}\n      <nav className=\"md:hidden w-full bg-[#EDF2F7] border-b border-[#E2E8F0] px-2 py-2 fixed top-0 left-0 right-0 z-50\">\n        <Navigation />\n      </nav>\n\n      {/* Desktop Sidebar */}\n      <aside\n        ref={sidebarRef}\n        className={`hidden md:block relative transition-all duration-300 ease-in-out ${\n          isOpen ? 'w-64' : 'w-0'\n        } min-h-screen bg-[#EDF2F7] border-r border-[#E2E8F0] overflow-hidden`}\n      >\n        <div className={`h-full p-6 ${isOpen ? 'opacity-100' : 'opacity-0'}`}>\n          <Navigation />\n        </div>\n        \n        {/* Drag Handle */}\n        <div\n          onMouseDown={handleMouseDown}\n          className={`absolute top-0 right-0 w-2 h-full cursor-ew-resize hover:bg-[#629C77]/30 transition-colors ${\n            isOpen ? 'block' : 'hidden'\n          }`}\n          style={{ zIndex: 10 }}\n        />\n      </aside>\n\n      {/* Collapsed Toggle Button - Only show on desktop when sidebar is closed */}\n      {!isOpen && (\n        <button\n          onClick={() => setIsOpen(true)}\n          className=\"hidden md:block fixed left-0 top-1/2 -translate-y-1/2 z-20 bg-[#EDF2F7] border-r border-[#E2E8F0] px-2 py-4 rounded-r-lg hover:bg-[#629C77] hover:text-white transition-colors\"\n          aria-label=\"Open sidebar\"\n        >\n          <svg\n            className=\"w-4 h-4\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            viewBox=\"0 0 24 24\"\n          >\n            <path\n              strokeLinecap=\"round\"\n              strokeLinejoin=\"round\"\n              strokeWidth={2}\n              d=\"M9 5l7 7-7 7\"\n            />\n          </svg>\n        </button>\n      )}\n    </>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAHA;;;;AAKe,SAAS;IACtB,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,kXAAQ,EAAC;IACrC,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,kXAAQ,EAAC;IAC7C,MAAM,aAAa,IAAA,gXAAM,EAAiB;IAC1C,MAAM,YAAY,IAAA,gXAAM,EAAS;IAEjC,IAAA,mXAAS,EAAC;QACR,MAAM,kBAAkB,CAAC;YACvB,IAAI,CAAC,cAAc,CAAC,WAAW,OAAO,EAAE;YAExC,MAAM,SAAS,EAAE,OAAO,GAAG,UAAU,OAAO;YAC5C,MAAM,YAAY,IAAI,wBAAwB;YAE9C,IAAI,QAAQ;gBACV,mCAAmC;gBACnC,IAAI,SAAS,CAAC,WAAW;oBACvB,UAAU;oBACV,cAAc;gBAChB;YACF,OAAO;gBACL,qCAAqC;gBACrC,IAAI,SAAS,WAAW;oBACtB,UAAU;oBACV,cAAc;gBAChB;YACF;QACF;QAEA,MAAM,gBAAgB;YACpB,cAAc;QAChB;QAEA,IAAI,YAAY;YACd,SAAS,gBAAgB,CAAC,aAAa;YACvC,SAAS,gBAAgB,CAAC,WAAW;YACrC,SAAS,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG;YAC7B,SAAS,IAAI,CAAC,KAAK,CAAC,UAAU,GAAG;QACnC;QAEA,OAAO;YACL,SAAS,mBAAmB,CAAC,aAAa;YAC1C,SAAS,mBAAmB,CAAC,WAAW;YACxC,SAAS,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG;YAC7B,SAAS,IAAI,CAAC,KAAK,CAAC,UAAU,GAAG;QACnC;IACF,GAAG;QAAC;QAAY;KAAO;IAEvB,MAAM,kBAAkB,CAAC;QACvB,EAAE,cAAc;QAChB,UAAU,OAAO,GAAG,EAAE,OAAO;QAC7B,cAAc;IAChB;IAEA,qBACE;;0BAEE,+YAAC;gBAAI,WAAU;0BACb,cAAA,+YAAC,+IAAU;;;;;;;;;;0BAIb,+YAAC;gBACC,KAAK;gBACL,WAAW,CAAC,iEAAiE,EAC3E,SAAS,SAAS,MACnB,oEAAoE,CAAC;;kCAEtE,+YAAC;wBAAI,WAAW,CAAC,WAAW,EAAE,SAAS,gBAAgB,aAAa;kCAClE,cAAA,+YAAC,+IAAU;;;;;;;;;;kCAIb,+YAAC;wBACC,aAAa;wBACb,WAAW,CAAC,2FAA2F,EACrG,SAAS,UAAU,UACnB;wBACF,OAAO;4BAAE,QAAQ;wBAAG;;;;;;;;;;;;YAKvB,CAAC,wBACA,+YAAC;gBACC,SAAS,IAAM,UAAU;gBACzB,WAAU;gBACV,cAAW;0BAEX,cAAA,+YAAC;oBACC,WAAU;oBACV,MAAK;oBACL,QAAO;oBACP,SAAQ;8BAER,cAAA,+YAAC;wBACC,eAAc;wBACd,gBAAe;wBACf,aAAa;wBACb,GAAE;;;;;;;;;;;;;;;;;;AAOhB"}},
    {"offset": {"line": 212, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/website/content/games/tank-trouble-map.json"],"sourcesContent":["{\"width\":480,\"height\":360,\"barriers\":[{\"x\":60,\"y\":60,\"width\":120,\"height\":18},{\"x\":300,\"y\":60,\"width\":120,\"height\":18},{\"x\":60,\"y\":282,\"width\":120,\"height\":18},{\"x\":300,\"y\":282,\"width\":120,\"height\":18}],\"suns\":[{\"x\":165,\"y\":180,\"size\":5},{\"x\":215,\"y\":180,\"size\":5},{\"x\":265,\"y\":180,\"size\":5},{\"x\":315,\"y\":180,\"size\":5}],\"spawnPoints\":[{\"x\":90,\"y\":90,\"angle\":0},{\"x\":408,\"y\":240,\"angle\":180}]}"],"names":[],"mappings":"AAAA"}},
    {"offset": {"line": 212, "column": 418}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 216, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/lib/type-guards.ts"],"sourcesContent":["/**\n * Type Guard Utilities\n * \n * Generic type guard functions to reduce duplicate validation logic\n * and provide consistent error handling throughout the codebase.\n */\n\n/**\n * Generic type guard function that validates a value and throws an error if invalid\n * \n * @param value - The value to validate\n * @param guard - A type guard function that returns true if value is valid\n * @param errorMessage - Error message to throw if validation fails\n * @returns The validated value with proper type\n * \n * @example\n * const num = assertType(unknownValue, (v): v is number => typeof v === 'number', 'Expected number');\n */\nexport function assertType<T>(\n  value: unknown,\n  guard: (val: unknown) => val is T,\n  errorMessage: string\n): T {\n  if (!guard(value)) {\n    throw new Error(errorMessage);\n  }\n  return value;\n}\n\n/**\n * Validates that a value is not null or undefined\n */\nexport function isNotNull<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n\n/**\n * Validates that a value is an object (not null, not array, not primitive)\n */\nexport function isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\n/**\n * Validates that a value is a number\n */\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number' && !isNaN(value);\n}\n\n/**\n * Validates that a value is a string\n */\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\n/**\n * Validates that a value is an array\n */\nexport function isArray<T>(value: unknown, elementGuard?: (val: unknown) => val is T): value is T[] {\n  if (!Array.isArray(value)) {\n    return false;\n  }\n  if (elementGuard) {\n    return value.every(elementGuard);\n  }\n  return true;\n}\n\n/**\n * Validates that a value is an array of numbers\n */\nexport function isNumberArray(value: unknown): value is number[] {\n  return Array.isArray(value) && value.every((item) => typeof item === 'number' && !isNaN(item));\n}\n\n/**\n * Validates that a value is a 2D array of numbers\n */\nexport function is2DNumberArray(value: unknown): value is number[][] {\n  return (\n    Array.isArray(value) &&\n    value.length > 0 &&\n    value.every((row) => Array.isArray(row) && row.every((item) => typeof item === 'number' && !isNaN(item)))\n  );\n}\n\n/**\n * Validates that a value is an instance of a specific class\n */\nexport function isInstanceOf<T>(\n  value: unknown,\n  constructor: new (...args: unknown[]) => T\n): value is T {\n  return value instanceof constructor;\n}\n\n/**\n * Validates that a value is an Error instance\n */\nexport function isError(value: unknown): value is Error {\n  return value instanceof Error;\n}\n\n/**\n * Validates that a value has a specific property\n */\nexport function hasProperty<K extends string>(\n  value: unknown,\n  key: K\n): value is Record<K, unknown> {\n  return isObject(value) && key in value;\n}\n\n/**\n * Validates that a value has all specified properties\n */\nexport function hasProperties<K extends string>(\n  value: unknown,\n  keys: readonly K[]\n): value is Record<K, unknown> {\n  if (!isObject(value)) {\n    return false;\n  }\n  return keys.every((key) => key in value);\n}\n\n/**\n * Validates that a property exists and matches a type guard\n */\nexport function hasPropertyOfType<T, K extends string>(\n  value: unknown,\n  key: K,\n  guard: (val: unknown) => val is T\n): value is Record<K, T> {\n  if (!hasProperty(value, key)) {\n    return false;\n  }\n  return guard(value[key]);\n}\n\n/**\n * Validates a value using multiple type guards (all must pass)\n */\nexport function satisfiesAll<T>(\n  value: unknown,\n  ...guards: Array<(val: unknown) => val is T>\n): value is T {\n  return guards.every((guard) => guard(value));\n}\n\n/**\n * Validates a value using multiple type guards (at least one must pass)\n */\nexport function satisfiesAny<T>(\n  value: unknown,\n  ...guards: Array<(val: unknown) => val is T>\n): value is T {\n  return guards.some((guard) => guard(value));\n}\n\n/**\n * Validates that a number is within a range\n */\nexport function isInRange(value: number, min: number, max: number): boolean {\n  return value >= min && value <= max;\n}\n\n/**\n * Validates that a value is a valid enum value\n */\nexport function isEnumValue<T extends string>(\n  value: unknown,\n  enumObject: Record<string, T>\n): value is T {\n  return typeof value === 'string' && Object.values(enumObject).includes(value as T);\n}\n\n/**\n * Validates that a key is a valid key of an object type\n */\nexport function isKeyOf<T extends Record<string, unknown>>(\n  key: unknown,\n  validKeys: readonly (keyof T)[]\n): key is keyof T {\n  return typeof key === 'string' && validKeys.includes(key as keyof T);\n}\n\n/**\n * Validates and parses JSON, then validates the result with a type guard\n */\nexport function parseAndValidate<T>(\n  json: unknown,\n  guard: (val: unknown) => val is T,\n  errorMessage: string\n): T {\n  let parsed: unknown;\n  \n  if (typeof json === 'string') {\n    try {\n      parsed = JSON.parse(json);\n    } catch {\n      throw new Error(`Invalid JSON: ${errorMessage}`);\n    }\n  } else {\n    // If already an object, use JSON round-trip to create clean copy\n    try {\n      const jsonString = JSON.stringify(json);\n      parsed = JSON.parse(jsonString);\n    } catch {\n      throw new Error(`Failed to serialize: ${errorMessage}`);\n    }\n  }\n  \n  return assertType(parsed, guard, errorMessage);\n}\n\n/**\n * Validates that a value is a valid array length (non-negative integer)\n */\nexport function isValidArrayLength(value: unknown): value is number {\n  return typeof value === 'number' && Number.isInteger(value) && value >= 0;\n}\n\n/**\n * Validates that a value is a positive number\n */\nexport function isPositiveNumber(value: unknown): value is number {\n  return isNumber(value) && value > 0;\n}\n\n/**\n * Validates that a value is a non-negative number\n */\nexport function isNonNegativeNumber(value: unknown): value is number {\n  return isNumber(value) && value >= 0;\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 378, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/hooks/useGameInput.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\ninterface UseGameInputOptions {\n  gameOver?: boolean;\n}\n\n// Pre-compute game keys as Set for O(1) lookup instead of O(n) array.includes()\nconst GAME_KEYS_SET = new Set(['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' ', 'w', 'a', 's', 'd', 'q', 'p']);\n\nexport function useGameInput(options?: UseGameInputOptions) {\n  const keysRef = useRef<Set<string>>(new Set());\n  const [isPaused, setIsPaused] = useState(false);\n  const gameOverRef = useRef(options?.gameOver ?? false);\n\n  useEffect(() => {\n    gameOverRef.current = options?.gameOver ?? false;\n  }, [options?.gameOver]);\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Skip processing if game is over\n      if (gameOverRef.current) {\n        return;\n      }\n      // Normalize key to lowercase, handle special cases\n      let key: string;\n      \n      // Handle space key\n      if (e.key === ' ' || e.code === 'Space') {\n        key = ' ';\n      }\n      // Handle arrow keys - they come as \"ArrowUp\", \"ArrowDown\", etc.\n      else if (e.key.startsWith('Arrow') || e.code.startsWith('Arrow')) {\n        const arrowDir = e.key.replace('Arrow', '').toLowerCase() || e.code.replace('Arrow', '').toLowerCase();\n        key = `arrow${arrowDir}`;\n      }\n      // Regular letter keys - use code for more reliable detection\n      else {\n        // e.code gives \"KeyP\", \"KeyW\", etc. - remove \"Key\" prefix\n        if (e.code.startsWith('Key')) {\n          key = e.code.replace('Key', '').toLowerCase(); // 'KeyW' -> 'w', 'KeyP' -> 'p', etc.\n        } else {\n          key = e.key.toLowerCase();\n        }\n      }\n      \n      // Use Set for O(1) lookup instead of O(n) array.includes()\n      if (GAME_KEYS_SET.has(key)) {\n        e.preventDefault(); // Prevent default browser behavior (scrolling, etc.) - prevents the \"ding\" sound\n        e.stopPropagation(); // Stop event from bubbling\n        \n        // Handle pause toggle\n        if (key === 'p') {\n          setIsPaused((prev) => !prev);\n          return; // Don't add 'p' to keys set\n        }\n        \n        keysRef.current.add(key);\n      }\n    };\n\n    const handleKeyUp = (e: KeyboardEvent) => {\n      // Skip processing if game is over\n      if (gameOverRef.current) {\n        return;\n      }\n      \n      // Normalize key to lowercase, handle special cases\n      let key: string;\n      \n      // Handle space key\n      if (e.key === ' ' || e.code === 'Space') {\n        key = ' ';\n      }\n      // Handle arrow keys\n      else if (e.key.startsWith('Arrow') || e.code.startsWith('Arrow')) {\n        const arrowDir = e.key.replace('Arrow', '').toLowerCase() || e.code.replace('Arrow', '').toLowerCase();\n        key = `arrow${arrowDir}`;\n      }\n      // Regular letter keys\n      else {\n        // e.code gives \"KeyP\", \"KeyW\", etc. - remove \"Key\" prefix\n        if (e.code.startsWith('Key')) {\n          key = e.code.replace('Key', '').toLowerCase(); // 'KeyW' -> 'w', 'KeyP' -> 'p', etc.\n        } else {\n          key = e.key.toLowerCase();\n        }\n      }\n      \n      // Use Set for O(1) lookup instead of O(n) array.includes()\n      if (GAME_KEYS_SET.has(key)) {\n        e.preventDefault(); // Prevent default browser behavior\n        e.stopPropagation(); // Stop event from bubbling\n        \n        // Don't remove 'p' from keys set since we never added it\n        if (key !== 'p') {\n          keysRef.current.delete(key);\n        }\n      }\n    };\n\n    // Use capture phase to catch events early and prevent default behavior\n    window.addEventListener('keydown', handleKeyDown, true);\n    window.addEventListener('keyup', handleKeyUp, true);\n\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown, true);\n      window.removeEventListener('keyup', handleKeyUp, true);\n    };\n  }, []);\n\n  return { keysRef, isPaused };\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 489, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/hooks/useTankImages.ts"],"sourcesContent":["import { useEffect, useState } from 'react';\n\nexport function useTankImages() {\n  const [tankImages, setTankImages] = useState<{ blue: HTMLImageElement | null; red: HTMLImageElement | null }>({\n    blue: null,\n    red: null,\n  });\n\n  useEffect(() => {\n    const blueImg = new Image();\n    blueImg.src = '/games/tank-blue.svg';\n    blueImg.onload = () => {\n      setTankImages((prev) => ({ ...prev, blue: blueImg }));\n    };\n\n    const redImg = new Image();\n    redImg.src = '/games/tank-red.svg';\n    redImg.onload = () => {\n      setTankImages((prev) => ({ ...prev, red: redImg }));\n    };\n  }, []);\n\n  return tankImages;\n}\n\n"],"names":[],"mappings":";;;;AAAA;;AAEO,SAAS;IACd,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,kXAAQ,EAAkE;QAC5G,MAAM;QACN,KAAK;IACP;IAEA,IAAA,mXAAS,EAAC;QACR,MAAM,UAAU,IAAI;QACpB,QAAQ,GAAG,GAAG;QACd,QAAQ,MAAM,GAAG;YACf,cAAc,CAAC,OAAS,CAAC;oBAAE,GAAG,IAAI;oBAAE,MAAM;gBAAQ,CAAC;QACrD;QAEA,MAAM,SAAS,IAAI;QACnB,OAAO,GAAG,GAAG;QACb,OAAO,MAAM,GAAG;YACd,cAAc,CAAC,OAAS,CAAC;oBAAE,GAAG,IAAI;oBAAE,KAAK;gBAAO,CAAC;QACnD;IACF,GAAG,EAAE;IAEL,OAAO;AACT"}},
    {"offset": {"line": 524, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/config.ts"],"sourcesContent":["// Game Configuration - Modify these values to adjust game rules\nexport const GAME_CONFIG = {\n  // Tank settings (40% bigger)\n  tank: {\n    size: 24, // 17 * 1.4 = 23.8, rounded to 24\n    collisionSize: 10, // 7 * 1.4 = 9.8, rounded to 10\n    speed: 1.4, // 1.12 * 1.25 = 1.4 (25% faster)\n    rotationSpeed: 5, // degrees per tick (keep same)\n    lives: 3,\n    spawnOffset: 2, // 4 * 0.5 = 2\n  },\n  \n  // Bullet settings (60% slower - 40% of current speed)\n  bullet: {\n    speedMultiplier: 1.8 , // Bullet speed = tank speed * this multiplier (60% slower: 2.4 * 0.4 = 0.96)\n    maxPerTank: 5,\n    maxAge: 7000, // Maximum lifetime in milliseconds (7 seconds)\n    fadeDuration: 500, // Fade duration in milliseconds\n    radius: 2, // Twice as big: 1 * 2 = 2\n    collisionSize: 3, // 5 * 0.5 = 2.5, rounded to 3 \n  },\n  \n  // Game timing\n  game: {\n    tickRate: 72, // FPS (20% increase: 60 * 1.2 = 72)\n    shootingCooldown: 150, // Milliseconds between shots (reduced for rapid fire)\n  },\n  \n  // Sun physics (50% weaker - 50% of current strength)\n  sun: {\n    gravitationalConstant: 0.25 , // G - Gravitational constant for suns (50% weaker: 0.18 * 0.5 = 0.09)\n    mass: 120.0, // Mass of the sun (2x original)\n    influenceRadius: 60, // 120 * 0.5 = 60\n    minDistance: 2, // 4 * 0.5 = 2\n  },\n  \n  // Visual settings (scaled down by 50% - 50% of current)\n  visual: {\n    livesIndicatorRadius: 2, // 3 * 0.5 = 1.5, rounded to 2\n    livesIndicatorSpacing: 3, // Reduced spacing for closer life indicators (was 4)\n    livesIndicatorOffsetX: 3, // 6 * 0.5 = 3\n    livesIndicatorOffsetY: -3, // -6 * 0.5 = -3\n    uiTextSize: 7, // 13 * 0.5 = 6.5, rounded to 7\n    uiTextOffsetX: 4, // 8 * 0.5 = 4\n    uiTextOffsetY: 10, // 20 * 0.5 = 10\n  },\n  \n  // Debug flags\n  debug: {\n    disableSunGravity: true, // When true, disables sun gravity and hides suns (for performance testing)\n  },\n} as const;\n\n// Derived constants (calculated from config)\nexport const TANK_SIZE = GAME_CONFIG.tank.size;\nexport const TANK_COLLISION_SIZE = GAME_CONFIG.tank.collisionSize;\nexport const TANK_HALF_SIZE = TANK_SIZE / 2; // Commonly used value, compute once\nexport const TANK_SPEED = GAME_CONFIG.tank.speed;\nexport const BULLET_SPEED = TANK_SPEED * GAME_CONFIG.bullet.speedMultiplier;\nexport const ROTATION_SPEED = GAME_CONFIG.tank.rotationSpeed;\nexport const TICK_RATE = GAME_CONFIG.game.tickRate;\nexport const TICK_INTERVAL = 1000 / TICK_RATE;\nexport const MAX_BULLETS_PER_TANK = GAME_CONFIG.bullet.maxPerTank;\nexport const BULLET_MAX_AGE = GAME_CONFIG.bullet.maxAge;\nexport const G = GAME_CONFIG.sun.gravitationalConstant;\nexport const mSun = GAME_CONFIG.sun.mass;\nexport const SUN_INFLUENCE_RADIUS = GAME_CONFIG.sun.influenceRadius;\n\n"],"names":[],"mappings":"AAAA,gEAAgE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACzD,MAAM,cAAc;IACzB,6BAA6B;IAC7B,MAAM;QACJ,MAAM;QACN,eAAe;QACf,OAAO;QACP,eAAe;QACf,OAAO;QACP,aAAa;IACf;IAEA,sDAAsD;IACtD,QAAQ;QACN,iBAAiB;QACjB,YAAY;QACZ,QAAQ;QACR,cAAc;QACd,QAAQ;QACR,eAAe;IACjB;IAEA,cAAc;IACd,MAAM;QACJ,UAAU;QACV,kBAAkB;IACpB;IAEA,qDAAqD;IACrD,KAAK;QACH,uBAAuB;QACvB,MAAM;QACN,iBAAiB;QACjB,aAAa;IACf;IAEA,wDAAwD;IACxD,QAAQ;QACN,sBAAsB;QACtB,uBAAuB;QACvB,uBAAuB;QACvB,uBAAuB,CAAC;QACxB,YAAY;QACZ,eAAe;QACf,eAAe;IACjB;IAEA,cAAc;IACd,OAAO;QACL,mBAAmB;IACrB;AACF;AAGO,MAAM,YAAY,YAAY,IAAI,CAAC,IAAI;AACvC,MAAM,sBAAsB,YAAY,IAAI,CAAC,aAAa;AAC1D,MAAM,iBAAiB,YAAY,GAAG,oCAAoC;AAC1E,MAAM,aAAa,YAAY,IAAI,CAAC,KAAK;AACzC,MAAM,eAAe,aAAa,YAAY,MAAM,CAAC,eAAe;AACpE,MAAM,iBAAiB,YAAY,IAAI,CAAC,aAAa;AACrD,MAAM,YAAY,YAAY,IAAI,CAAC,QAAQ;AAC3C,MAAM,gBAAgB,OAAO;AAC7B,MAAM,uBAAuB,YAAY,MAAM,CAAC,UAAU;AAC1D,MAAM,iBAAiB,YAAY,MAAM,CAAC,MAAM;AAChD,MAAM,IAAI,YAAY,GAAG,CAAC,qBAAqB;AAC/C,MAAM,OAAO,YAAY,GAAG,CAAC,IAAI;AACjC,MAAM,uBAAuB,YAAY,GAAG,CAAC,eAAe"}},
    {"offset": {"line": 618, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/lib/physics.ts"],"sourcesContent":["/**\n * Physics utilities for game mechanics\n * Shared between BouncingBall and TankTrouble components\n */\n\nexport interface Vector2D {\n  x: number;\n  y: number;\n}\n\nexport interface Rectangle {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nexport interface BounceResult {\n  newPosition: Vector2D;\n  newVelocity: Vector2D;\n  bounced: boolean;\n}\n\n/**\n * Check collision between two rectangles\n */\nexport function checkRectCollision(\n  x1: number,\n  y1: number,\n  w1: number,\n  h1: number,\n  x2: number,\n  y2: number,\n  w2: number,\n  h2: number\n): boolean {\n  return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;\n}\n\n/**\n * Bounce off rectangular boundaries\n * Returns new position and velocity after bounce\n * Position is the center of the object, size is the collision size\n * Handles corners properly by detecting when both boundaries are hit\n */\nexport function bounceOffBoundaries(\n  position: Vector2D,\n  velocity: Vector2D,\n  size: number,\n  boundaries: {\n    left: number;\n    right: number;\n    top: number;\n    bottom: number;\n  }\n): BounceResult {\n  let newX = position.x;\n  let newY = position.y;\n  let newVx = velocity.x;\n  let newVy = velocity.y;\n  let bounced = false;\n  // No padding - objects can navigate right up to walls with no gap\n  const padding = 0;\n\n  // Check which boundaries are being hit\n  const hitLeft = newX - padding < boundaries.left;\n  const hitRight = newX + padding > boundaries.right;\n  const hitTop = newY - padding < boundaries.top;\n  const hitBottom = newY + padding > boundaries.bottom;\n\n  // Handle corner collisions (when two boundaries are hit)\n  if ((hitLeft || hitRight) && (hitTop || hitBottom)) {\n    // Corner collision - bounce both velocities\n    if (hitLeft) {\n      newX = boundaries.left + padding;\n      newVx = -newVx;\n    } else if (hitRight) {\n      newX = boundaries.right - padding;\n      newVx = -newVx;\n    }\n\n    if (hitTop) {\n      newY = boundaries.top + padding;\n      newVy = -newVy;\n    } else if (hitBottom) {\n      newY = boundaries.bottom - padding;\n      newVy = -newVy;\n    }\n    bounced = true;\n  } else {\n    // Handle edge collisions (single boundary)\n    if (hitLeft) {\n      newX = boundaries.left + padding;\n      newVx = -newVx;\n      bounced = true;\n    } else if (hitRight) {\n      newX = boundaries.right - padding;\n      newVx = -newVx;\n      bounced = true;\n    }\n\n    if (hitTop) {\n      newY = boundaries.top + padding;\n      newVy = -newVy;\n      bounced = true;\n    } else if (hitBottom) {\n      newY = boundaries.bottom - padding;\n      newVy = -newVy;\n      bounced = true;\n    }\n  }\n\n  return {\n    newPosition: { x: newX, y: newY },\n    newVelocity: { x: newVx, y: newVy },\n    bounced,\n  };\n}\n\n/**\n * Bounce off a rectangle barrier\n * Returns new position and velocity after bounce\n * Uses the bullet's previous position to determine collision side more accurately\n */\nexport function bounceOffRectangle(\n  position: Vector2D,\n  velocity: Vector2D,\n  size: number,\n  barrier: Rectangle,\n  previousPosition?: Vector2D\n): BounceResult {\n  const halfSize = size / 2;\n  const bulletLeft = position.x - halfSize;\n  const bulletRight = position.x + halfSize;\n  const bulletTop = position.y - halfSize;\n  const bulletBottom = position.y + halfSize;\n  \n  let newVx = velocity.x;\n  let newVy = velocity.y;\n  let bounced = false;\n\n  // Check if colliding with barrier\n  if (\n    bulletLeft < barrier.x + barrier.width &&\n    bulletRight > barrier.x &&\n    bulletTop < barrier.y + barrier.height &&\n    bulletBottom > barrier.y\n  ) {\n    // Determine which side of the barrier was hit\n    // Use previous position if available for more accurate detection\n    const refX = previousPosition?.x ?? position.x;\n    const refY = previousPosition?.y ?? position.y;\n    \n    // Calculate distances from bullet center to each barrier edge\n    const distToLeft = Math.abs(refX - barrier.x);\n    const distToRight = Math.abs(refX - (barrier.x + barrier.width));\n    const distToTop = Math.abs(refY - barrier.y);\n    const distToBottom = Math.abs(refY - (barrier.y + barrier.height));\n    \n    // Find the closest edge\n    const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);\n    \n    let newX = position.x;\n    let newY = position.y;\n    \n    if (minDist === distToLeft) {\n      // Hit left edge - bounce x velocity and position to left of barrier\n      newVx = -newVx;\n      newX = barrier.x - halfSize;\n      bounced = true;\n    } else if (minDist === distToRight) {\n      // Hit right edge - bounce x velocity and position to right of barrier\n      newVx = -newVx;\n      newX = barrier.x + barrier.width + halfSize;\n      bounced = true;\n    } else if (minDist === distToTop) {\n      // Hit top edge - bounce y velocity and position above barrier\n      newVy = -newVy;\n      newY = barrier.y - halfSize;\n      bounced = true;\n    } else if (minDist === distToBottom) {\n      // Hit bottom edge - bounce y velocity and position below barrier\n      newVy = -newVy;\n      newY = barrier.y + barrier.height + halfSize;\n      bounced = true;\n    }\n\n    return {\n      newPosition: { x: newX, y: newY },\n      newVelocity: { x: newVx, y: newVy },\n      bounced,\n    };\n  }\n\n  return {\n    newPosition: { x: position.x, y: position.y },\n    newVelocity: { x: newVx, y: newVy },\n    bounced: false,\n  };\n}\n\n/**\n * Calculate gravitational acceleration from a point source\n */\nexport function calculateGravity(\n  position: Vector2D,\n  source: Vector2D,\n  config: {\n    gravitationalConstant: number;\n    sourceMass: number;\n    influenceRadius: number;\n    minDistance: number;\n    maxAcceleration?: number;\n  }\n): Vector2D {\n  const dx = source.x - position.x;\n  const dy = source.y - position.y;\n  const distanceSquared = dx * dx + dy * dy;\n\n  // Early exit: check squared distance first (avoid sqrt if outside influence)\n  const influenceRadiusSquared = config.influenceRadius * config.influenceRadius;\n  if (distanceSquared >= influenceRadiusSquared || distanceSquared === 0) {\n    return { x: 0, y: 0 };\n  }\n\n  // Only calculate sqrt when we know we're within influence radius\n  const distance = Math.sqrt(distanceSquared);\n  const effectiveDistance = Math.max(distance, config.minDistance);\n  const effectiveDistanceSquared = effectiveDistance * effectiveDistance;\n\n  // Calculate gravitational acceleration\n  let gravitationalAcceleration = (config.gravitationalConstant * config.sourceMass) / effectiveDistanceSquared;\n\n  // Cap maximum acceleration if specified\n  if (config.maxAcceleration !== undefined) {\n    gravitationalAcceleration = Math.min(gravitationalAcceleration, config.maxAcceleration);\n  }\n\n  // Normalize direction vector\n  const directionX = dx / distance;\n  const directionY = dy / distance;\n\n  return {\n    x: directionX * gravitationalAcceleration,\n    y: directionY * gravitationalAcceleration,\n  };\n}\n\n/**\n * Apply gravity from multiple sources\n * Optimized: early exit if no sources are within influence radius\n */\nexport function applyGravityFromSources(\n  position: Vector2D,\n  sources: Vector2D[],\n  config: {\n    gravitationalConstant: number;\n    sourceMass: number;\n    influenceRadius: number;\n    minDistance: number;\n    maxAcceleration?: number;\n  }\n): Vector2D {\n  let totalAccelerationX = 0;\n  let totalAccelerationY = 0;\n  \n  // Pre-compute squared influence radius for faster distance comparison\n  const influenceRadiusSquared = config.influenceRadius * config.influenceRadius;\n\n  for (const source of sources) {\n    // Quick squared distance check before calling calculateGravity\n    const dx = source.x - position.x;\n    const dy = source.y - position.y;\n    const distanceSquared = dx * dx + dy * dy;\n    \n    // Skip this source if it's outside influence radius (calculateGravity also checks, but this avoids function call overhead)\n    if (distanceSquared >= influenceRadiusSquared || distanceSquared === 0) {\n      continue;\n    }\n    \n    const gravity = calculateGravity(position, source, config);\n    totalAccelerationX += gravity.x;\n    totalAccelerationY += gravity.y;\n  }\n\n  return {\n    x: totalAccelerationX,\n    y: totalAccelerationY,\n  };\n}\n\n/**\n * Ensure minimum velocity to prevent objects from getting stuck\n */\nexport function ensureMinimumVelocity(\n  velocity: Vector2D,\n  minSpeed: number\n): Vector2D {\n  const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n  \n  if (currentSpeed < minSpeed && currentSpeed > 0) {\n    // Normalize and scale to minimum velocity\n    const scale = minSpeed / currentSpeed;\n    return {\n      x: velocity.x * scale,\n      y: velocity.y * scale,\n    };\n  }\n\n  return velocity;\n}\n\n/**\n * Clamp velocity to maximum speed\n */\nexport function clampVelocity(velocity: Vector2D, maxSpeed: number): Vector2D {\n  const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n  \n  if (currentSpeed > maxSpeed) {\n    const scale = maxSpeed / currentSpeed;\n    return {\n      x: velocity.x * scale,\n      y: velocity.y * scale,\n    };\n  }\n\n  return velocity;\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 853, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/constants/game-constants.ts"],"sourcesContent":["/**\n * Game Constants\n * \n * Central location for all magic numbers and configuration values\n * used throughout the game logic.\n */\n\n// Spawn Constants\nexport const SPAWN_PADDING = 8; // Minimum distance from edges\nexport const MAX_SPAWN_ATTEMPTS = 100;\nexport const MIN_SPAWN_DISTANCE = 50; // Minimum distance between spawns\n\n// Bullet Constants\nexport const BULLET_MIN_VELOCITY = 0.5;\n\n// Collision Constants\nexport const COLLISION_EPSILON = 0.001; // Floating point precision tolerance\n\n// AI Controller Constants\nexport const URGENT_THREAT_THRESHOLD = 0.85; // Threat level to trigger dodge\nexport const ENEMY_PREDICTION_TIME_MS = 500; // Time to predict enemy position ahead\nexport const MOVE_FORWARD_ANGLE_TOLERANCE = 60; // Degrees tolerance for forward movement\nexport const MOVE_BACKWARD_ANGLE_TOLERANCE = 120; // Degrees tolerance for backward movement\n\n// Navigation Constants\nexport const MIN_DISTANCE_TO_ENEMY = 50; // Minimum ideal distance to enemy\nexport const TOO_CLOSE_DISTANCE = 30; // Distance considered too close\nexport const DISTANCE_REDUCTION_FACTOR = 0.8; // Factor for reducing distance to enemy\nexport const PATH_CHECK_STEPS = 20; // Steps for path clearance checking\n\n// Threat Assessment Constants\nexport const COLLISION_SIZE_BUFFER = 5; // Buffer pixels for collision detection\nexport const HIGH_THREAT_DISTANCE_MULTIPLIER = 3; // Multiplier for high threat distance\n\n// RL Reward Constants\nexport const TIMEOUT_PENALTY = -100;\nexport const MAX_EPISODE_TIME_MS = 60000; // 60 seconds - maximum episode duration before timeout\nexport const SURVIVAL_REWARD_PER_TICK = 0.01;\nexport const HIT_ENEMY_REWARD = 100;\nexport const GOT_HIT_PENALTY = -100;\nexport const OPTIMAL_DISTANCE_TO_ENEMY = 120; // Optimal distance for engagement\nexport const INACTIVITY_THRESHOLD_MS = 1500; // Time before inactivity penalty\nexport const SIGNIFICANT_MOVEMENT_THRESHOLD = 5; // Pixels - minimum movement to count\nexport const AGGRESSION_CHECK_INTERVAL_MS = 2000; // Time window for aggression check\nexport const DODGE_REWARD_PER_BULLET = 10;\n\n// Canvas Rendering Constants\nexport const CANVAS_SCALE_FACTOR = 2; // Internal resolution multiplier\nexport const GRAVITY_ARROW_GRID_SPACING = 30;\nexport const GRAVITY_ARROW_LENGTH = 8;\nexport const GRAVITY_ARROW_HEAD_SIZE = 3;\nexport const BULLET_DRAW_LENGTH = 6;\nexport const BULLET_DRAW_WIDTH = 3;\nexport const BULLET_DRAW_RADIUS = 1;\nexport const UI_TEXT_SPACING = 12; // Vertical spacing between UI text lines\n\n// Training View Constants\nexport const AI_VS_AI_SPEED_MULTIPLIER = 1;\nexport const MAX_GAMES = 4;\nexport const GAME_DISPLAY_SCALE = 0.45; // Scale factor for game display\n\n// Math Constants\nexport const DEGREES_TO_RADIANS = Math.PI / 180;\nexport const RADIANS_TO_DEGREES = 180 / Math.PI;\n\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GAED,kBAAkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACX,MAAM,gBAAgB,GAAG,8BAA8B;AACvD,MAAM,qBAAqB;AAC3B,MAAM,qBAAqB,IAAI,kCAAkC;AAGjE,MAAM,sBAAsB;AAG5B,MAAM,oBAAoB,OAAO,qCAAqC;AAGtE,MAAM,0BAA0B,MAAM,gCAAgC;AACtE,MAAM,2BAA2B,KAAK,uCAAuC;AAC7E,MAAM,+BAA+B,IAAI,yCAAyC;AAClF,MAAM,gCAAgC,KAAK,0CAA0C;AAGrF,MAAM,wBAAwB,IAAI,kCAAkC;AACpE,MAAM,qBAAqB,IAAI,gCAAgC;AAC/D,MAAM,4BAA4B,KAAK,wCAAwC;AAC/E,MAAM,mBAAmB,IAAI,oCAAoC;AAGjE,MAAM,wBAAwB,GAAG,wCAAwC;AACzE,MAAM,kCAAkC,GAAG,sCAAsC;AAGjF,MAAM,kBAAkB,CAAC;AACzB,MAAM,sBAAsB,OAAO,uDAAuD;AAC1F,MAAM,2BAA2B;AACjC,MAAM,mBAAmB;AACzB,MAAM,kBAAkB,CAAC;AACzB,MAAM,4BAA4B,KAAK,kCAAkC;AACzE,MAAM,0BAA0B,MAAM,iCAAiC;AACvE,MAAM,iCAAiC,GAAG,qCAAqC;AAC/E,MAAM,+BAA+B,MAAM,mCAAmC;AAC9E,MAAM,0BAA0B;AAGhC,MAAM,sBAAsB,GAAG,iCAAiC;AAChE,MAAM,6BAA6B;AACnC,MAAM,uBAAuB;AAC7B,MAAM,0BAA0B;AAChC,MAAM,qBAAqB;AAC3B,MAAM,oBAAoB;AAC1B,MAAM,qBAAqB;AAC3B,MAAM,kBAAkB,IAAI,yCAAyC;AAGrE,MAAM,4BAA4B;AAClC,MAAM,YAAY;AAClB,MAAM,qBAAqB,MAAM,gCAAgC;AAGjE,MAAM,qBAAqB,KAAK,EAAE,GAAG;AACrC,MAAM,qBAAqB,MAAM,KAAK,EAAE"}},
    {"offset": {"line": 979, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/utils/collision.ts"],"sourcesContent":["import { checkRectCollision } from '@/lib/physics';\nimport type { Barrier, Tank, Sun } from '@/app/games/tank-trouble/types';\nimport { TANK_SIZE, TANK_COLLISION_SIZE } from '@/app/games/tank-trouble/config';\nimport { COLLISION_EPSILON } from '@/app/games/tank-trouble/constants/game-constants';\n\n/**\n * Check if a tank position is valid (not colliding with barriers or out of bounds)\n * Note: Tanks can overlap each other - no tank-to-tank collision check\n */\nexport function isValidTankPosition(\n  x: number,\n  y: number,\n  mapWidth: number,\n  mapHeight: number,\n  barriers: Barrier[],\n  tanks: Tank[],\n  suns: Sun[],\n  excludeTankIndex?: number\n): boolean {\n  // Calculate collision box position (centered on tank)\n  const collisionOffset = (TANK_SIZE - TANK_COLLISION_SIZE) / 2;\n  const collisionX = x + collisionOffset;\n  const collisionY = y + collisionOffset;\n  \n  // Check boundaries - allow tanks to be exactly at walls (with small epsilon for floating point precision)\n  if (collisionX < -COLLISION_EPSILON || collisionY < -COLLISION_EPSILON || \n      collisionX + TANK_COLLISION_SIZE > mapWidth + COLLISION_EPSILON || \n      collisionY + TANK_COLLISION_SIZE > mapHeight + COLLISION_EPSILON) {\n    return false;\n  }\n\n  // Check barriers using collision size\n  for (const barrier of barriers) {\n    if (checkRectCollision(collisionX, collisionY, TANK_COLLISION_SIZE, TANK_COLLISION_SIZE, \n                           barrier.x, barrier.y, barrier.width, barrier.height)) {\n      return false;\n    }\n  }\n\n  // Check suns - tanks cannot overlap with suns\n  for (const sun of suns) {\n    const sunLeft = sun.x - sun.size;\n    const sunRight = sun.x + sun.size;\n    const sunTop = sun.y - sun.size;\n    const sunBottom = sun.y + sun.size;\n    \n    if (checkRectCollision(collisionX, collisionY, TANK_COLLISION_SIZE, TANK_COLLISION_SIZE,\n                           sunLeft, sunTop, sunRight - sunLeft, sunBottom - sunTop)) {\n      return false;\n    }\n  }\n\n  // Tanks can now overlap each other - no tank-to-tank collision check\n\n  return true;\n}\n\n/**\n * Check if tank can move to a position (checks barriers, boundaries, and suns)\n * Note: Tanks can overlap each other but not with suns\n */\nexport function canMoveTo(\n  x: number,\n  y: number,\n  mapWidth: number,\n  mapHeight: number,\n  barriers: Barrier[],\n  tanks: Tank[],\n  suns: Sun[],\n  excludeTankIndex?: number\n): boolean {\n  return isValidTankPosition(x, y, mapWidth, mapHeight, barriers, tanks, suns, excludeTankIndex);\n}\n\n"],"names":[],"mappings":";;;;;;AAAA;AAEA;AACA;;;;AAMO,SAAS,oBACd,CAAS,EACT,CAAS,EACT,QAAgB,EAChB,SAAiB,EACjB,QAAmB,EACnB,KAAa,EACb,IAAW,EACX,gBAAyB;IAEzB,sDAAsD;IACtD,MAAM,kBAAkB,CAAC,iKAAS,GAAG,2KAAmB,IAAI;IAC5D,MAAM,aAAa,IAAI;IACvB,MAAM,aAAa,IAAI;IAEvB,0GAA0G;IAC1G,IAAI,aAAa,CAAC,iMAAiB,IAAI,aAAa,CAAC,iMAAiB,IAClE,aAAa,2KAAmB,GAAG,WAAW,iMAAiB,IAC/D,aAAa,2KAAmB,GAAG,YAAY,iMAAiB,EAAE;QACpE,OAAO;IACT;IAEA,sCAAsC;IACtC,KAAK,MAAM,WAAW,SAAU;QAC9B,IAAI,IAAA,+IAAkB,EAAC,YAAY,YAAY,2KAAmB,EAAE,2KAAmB,EAChE,QAAQ,CAAC,EAAE,QAAQ,CAAC,EAAE,QAAQ,KAAK,EAAE,QAAQ,MAAM,GAAG;YAC3E,OAAO;QACT;IACF;IAEA,8CAA8C;IAC9C,KAAK,MAAM,OAAO,KAAM;QACtB,MAAM,UAAU,IAAI,CAAC,GAAG,IAAI,IAAI;QAChC,MAAM,WAAW,IAAI,CAAC,GAAG,IAAI,IAAI;QACjC,MAAM,SAAS,IAAI,CAAC,GAAG,IAAI,IAAI;QAC/B,MAAM,YAAY,IAAI,CAAC,GAAG,IAAI,IAAI;QAElC,IAAI,IAAA,+IAAkB,EAAC,YAAY,YAAY,2KAAmB,EAAE,2KAAmB,EAChE,SAAS,QAAQ,WAAW,SAAS,YAAY,SAAS;YAC/E,OAAO;QACT;IACF;IAEA,qEAAqE;IAErE,OAAO;AACT;AAMO,SAAS,UACd,CAAS,EACT,CAAS,EACT,QAAgB,EAChB,SAAiB,EACjB,QAAmB,EACnB,KAAa,EACb,IAAW,EACX,gBAAyB;IAEzB,OAAO,oBAAoB,GAAG,GAAG,UAAU,WAAW,UAAU,OAAO,MAAM;AAC/E"}},
    {"offset": {"line": 1026, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/utils/math.ts"],"sourcesContent":["/**\n * Math Utilities\n * \n * Common mathematical operations used throughout the game.\n */\n\nimport { DEGREES_TO_RADIANS, RADIANS_TO_DEGREES } from '../constants/game-constants';\n\n/**\n * Calculate Euclidean distance between two points\n */\nexport function distance(x1: number, y1: number, x2: number, y2: number): number {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n/**\n * Calculate Euclidean distance between two point objects\n */\nexport function distancePoints(\n  p1: { x: number; y: number },\n  p2: { x: number; y: number }\n): number {\n  return distance(p1.x, p1.y, p2.x, p2.y);\n}\n\n/**\n * Convert degrees to radians\n */\nexport function degToRad(degrees: number): number {\n  return degrees * DEGREES_TO_RADIANS;\n}\n\n/**\n * Convert radians to degrees\n */\nexport function radToDeg(radians: number): number {\n  return radians * RADIANS_TO_DEGREES;\n}\n\n/**\n * Normalize angle to 0-360 range\n */\nexport function normalizeAngle(angle: number): number {\n  let normalized = angle % 360;\n  if (normalized < 0) normalized += 360;\n  return normalized;\n}\n\n/**\n * Normalize angle difference to -180 to 180 range\n */\nexport function normalizeAngleDifference(angleDiff: number): number {\n  while (angleDiff > 180) angleDiff -= 360;\n  while (angleDiff < -180) angleDiff += 360;\n  return angleDiff;\n}\n\n/**\n * Calculate angle from one point to another in degrees\n */\nexport function angleToPoint(\n  from: { x: number; y: number },\n  to: { x: number; y: number }\n): number {\n  const dx = to.x - from.x;\n  const dy = to.y - from.y;\n  return radToDeg(Math.atan2(dy, dx));\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;CAIC,GAED;;AAKO,SAAS,SAAS,EAAU,EAAE,EAAU,EAAE,EAAU,EAAE,EAAU;IACrE,MAAM,KAAK,KAAK;IAChB,MAAM,KAAK,KAAK;IAChB,OAAO,KAAK,IAAI,CAAC,KAAK,KAAK,KAAK;AAClC;AAKO,SAAS,eACd,EAA4B,EAC5B,EAA4B;IAE5B,OAAO,SAAS,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC;AACxC;AAKO,SAAS,SAAS,OAAe;IACtC,OAAO,UAAU,kMAAkB;AACrC;AAKO,SAAS,SAAS,OAAe;IACtC,OAAO,UAAU,kMAAkB;AACrC;AAKO,SAAS,eAAe,KAAa;IAC1C,IAAI,aAAa,QAAQ;IACzB,IAAI,aAAa,GAAG,cAAc;IAClC,OAAO;AACT;AAKO,SAAS,yBAAyB,SAAiB;IACxD,MAAO,YAAY,IAAK,aAAa;IACrC,MAAO,YAAY,CAAC,IAAK,aAAa;IACtC,OAAO;AACT;AAKO,SAAS,aACd,IAA8B,EAC9B,EAA4B;IAE5B,MAAM,KAAK,GAAG,CAAC,GAAG,KAAK,CAAC;IACxB,MAAM,KAAK,GAAG,CAAC,GAAG,KAAK,CAAC;IACxB,OAAO,SAAS,KAAK,KAAK,CAAC,IAAI;AACjC"}},
    {"offset": {"line": 1081, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/utils/bullet-creation.ts"],"sourcesContent":["/**\n * Bullet Creation Utilities\n * \n * Centralized logic for creating bullet objects.\n */\n\nimport type { Bullet, Tank } from '@/app/games/tank-trouble/types';\nimport { TANK_SIZE, BULLET_SPEED, GAME_CONFIG } from '@/app/games/tank-trouble/config';\nimport { degToRad } from './math';\n\n/**\n * Create a bullet from a tank's position and angle\n */\nexport function createBullet(\n  tank: Tank,\n  angle: number,\n  tickTime: number,\n  owner: 'blue' | 'red'\n): Bullet {\n  const rad = degToRad(angle);\n  const bulletX =\n    tank.x +\n    TANK_SIZE / 2 +\n    Math.cos(rad) * (TANK_SIZE / 2 + GAME_CONFIG.tank.spawnOffset);\n  const bulletY =\n    tank.y +\n    TANK_SIZE / 2 +\n    Math.sin(rad) * (TANK_SIZE / 2 + GAME_CONFIG.tank.spawnOffset);\n\n  return {\n    x: bulletX,\n    y: bulletY,\n    angle: angle,\n    speed: BULLET_SPEED,\n    owner: owner,\n    createdAt: tickTime,\n    vx: Math.cos(rad) * BULLET_SPEED,\n    vy: Math.sin(rad) * BULLET_SPEED,\n  };\n}\n\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AAGD;AACA;;;AAKO,SAAS,aACd,IAAU,EACV,KAAa,EACb,QAAgB,EAChB,KAAqB;IAErB,MAAM,MAAM,IAAA,uKAAQ,EAAC;IACrB,MAAM,UACJ,KAAK,CAAC,GACN,iKAAS,GAAG,IACZ,KAAK,GAAG,CAAC,OAAO,CAAC,iKAAS,GAAG,IAAI,mKAAW,CAAC,IAAI,CAAC,WAAW;IAC/D,MAAM,UACJ,KAAK,CAAC,GACN,iKAAS,GAAG,IACZ,KAAK,GAAG,CAAC,OAAO,CAAC,iKAAS,GAAG,IAAI,mKAAW,CAAC,IAAI,CAAC,WAAW;IAE/D,OAAO;QACL,GAAG;QACH,GAAG;QACH,OAAO;QACP,OAAO,oKAAY;QACnB,OAAO;QACP,WAAW;QACX,IAAI,KAAK,GAAG,CAAC,OAAO,oKAAY;QAChC,IAAI,KAAK,GAAG,CAAC,OAAO,oKAAY;IAClC;AACF"}},
    {"offset": {"line": 1112, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/utils/tank-utils.ts"],"sourcesContent":["/**\n * Tank Utilities\n * \n * Common operations for tank manipulation.\n */\n\nimport type { Tank } from '@/app/games/tank-trouble/types';\nimport { TANK_SIZE, TANK_COLLISION_SIZE, TANK_HALF_SIZE } from '@/app/games/tank-trouble/config';\n\n/**\n * Get the center point of a tank\n */\nexport function getTankCenter(tank: Tank): { x: number; y: number } {\n  return {\n    x: tank.x + TANK_HALF_SIZE,\n    y: tank.y + TANK_HALF_SIZE,\n  };\n}\n\n/**\n * Clamp tank position to keep collision box within map bounds\n */\nexport function clampTankPosition(\n  x: number,\n  y: number,\n  mapWidth: number,\n  mapHeight: number\n): { x: number; y: number } {\n  const collisionOffset = (TANK_SIZE - TANK_COLLISION_SIZE) / 2;\n  const clampedX = Math.max(\n    -collisionOffset,\n    Math.min(x, mapWidth - TANK_SIZE + collisionOffset)\n  );\n  const clampedY = Math.max(\n    -collisionOffset,\n    Math.min(y, mapHeight - TANK_SIZE + collisionOffset)\n  );\n  return { x: clampedX, y: clampedY };\n}\n\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;;;AAGD;;AAKO,SAAS,cAAc,IAAU;IACtC,OAAO;QACL,GAAG,KAAK,CAAC,GAAG,sKAAc;QAC1B,GAAG,KAAK,CAAC,GAAG,sKAAc;IAC5B;AACF;AAKO,SAAS,kBACd,CAAS,EACT,CAAS,EACT,QAAgB,EAChB,SAAiB;IAEjB,MAAM,kBAAkB,CAAC,iKAAS,GAAG,2KAAmB,IAAI;IAC5D,MAAM,WAAW,KAAK,GAAG,CACvB,CAAC,iBACD,KAAK,GAAG,CAAC,GAAG,WAAW,iKAAS,GAAG;IAErC,MAAM,WAAW,KAAK,GAAG,CACvB,CAAC,iBACD,KAAK,GAAG,CAAC,GAAG,YAAY,iKAAS,GAAG;IAEtC,OAAO;QAAE,GAAG;QAAU,GAAG;IAAS;AACpC"}},
    {"offset": {"line": 1143, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/utils/bullet-optimization.ts"],"sourcesContent":["/**\n * Optimized bullet collision utilities\n * \n * Pre-computes bullet groupings to reduce O(n) operations to O(n)\n */\n\nimport type { Bullet } from '@/app/games/tank-trouble/types';\nimport { distance } from './math';\nimport { GAME_CONFIG } from '../config';\n\n/**\n * Group bullets by owner for faster collision detection\n * Returns a map: owner -> array of bullet indices\n */\nexport function groupBulletsByOwner(bullets: Bullet[]): Map<'blue' | 'red', number[]> {\n  const groups = new Map<'blue' | 'red', number[]>();\n  \n  for (let i = 0; i < bullets.length; i++) {\n    const bullet = bullets[i];\n    if (bullet.exploding) continue;\n    \n    const indices = groups.get(bullet.owner) || [];\n    indices.push(i);\n    groups.set(bullet.owner, indices);\n  }\n  \n  return groups;\n}\n\n/**\n * Count bullets by owner using Map for O(1) lookup\n * More efficient than filtering on every call\n */\nexport function countBulletsByOwner(bullets: Bullet[]): Map<'blue' | 'red', number> {\n  const counts = new Map<'blue' | 'red', number>();\n  \n  for (const bullet of bullets) {\n    if (!bullet.exploding) {\n      counts.set(bullet.owner, (counts.get(bullet.owner) || 0) + 1);\n    }\n  }\n  \n  return counts;\n}\n\n/**\n * Optimized bullet-bullet collision detection\n * Reduces O(n) to O(n) by only checking bullets from different owners\n */\nexport function detectBulletCollisions(\n  bullets: Bullet[],\n  bulletGroups: Map<'blue' | 'red', number[]>\n): Set<number> {\n  const collisions = new Set<number>();\n  const checked = new Set<string>();\n  const collisionSize = GAME_CONFIG.bullet.collisionSize;\n  \n  const blueIndices = bulletGroups.get('blue') || [];\n  const redIndices = bulletGroups.get('red') || [];\n  \n  // Only check blue vs red bullets (not same owner)\n  // This reduces from O(n) to O(blue_count * red_count), which is typically much smaller\n  for (const i of blueIndices) {\n    if (collisions.has(i)) continue;\n    const bullet = bullets[i];\n    if (bullet.exploding) continue;\n    \n    for (const j of redIndices) {\n      if (collisions.has(j)) continue;\n      const otherBullet = bullets[j];\n      if (otherBullet.exploding) continue;\n      \n      // Create unique key to avoid duplicate checks\n      const key = `${Math.min(i, j)}-${Math.max(i, j)}`;\n      if (checked.has(key)) continue;\n      checked.add(key);\n      \n      const dist = distance(bullet.x, bullet.y, otherBullet.x, otherBullet.y);\n      if (dist < collisionSize) {\n        collisions.add(i);\n        collisions.add(j);\n        break; // This bullet collided, no need to check more\n      }\n    }\n  }\n  \n  return collisions;\n}\n\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;;;;;AAGD;AACA;;;AAMO,SAAS,oBAAoB,OAAiB;IACnD,MAAM,SAAS,IAAI;IAEnB,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,MAAM,EAAE,IAAK;QACvC,MAAM,SAAS,OAAO,CAAC,EAAE;QACzB,IAAI,OAAO,SAAS,EAAE;QAEtB,MAAM,UAAU,OAAO,GAAG,CAAC,OAAO,KAAK,KAAK,EAAE;QAC9C,QAAQ,IAAI,CAAC;QACb,OAAO,GAAG,CAAC,OAAO,KAAK,EAAE;IAC3B;IAEA,OAAO;AACT;AAMO,SAAS,oBAAoB,OAAiB;IACnD,MAAM,SAAS,IAAI;IAEnB,KAAK,MAAM,UAAU,QAAS;QAC5B,IAAI,CAAC,OAAO,SAAS,EAAE;YACrB,OAAO,GAAG,CAAC,OAAO,KAAK,EAAE,CAAC,OAAO,GAAG,CAAC,OAAO,KAAK,KAAK,CAAC,IAAI;QAC7D;IACF;IAEA,OAAO;AACT;AAMO,SAAS,uBACd,OAAiB,EACjB,YAA2C;IAE3C,MAAM,aAAa,IAAI;IACvB,MAAM,UAAU,IAAI;IACpB,MAAM,gBAAgB,mKAAW,CAAC,MAAM,CAAC,aAAa;IAEtD,MAAM,cAAc,aAAa,GAAG,CAAC,WAAW,EAAE;IAClD,MAAM,aAAa,aAAa,GAAG,CAAC,UAAU,EAAE;IAEhD,kDAAkD;IAClD,wFAAwF;IACxF,KAAK,MAAM,KAAK,YAAa;QAC3B,IAAI,WAAW,GAAG,CAAC,IAAI;QACvB,MAAM,SAAS,OAAO,CAAC,EAAE;QACzB,IAAI,OAAO,SAAS,EAAE;QAEtB,KAAK,MAAM,KAAK,WAAY;YAC1B,IAAI,WAAW,GAAG,CAAC,IAAI;YACvB,MAAM,cAAc,OAAO,CAAC,EAAE;YAC9B,IAAI,YAAY,SAAS,EAAE;YAE3B,8CAA8C;YAC9C,MAAM,MAAM,GAAG,KAAK,GAAG,CAAC,GAAG,GAAG,CAAC,EAAE,KAAK,GAAG,CAAC,GAAG,IAAI;YACjD,IAAI,QAAQ,GAAG,CAAC,MAAM;YACtB,QAAQ,GAAG,CAAC;YAEZ,MAAM,OAAO,IAAA,uKAAQ,EAAC,OAAO,CAAC,EAAE,OAAO,CAAC,EAAE,YAAY,CAAC,EAAE,YAAY,CAAC;YACtE,IAAI,OAAO,eAAe;gBACxB,WAAW,GAAG,CAAC;gBACf,WAAW,GAAG,CAAC;gBACf,OAAO,8CAA8C;YACvD;QACF;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 1213, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/utils/tank.ts"],"sourcesContent":["import type { Tank, Bullet, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport { TANK_SPEED, ROTATION_SPEED, GAME_CONFIG, MAX_BULLETS_PER_TANK } from '@/app/games/tank-trouble/config';\nimport { canMoveTo } from '@/app/games/tank-trouble/utils/collision';\nimport { createBullet } from '@/app/games/tank-trouble/utils/bullet-creation';\nimport { clampTankPosition } from '@/app/games/tank-trouble/utils/tank-utils';\nimport { degToRad } from '@/app/games/tank-trouble/utils/math';\nimport { countBulletsByOwner } from '@/app/games/tank-trouble/utils/bullet-optimization';\n\nexport interface UpdateTankParams {\n  tank: Tank;\n  tankIndex: number;\n  keys: Set<string>;\n  tickTime: number;\n  lastShotTime: number;\n  bullets: Bullet[];\n  mapWidth: number;\n  mapHeight: number;\n  barriers: Barrier[];\n  suns: Sun[];\n  allTanks: Tank[];\n}\n\nexport interface UpdateTankResult {\n  updatedTank: Tank;\n  newBullets: Bullet[];\n  lastShotTime: number;\n}\n\n/**\n * Player control key mappings\n */\nexport interface PlayerControls {\n  rotateLeft: string;\n  rotateRight: string;\n  moveForward: string;\n  moveBackward: string;\n  shoot: string;\n}\n\n/**\n * Update tank movement and shooting using control mappings\n */\nfunction updatePlayerTank(\n  params: UpdateTankParams,\n  controls: PlayerControls,\n  owner: 'blue' | 'red'\n): UpdateTankResult {\n  const { tank, keys, tickTime, lastShotTime, bullets, mapWidth, mapHeight, barriers, suns, allTanks, tankIndex } = params;\n  \n  let newAngle = tank.angle;\n  let newX = tank.x;\n  let newY = tank.y;\n  const newBullets: Bullet[] = [];\n  let newLastShotTime = lastShotTime;\n\n  // Handle rotation\n  if (keys.has(controls.rotateLeft)) {\n    newAngle -= ROTATION_SPEED;\n  }\n  if (keys.has(controls.rotateRight)) {\n    newAngle += ROTATION_SPEED;\n  }\n\n  // Handle forward movement\n  if (keys.has(controls.moveForward)) {\n    const rad = degToRad(newAngle);\n    const dx = Math.cos(rad) * TANK_SPEED;\n    const dy = Math.sin(rad) * TANK_SPEED;\n    const testX = newX + dx;\n    const testY = newY + dy;\n    if (canMoveTo(testX, testY, mapWidth, mapHeight, barriers, allTanks, suns, tankIndex)) {\n      newX = testX;\n      newY = testY;\n    }\n  }\n\n  // Handle backward movement\n  if (keys.has(controls.moveBackward)) {\n    const rad = degToRad(newAngle);\n    const dx = -Math.cos(rad) * TANK_SPEED;\n    const dy = -Math.sin(rad) * TANK_SPEED;\n    const testX = newX + dx;\n    const testY = newY + dy;\n    if (canMoveTo(testX, testY, mapWidth, mapHeight, barriers, allTanks, suns, tankIndex)) {\n      newX = testX;\n      newY = testY;\n    }\n  }\n\n  // Handle shooting\n  if (keys.has(controls.shoot) && tickTime - lastShotTime > GAME_CONFIG.game.shootingCooldown) {\n    // Use optimized bullet counting instead of filter (O(n) instead of O(n) but cached result)\n    const bulletCounts = countBulletsByOwner(bullets);\n    const bulletCount = bulletCounts.get(owner) || 0;\n    if (bulletCount < MAX_BULLETS_PER_TANK) {\n      const bullet = createBullet(\n        { ...tank, x: newX, y: newY, angle: newAngle },\n        newAngle,\n        tickTime,\n        owner\n      );\n      newBullets.push(bullet);\n      newLastShotTime = tickTime;\n    }\n  }\n\n  // Clamp position to ensure collision box stays within bounds\n  const clamped = clampTankPosition(newX, newY, mapWidth, mapHeight);\n\n  return {\n    updatedTank: { ...tank, x: clamped.x, y: clamped.y, angle: newAngle },\n    newBullets,\n    lastShotTime: newLastShotTime,\n  };\n}\n\n/**\n * Update tank movement and shooting for Player 1 (Blue) - Arrow keys + Space\n */\nexport function updatePlayer1Tank(params: UpdateTankParams): UpdateTankResult {\n  return updatePlayerTank(params, {\n    rotateLeft: 'arrowleft',\n    rotateRight: 'arrowright',\n    moveForward: 'arrowup',\n    moveBackward: 'arrowdown',\n    shoot: ' ',\n  }, 'blue');\n}\n\n/**\n * Update tank movement and shooting for Player 2 (Red) - WASD + Q\n */\nexport function updatePlayer2Tank(params: UpdateTankParams): UpdateTankResult {\n  return updatePlayerTank(params, {\n    rotateLeft: 'a',\n    rotateRight: 'd',\n    moveForward: 'w',\n    moveBackward: 's',\n    shoot: 'q',\n  }, 'red');\n}\n\n"],"names":[],"mappings":";;;;;;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAiCA;;CAEC,GACD,SAAS,iBACP,MAAwB,EACxB,QAAwB,EACxB,KAAqB;IAErB,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,YAAY,EAAE,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,GAAG;IAElH,IAAI,WAAW,KAAK,KAAK;IACzB,IAAI,OAAO,KAAK,CAAC;IACjB,IAAI,OAAO,KAAK,CAAC;IACjB,MAAM,aAAuB,EAAE;IAC/B,IAAI,kBAAkB;IAEtB,kBAAkB;IAClB,IAAI,KAAK,GAAG,CAAC,SAAS,UAAU,GAAG;QACjC,YAAY,sKAAc;IAC5B;IACA,IAAI,KAAK,GAAG,CAAC,SAAS,WAAW,GAAG;QAClC,YAAY,sKAAc;IAC5B;IAEA,0BAA0B;IAC1B,IAAI,KAAK,GAAG,CAAC,SAAS,WAAW,GAAG;QAClC,MAAM,MAAM,IAAA,uKAAQ,EAAC;QACrB,MAAM,KAAK,KAAK,GAAG,CAAC,OAAO,kKAAU;QACrC,MAAM,KAAK,KAAK,GAAG,CAAC,OAAO,kKAAU;QACrC,MAAM,QAAQ,OAAO;QACrB,MAAM,QAAQ,OAAO;QACrB,IAAI,IAAA,6KAAS,EAAC,OAAO,OAAO,UAAU,WAAW,UAAU,UAAU,MAAM,YAAY;YACrF,OAAO;YACP,OAAO;QACT;IACF;IAEA,2BAA2B;IAC3B,IAAI,KAAK,GAAG,CAAC,SAAS,YAAY,GAAG;QACnC,MAAM,MAAM,IAAA,uKAAQ,EAAC;QACrB,MAAM,KAAK,CAAC,KAAK,GAAG,CAAC,OAAO,kKAAU;QACtC,MAAM,KAAK,CAAC,KAAK,GAAG,CAAC,OAAO,kKAAU;QACtC,MAAM,QAAQ,OAAO;QACrB,MAAM,QAAQ,OAAO;QACrB,IAAI,IAAA,6KAAS,EAAC,OAAO,OAAO,UAAU,WAAW,UAAU,UAAU,MAAM,YAAY;YACrF,OAAO;YACP,OAAO;QACT;IACF;IAEA,kBAAkB;IAClB,IAAI,KAAK,GAAG,CAAC,SAAS,KAAK,KAAK,WAAW,eAAe,mKAAW,CAAC,IAAI,CAAC,gBAAgB,EAAE;QAC3F,2FAA2F;QAC3F,MAAM,eAAe,IAAA,oMAAmB,EAAC;QACzC,MAAM,cAAc,aAAa,GAAG,CAAC,UAAU;QAC/C,IAAI,cAAc,4KAAoB,EAAE;YACtC,MAAM,SAAS,IAAA,yLAAY,EACzB;gBAAE,GAAG,IAAI;gBAAE,GAAG;gBAAM,GAAG;gBAAM,OAAO;YAAS,GAC7C,UACA,UACA;YAEF,WAAW,IAAI,CAAC;YAChB,kBAAkB;QACpB;IACF;IAEA,6DAA6D;IAC7D,MAAM,UAAU,IAAA,yLAAiB,EAAC,MAAM,MAAM,UAAU;IAExD,OAAO;QACL,aAAa;YAAE,GAAG,IAAI;YAAE,GAAG,QAAQ,CAAC;YAAE,GAAG,QAAQ,CAAC;YAAE,OAAO;QAAS;QACpE;QACA,cAAc;IAChB;AACF;AAKO,SAAS,kBAAkB,MAAwB;IACxD,OAAO,iBAAiB,QAAQ;QAC9B,YAAY;QACZ,aAAa;QACb,aAAa;QACb,cAAc;QACd,OAAO;IACT,GAAG;AACL;AAKO,SAAS,kBAAkB,MAAwB;IACxD,OAAO,iBAAiB,QAAQ;QAC9B,YAAY;QACZ,aAAa;QACb,aAAa;QACb,cAAc;QACd,OAAO;IACT,GAAG;AACL"}},
    {"offset": {"line": 1322, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/utils/bullet.ts"],"sourcesContent":["import type { Bullet, Tank, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport {\n  bounceOffBoundaries,\n  bounceOffRectangle,\n  applyGravityFromSources,\n  ensureMinimumVelocity,\n  type Vector2D,\n  type Rectangle,\n} from '@/lib/physics';\nimport {\n  BULLET_MAX_AGE,\n  BULLET_SPEED,\n  G,\n  mSun,\n  SUN_INFLUENCE_RADIUS,\n  GAME_CONFIG,\n  TANK_COLLISION_SIZE,\n  TANK_SIZE,\n} from '@/app/games/tank-trouble/config';\nimport { BULLET_MIN_VELOCITY } from '@/app/games/tank-trouble/constants/game-constants';\nimport { distance, radToDeg } from '@/app/games/tank-trouble/utils/math';\nimport { detectBulletCollisions, groupBulletsByOwner } from '@/app/games/tank-trouble/utils/bullet-optimization';\n\n// Cache for sun sources (suns are static during gameplay)\nlet cachedSunSources: Vector2D[] | null = null;\nlet cachedSunsReference: Sun[] | null = null;\nlet cachedDisableSunGravity: boolean | null = null;\n\n// Cache for gravity config (only maxAcceleration depends on BULLET_SPEED)\nlet cachedGravityConfig: {\n  gravitationalConstant: number;\n  sourceMass: number;\n  influenceRadius: number;\n  minDistance: number;\n  maxAcceleration: number;\n} | null = null;\nlet cachedBulletSpeed: number | null = null;\n\n/**\n * Get or compute sun sources array (cached for performance)\n */\nfunction getSunSources(suns: Sun[]): Vector2D[] {\n  const disableSunGravity = GAME_CONFIG.debug.disableSunGravity;\n  \n  // Check if suns array reference changed, disable flag changed, or cache is invalid\n  if (cachedSunSources === null || \n      cachedSunsReference !== suns || \n      cachedDisableSunGravity !== disableSunGravity) {\n    if (disableSunGravity) {\n      cachedSunSources = [];\n    } else {\n      cachedSunSources = suns.map((sun) => ({\n        x: sun.x,\n        y: sun.y,\n      }));\n    }\n    cachedSunsReference = suns;\n    cachedDisableSunGravity = disableSunGravity;\n  }\n  return cachedSunSources;\n}\n\n/**\n * Get or compute gravity config (cached for performance)\n */\nfunction getGravityConfig(): {\n  gravitationalConstant: number;\n  sourceMass: number;\n  influenceRadius: number;\n  minDistance: number;\n  maxAcceleration: number;\n} {\n  // Check if BULLET_SPEED changed (only maxAcceleration depends on it)\n  if (cachedGravityConfig === null || cachedBulletSpeed !== BULLET_SPEED) {\n    cachedGravityConfig = {\n      gravitationalConstant: G,\n      sourceMass: mSun,\n      influenceRadius: SUN_INFLUENCE_RADIUS,\n      minDistance: GAME_CONFIG.sun.minDistance,\n      maxAcceleration: BULLET_SPEED * 0.3, // Max 30% of bullet speed per frame\n    };\n    cachedBulletSpeed = BULLET_SPEED;\n  }\n  return cachedGravityConfig;\n}\n\ninterface UpdateBulletsParams {\n  bullets: Bullet[];\n  tickTime: number;\n  mapWidth: number;\n  mapHeight: number;\n  barriers: Barrier[];\n  suns: Sun[];\n  tanks: Tank[];\n}\n\ninterface UpdateBulletsResult {\n  updatedBullets: Bullet[];\n  updatedTanks: Tank[];\n}\n\n/**\n * Update all bullets - handle physics, collisions, and tank hits\n */\nexport function updateBullets(params: UpdateBulletsParams): UpdateBulletsResult {\n  const { bullets, tickTime, mapWidth, mapHeight, barriers, suns, tanks } = params;\n  \n  const updatedBullets: Bullet[] = [];\n  const updatedTanks = [...tanks];\n  const bulletCollisionSize = GAME_CONFIG.bullet.collisionSize;\n\n  // First pass: optimized bullet-bullet collision detection\n  // Groups bullets by owner first, reducing O(n) to O(blue_count * red_count)\n  const bulletGroups = groupBulletsByOwner(bullets);\n  const bulletsToRemove = detectBulletCollisions(bullets, bulletGroups);\n\n  // Get cached sun sources (only recomputed if suns array reference changes)\n  const sunSources = getSunSources(suns);\n\n  // Get cached gravity config (only recomputed if BULLET_SPEED changes)\n  const gravityConfig = getGravityConfig();\n\n  // Second pass: update remaining bullets\n  for (let i = 0; i < bullets.length; i++) {\n    if (bulletsToRemove.has(i)) continue;\n    \n    const bullet = bullets[i];\n    \n    // Remove exploding bullets immediately (no animation)\n    if (bullet.exploding) {\n      continue;\n    }\n\n    // Check bullet age - bullets fade away instead of exploding\n    const age = tickTime - bullet.createdAt;\n    if (age > BULLET_MAX_AGE) {\n      // Remove bullet after fade duration\n      const fadeDuration = GAME_CONFIG.bullet.fadeDuration;\n      if (age > BULLET_MAX_AGE + fadeDuration) {\n        continue; // Bullet has faded completely, remove it\n      }\n      // Keep bullet but mark as fading (will be handled in rendering)\n    }\n\n    // Apply gravitational force from suns (skip if disabled via debug flag)\n    const gravityAcceleration = GAME_CONFIG.debug.disableSunGravity\n      ? { x: 0, y: 0 }\n      : applyGravityFromSources(\n          { x: bullet.x, y: bullet.y },\n          sunSources,\n          gravityConfig\n        );\n\n    // Update velocity with gravitational acceleration\n    let newVx = bullet.vx + gravityAcceleration.x;\n    let newVy = bullet.vy + gravityAcceleration.y;\n\n    // Ensure minimum velocity to prevent bullets from getting stuck (very small minimum to prevent division by zero)\n    const velocity = ensureMinimumVelocity({ x: newVx, y: newVy }, BULLET_MIN_VELOCITY);\n    newVx = velocity.x;\n    newVy = velocity.y;\n\n    // Allow gravity to slow bullets naturally - no minimum speed enforcement\n\n    // Update position using velocity\n    let newX = bullet.x + newVx;\n    let newY = bullet.y + newVy;\n\n    // Bounce off boundaries (walls)\n    const boundaryBounce = bounceOffBoundaries(\n      { x: newX, y: newY },\n      { x: newVx, y: newVy },\n      bulletCollisionSize,\n      {\n        left: 0,\n        right: mapWidth,\n        top: 0,\n        bottom: mapHeight,\n      }\n    );\n    newX = boundaryBounce.newPosition.x;\n    newY = boundaryBounce.newPosition.y;\n    newVx = boundaryBounce.newVelocity.x;\n    newVy = boundaryBounce.newVelocity.y;\n\n    // Check collision with barriers - bounce off barriers\n    // Early exit when collision found - barriers array is typically small so O(n) is acceptable\n    for (const barrier of barriers) {\n      const barrierRect: Rectangle = {\n        x: barrier.x,\n        y: barrier.y,\n        width: barrier.width,\n        height: barrier.height,\n      };\n\n      const barrierBounce = bounceOffRectangle(\n        { x: newX, y: newY },\n        { x: newVx, y: newVy },\n        bulletCollisionSize,\n        barrierRect,\n        { x: bullet.x, y: bullet.y } // Previous position for accurate side detection\n      );\n\n      if (barrierBounce.bounced) {\n        newX = barrierBounce.newPosition.x;\n        newY = barrierBounce.newPosition.y;\n        newVx = barrierBounce.newVelocity.x;\n        newVy = barrierBounce.newVelocity.y;\n        break; // Only one barrier collision per tick\n      }\n    }\n\n    // Check collision with tanks\n    let hitTank = false;\n    for (let j = 0; j < updatedTanks.length; j++) {\n      const tank = updatedTanks[j];\n      if (tank.lives > 0) {\n        // Check if tank is invincible (recently respawned)\n        const isInvincible = tank.invincibleUntil !== undefined && tickTime < tank.invincibleUntil;\n        if (isInvincible) {\n          // Tank is invincible, skip collision check\n          continue;\n        }\n        \n        const bulletLeft = newX - bulletCollisionSize / 2;\n        const bulletTop = newY - bulletCollisionSize / 2;\n        const bulletRight = newX + bulletCollisionSize / 2;\n        const bulletBottom = newY + bulletCollisionSize / 2;\n        \n        // Calculate tank collision box (centered on tank position)\n        const tankCollisionOffset = (TANK_SIZE - TANK_COLLISION_SIZE) / 2;\n        const tankCollisionLeft = tank.x + tankCollisionOffset;\n        const tankCollisionTop = tank.y + tankCollisionOffset;\n        const tankCollisionRight = tankCollisionLeft + TANK_COLLISION_SIZE;\n        const tankCollisionBottom = tankCollisionTop + TANK_COLLISION_SIZE;\n        \n        // Check if bullet rectangle overlaps with tank collision rectangle\n        if (\n          bulletLeft < tankCollisionRight &&\n          bulletRight > tankCollisionLeft &&\n          bulletTop < tankCollisionBottom &&\n          bulletBottom > tankCollisionTop\n        ) {\n          // Tank hit! Decrease lives and respawn immediately\n          const newLives = tank.lives - 1;\n          // Use random spawn (will be handled by game logic)\n          updatedTanks[j] = {\n            ...tank,\n            lives: newLives,\n          };\n          hitTank = true;\n          break;\n        }\n      }\n    }\n    \n    if (hitTank) {\n      // Bullet hits tank - remove immediately (no animation)\n      continue;\n    }\n\n    // Update angle based on new velocity\n    const newAngle = radToDeg(Math.atan2(newVy, newVx));\n    \n    updatedBullets.push({\n      ...bullet,\n      x: newX,\n      y: newY,\n      angle: newAngle,\n      vx: newVx,\n      vy: newVy,\n    });\n  }\n\n  return {\n    updatedBullets,\n    updatedTanks,\n  };\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1535, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/utils/spawn.ts"],"sourcesContent":["import type { Tank, SpawnPosition, TankTroubleMapData, Sun } from '@/app/games/tank-trouble/types';\nimport { GAME_CONFIG, TANK_SIZE } from '@/app/games/tank-trouble/config';\nimport { isValidTankPosition } from '@/app/games/tank-trouble/utils/collision';\nimport { MAX_SPAWN_ATTEMPTS, SPAWN_PADDING, MIN_SPAWN_DISTANCE } from '@/app/games/tank-trouble/constants/game-constants';\nimport { distancePoints } from '@/app/games/tank-trouble/utils/math';\n\n/**\n * Generate a random valid spawn position for a tank\n */\nexport function generateRandomSpawnPosition(\n  mapData: TankTroubleMapData,\n  barriers: Array<{ x: number; y: number; width: number; height: number }>,\n  tanks: Tank[],\n  suns: Sun[],\n  excludePosition?: { x: number; y: number }\n): SpawnPosition {\n  if (!mapData || typeof mapData.width !== 'number' || typeof mapData.height !== 'number') {\n    // Fallback to safe defaults - use type guard utility for validation\n    return {\n      x: 90,\n      y: 90,\n      angle: 0,\n    };\n  }\n  \n  const maxAttempts = MAX_SPAWN_ATTEMPTS;\n  const padding = SPAWN_PADDING;\n  \n  // Validate map dimensions\n  const mapWidth = mapData.width;\n  const mapHeight = mapData.height;\n  const availableWidth = mapWidth - TANK_SIZE - padding * 2;\n  const availableHeight = mapHeight - TANK_SIZE - padding * 2;\n  \n  if (isNaN(availableWidth) || isNaN(availableHeight) || availableWidth <= 0 || availableHeight <= 0) {\n    // Fallback to spawn points\n    if (mapData.spawnPoints && mapData.spawnPoints.length > 0) {\n      return {\n        x: mapData.spawnPoints[0].x,\n        y: mapData.spawnPoints[0].y,\n        angle: mapData.spawnPoints[0].angle,\n      };\n    }\n    return {\n      x: padding,\n      y: padding,\n      angle: 0,\n    };\n  }\n  \n  for (let attempt = 0; attempt < maxAttempts; attempt++) {\n    const x = padding + Math.random() * availableWidth;\n    const y = padding + Math.random() * availableHeight;\n    \n    // Check if position is too close to exclude position (if provided)\n    if (excludePosition) {\n      const dist = distancePoints({ x, y }, excludePosition);\n      if (dist < MIN_SPAWN_DISTANCE) {\n        continue;\n      }\n    }\n    \n    // Check if position is valid (no barrier or sun collision)\n    if (isValidTankPosition(x, y, mapData.width, mapData.height, barriers, tanks, suns)) {\n      // Tanks can overlap, so no distance check needed\n      // Random angle between 0 and 360\n      const angle = Math.random() * 360;\n      return { x, y, angle };\n    }\n  }\n  \n  // Fallback to default spawn points if random generation fails\n  const spawnPoints = mapData.spawnPoints;\n  if (!spawnPoints || spawnPoints.length === 0) {\n    // Last resort: return a safe default position if spawn points are missing\n    return {\n      x: padding,\n      y: padding,\n      angle: 0,\n    };\n  }\n  \n  // Try each spawn point until we find a valid one\n  for (const spawnPoint of spawnPoints) {\n    if (isValidTankPosition(spawnPoint.x, spawnPoint.y, mapData.width, mapData.height, barriers, tanks, suns)) {\n      // Check exclude position if provided\n      if (excludePosition) {\n        const dist = distancePoints(spawnPoint, excludePosition);\n        if (dist < MIN_SPAWN_DISTANCE) {\n          continue;\n        }\n      }\n      return {\n        x: spawnPoint.x,\n        y: spawnPoint.y,\n        angle: spawnPoint.angle,\n      };\n    }\n  }\n  \n  // If all spawn points are invalid, use the first one anyway (last resort)\n  return {\n    x: spawnPoints[0].x,\n    y: spawnPoints[0].y,\n    angle: spawnPoints[0].angle,\n  };\n}\n\n/**\n * Generate random initial spawn positions for both tanks\n * Explicitly excludes all death/respawn state to ensure clean tank state\n */\nexport function getInitialSpawnPositions(\n  mapData: TankTroubleMapData,\n  barriers: Array<{ x: number; y: number; width: number; height: number }>,\n  suns: Sun[]\n): Tank[] {\n  \n  const blueSpawn = generateRandomSpawnPosition(mapData, barriers || [], [], suns || []);\n  \n  // Validate blue spawn position\n  if (typeof blueSpawn.x !== 'number' || typeof blueSpawn.y !== 'number' || isNaN(blueSpawn.x) || isNaN(blueSpawn.y)) {\n    // Fallback to safe default\n    blueSpawn.x = 90;\n    blueSpawn.y = 90;\n    blueSpawn.angle = 0;\n  }\n  \n  // Create blue tank object to pass to red spawn generation (for collision checking)\n  const blueTank: Tank = {\n    x: blueSpawn.x,\n    y: blueSpawn.y,\n    angle: blueSpawn.angle,\n    lives: GAME_CONFIG.tank.lives,\n    color: 'blue',\n  };\n  const redSpawn = generateRandomSpawnPosition(mapData, barriers, [blueTank], suns, blueSpawn);\n  \n  // Validate red spawn position\n  if (typeof redSpawn.x !== 'number' || typeof redSpawn.y !== 'number' || isNaN(redSpawn.x) || isNaN(redSpawn.y)) {\n    // Fallback to safe default (different from blue)\n    redSpawn.x = mapData.spawnPoints && mapData.spawnPoints.length > 1 ? mapData.spawnPoints[1].x : 390;\n    redSpawn.y = mapData.spawnPoints && mapData.spawnPoints.length > 1 ? mapData.spawnPoints[1].y : 270;\n    redSpawn.angle = mapData.spawnPoints && mapData.spawnPoints.length > 1 ? mapData.spawnPoints[1].angle : 180;\n  }\n  \n  return [\n    { \n      x: blueSpawn.x, \n      y: blueSpawn.y, \n      angle: blueSpawn.angle, \n      lives: GAME_CONFIG.tank.lives, \n      color: 'blue',\n      // Explicitly exclude death/respawn state\n      exploding: undefined,\n      explosionStartTime: undefined,\n      respawning: undefined,\n      respawnStartTime: undefined,\n      respawnTargetX: undefined,\n      respawnTargetY: undefined,\n      respawnTargetAngle: undefined,\n    },\n    { \n      x: redSpawn.x, \n      y: redSpawn.y, \n      angle: redSpawn.angle, \n      lives: GAME_CONFIG.tank.lives, \n      color: 'red',\n      // Explicitly exclude death/respawn state\n      exploding: undefined,\n      explosionStartTime: undefined,\n      respawning: undefined,\n      respawnStartTime: undefined,\n      respawnTargetX: undefined,\n      respawnTargetY: undefined,\n      respawnTargetAngle: undefined,\n    },\n  ];\n}\n\n"],"names":[],"mappings":";;;;;;AACA;AACA;AACA;AACA;;;;;AAKO,SAAS,4BACd,OAA2B,EAC3B,QAAwE,EACxE,KAAa,EACb,IAAW,EACX,eAA0C;IAE1C,IAAI,CAAC,WAAW,OAAO,QAAQ,KAAK,KAAK,YAAY,OAAO,QAAQ,MAAM,KAAK,UAAU;QACvF,oEAAoE;QACpE,OAAO;YACL,GAAG;YACH,GAAG;YACH,OAAO;QACT;IACF;IAEA,MAAM,cAAc,kMAAkB;IACtC,MAAM,UAAU,6LAAa;IAE7B,0BAA0B;IAC1B,MAAM,WAAW,QAAQ,KAAK;IAC9B,MAAM,YAAY,QAAQ,MAAM;IAChC,MAAM,iBAAiB,WAAW,iKAAS,GAAG,UAAU;IACxD,MAAM,kBAAkB,YAAY,iKAAS,GAAG,UAAU;IAE1D,IAAI,MAAM,mBAAmB,MAAM,oBAAoB,kBAAkB,KAAK,mBAAmB,GAAG;QAClG,2BAA2B;QAC3B,IAAI,QAAQ,WAAW,IAAI,QAAQ,WAAW,CAAC,MAAM,GAAG,GAAG;YACzD,OAAO;gBACL,GAAG,QAAQ,WAAW,CAAC,EAAE,CAAC,CAAC;gBAC3B,GAAG,QAAQ,WAAW,CAAC,EAAE,CAAC,CAAC;gBAC3B,OAAO,QAAQ,WAAW,CAAC,EAAE,CAAC,KAAK;YACrC;QACF;QACA,OAAO;YACL,GAAG;YACH,GAAG;YACH,OAAO;QACT;IACF;IAEA,IAAK,IAAI,UAAU,GAAG,UAAU,aAAa,UAAW;QACtD,MAAM,IAAI,UAAU,KAAK,MAAM,KAAK;QACpC,MAAM,IAAI,UAAU,KAAK,MAAM,KAAK;QAEpC,mEAAmE;QACnE,IAAI,iBAAiB;YACnB,MAAM,OAAO,IAAA,6KAAc,EAAC;gBAAE;gBAAG;YAAE,GAAG;YACtC,IAAI,OAAO,kMAAkB,EAAE;gBAC7B;YACF;QACF;QAEA,2DAA2D;QAC3D,IAAI,IAAA,uLAAmB,EAAC,GAAG,GAAG,QAAQ,KAAK,EAAE,QAAQ,MAAM,EAAE,UAAU,OAAO,OAAO;YACnF,iDAAiD;YACjD,iCAAiC;YACjC,MAAM,QAAQ,KAAK,MAAM,KAAK;YAC9B,OAAO;gBAAE;gBAAG;gBAAG;YAAM;QACvB;IACF;IAEA,8DAA8D;IAC9D,MAAM,cAAc,QAAQ,WAAW;IACvC,IAAI,CAAC,eAAe,YAAY,MAAM,KAAK,GAAG;QAC5C,0EAA0E;QAC1E,OAAO;YACL,GAAG;YACH,GAAG;YACH,OAAO;QACT;IACF;IAEA,iDAAiD;IACjD,KAAK,MAAM,cAAc,YAAa;QACpC,IAAI,IAAA,uLAAmB,EAAC,WAAW,CAAC,EAAE,WAAW,CAAC,EAAE,QAAQ,KAAK,EAAE,QAAQ,MAAM,EAAE,UAAU,OAAO,OAAO;YACzG,qCAAqC;YACrC,IAAI,iBAAiB;gBACnB,MAAM,OAAO,IAAA,6KAAc,EAAC,YAAY;gBACxC,IAAI,OAAO,kMAAkB,EAAE;oBAC7B;gBACF;YACF;YACA,OAAO;gBACL,GAAG,WAAW,CAAC;gBACf,GAAG,WAAW,CAAC;gBACf,OAAO,WAAW,KAAK;YACzB;QACF;IACF;IAEA,0EAA0E;IAC1E,OAAO;QACL,GAAG,WAAW,CAAC,EAAE,CAAC,CAAC;QACnB,GAAG,WAAW,CAAC,EAAE,CAAC,CAAC;QACnB,OAAO,WAAW,CAAC,EAAE,CAAC,KAAK;IAC7B;AACF;AAMO,SAAS,yBACd,OAA2B,EAC3B,QAAwE,EACxE,IAAW;IAGX,MAAM,YAAY,4BAA4B,SAAS,YAAY,EAAE,EAAE,EAAE,EAAE,QAAQ,EAAE;IAErF,+BAA+B;IAC/B,IAAI,OAAO,UAAU,CAAC,KAAK,YAAY,OAAO,UAAU,CAAC,KAAK,YAAY,MAAM,UAAU,CAAC,KAAK,MAAM,UAAU,CAAC,GAAG;QAClH,2BAA2B;QAC3B,UAAU,CAAC,GAAG;QACd,UAAU,CAAC,GAAG;QACd,UAAU,KAAK,GAAG;IACpB;IAEA,mFAAmF;IACnF,MAAM,WAAiB;QACrB,GAAG,UAAU,CAAC;QACd,GAAG,UAAU,CAAC;QACd,OAAO,UAAU,KAAK;QACtB,OAAO,mKAAW,CAAC,IAAI,CAAC,KAAK;QAC7B,OAAO;IACT;IACA,MAAM,WAAW,4BAA4B,SAAS,UAAU;QAAC;KAAS,EAAE,MAAM;IAElF,8BAA8B;IAC9B,IAAI,OAAO,SAAS,CAAC,KAAK,YAAY,OAAO,SAAS,CAAC,KAAK,YAAY,MAAM,SAAS,CAAC,KAAK,MAAM,SAAS,CAAC,GAAG;QAC9G,iDAAiD;QACjD,SAAS,CAAC,GAAG,QAAQ,WAAW,IAAI,QAAQ,WAAW,CAAC,MAAM,GAAG,IAAI,QAAQ,WAAW,CAAC,EAAE,CAAC,CAAC,GAAG;QAChG,SAAS,CAAC,GAAG,QAAQ,WAAW,IAAI,QAAQ,WAAW,CAAC,MAAM,GAAG,IAAI,QAAQ,WAAW,CAAC,EAAE,CAAC,CAAC,GAAG;QAChG,SAAS,KAAK,GAAG,QAAQ,WAAW,IAAI,QAAQ,WAAW,CAAC,MAAM,GAAG,IAAI,QAAQ,WAAW,CAAC,EAAE,CAAC,KAAK,GAAG;IAC1G;IAEA,OAAO;QACL;YACE,GAAG,UAAU,CAAC;YACd,GAAG,UAAU,CAAC;YACd,OAAO,UAAU,KAAK;YACtB,OAAO,mKAAW,CAAC,IAAI,CAAC,KAAK;YAC7B,OAAO;YACP,yCAAyC;YACzC,WAAW;YACX,oBAAoB;YACpB,YAAY;YACZ,kBAAkB;YAClB,gBAAgB;YAChB,gBAAgB;YAChB,oBAAoB;QACtB;QACA;YACE,GAAG,SAAS,CAAC;YACb,GAAG,SAAS,CAAC;YACb,OAAO,SAAS,KAAK;YACrB,OAAO,mKAAW,CAAC,IAAI,CAAC,KAAK;YAC7B,OAAO;YACP,yCAAyC;YACzC,WAAW;YACX,oBAAoB;YACpB,YAAY;YACZ,kBAAkB;YAClB,gBAAgB;YAChB,gBAAgB;YAChB,oBAAoB;QACtB;KACD;AACH"}},
    {"offset": {"line": 1703, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/prediction.ts"],"sourcesContent":["import type { Bullet, Sun, Barrier } from '@/app/games/tank-trouble/types';\nimport type { PredictedBulletPath } from './types';\nimport {\n  applyGravityFromSources,\n  bounceOffBoundaries,\n  bounceOffRectangle,\n  ensureMinimumVelocity,\n  type Vector2D,\n  type Rectangle,\n} from '@/lib/physics';\nimport {\n  BULLET_SPEED,\n  G,\n  mSun,\n  SUN_INFLUENCE_RADIUS,\n  GAME_CONFIG,\n  TICK_INTERVAL,\n} from '@/app/games/tank-trouble/config';\nimport { BULLET_MIN_VELOCITY } from '@/app/games/tank-trouble/constants/game-constants';\n\n/**\n * Predict bullet trajectory accounting for sun gravity and collisions\n */\nexport function predictBulletPath(\n  bullet: Bullet,\n  suns: Sun[],\n  barriers: Barrier[],\n  mapWidth: number,\n  mapHeight: number,\n  maxTime: number,\n  stepSize: number = TICK_INTERVAL\n): PredictedBulletPath {\n  const points: Array<{ x: number; y: number; time: number }> = [];\n  let currentX = bullet.x;\n  let currentY = bullet.y;\n  let currentVx = bullet.vx;\n  let currentVy = bullet.vy;\n  let currentTime = 0;\n  const bulletCollisionSize = GAME_CONFIG.bullet.collisionSize;\n  let isBlocked = false;\n\n  // Convert suns to vector sources (pre-compute once, skip if disabled via debug flag)\n  const sunSources: Vector2D[] = GAME_CONFIG.debug.disableSunGravity\n    ? []\n    : suns.map((sun) => ({\n        x: sun.x,\n        y: sun.y,\n      }));\n\n  // Pre-compute gravity config (avoid recreating object in loop)\n  const gravityConfig = {\n    gravitationalConstant: G,\n    sourceMass: mSun,\n    influenceRadius: SUN_INFLUENCE_RADIUS,\n    minDistance: GAME_CONFIG.sun.minDistance,\n    maxAcceleration: BULLET_SPEED * 0.3,\n  };\n\n  // Store initial point\n  points.push({ x: currentX, y: currentY, time: currentTime });\n\n  while (currentTime < maxTime && !isBlocked) {\n    // Apply gravity (skip if disabled via debug flag)\n    const gravityAcceleration = GAME_CONFIG.debug.disableSunGravity\n      ? { x: 0, y: 0 }\n      : applyGravityFromSources(\n          { x: currentX, y: currentY },\n          sunSources,\n          gravityConfig\n        );\n\n    // Update velocity\n    let newVx = currentVx + gravityAcceleration.x;\n    let newVy = currentVy + gravityAcceleration.y;\n\n    // Ensure minimum velocity\n    const velocity = ensureMinimumVelocity({ x: newVx, y: newVy }, BULLET_MIN_VELOCITY);\n    newVx = velocity.x;\n    newVy = velocity.y;\n\n    // Update position\n    let newX = currentX + newVx;\n    let newY = currentY + newVy;\n\n    // Check boundary collision\n    const boundaryBounce = bounceOffBoundaries(\n      { x: newX, y: newY },\n      { x: newVx, y: newVy },\n      bulletCollisionSize,\n      {\n        left: 0,\n        right: mapWidth,\n        top: 0,\n        bottom: mapHeight,\n      }\n    );\n\n    if (boundaryBounce.bounced) {\n      newX = boundaryBounce.newPosition.x;\n      newY = boundaryBounce.newPosition.y;\n      newVx = boundaryBounce.newVelocity.x;\n      newVy = boundaryBounce.newVelocity.y;\n    }\n\n    // Check barrier collision\n    for (const barrier of barriers) {\n      const barrierRect: Rectangle = {\n        x: barrier.x,\n        y: barrier.y,\n        width: barrier.width,\n        height: barrier.height,\n      };\n\n      const barrierBounce = bounceOffRectangle(\n        { x: newX, y: newY },\n        { x: newVx, y: newVy },\n        bulletCollisionSize,\n        barrierRect,\n        { x: currentX, y: currentY }\n      );\n\n      if (barrierBounce.bounced) {\n        newX = barrierBounce.newPosition.x;\n        newY = barrierBounce.newPosition.y;\n        newVx = barrierBounce.newVelocity.x;\n        newVy = barrierBounce.newVelocity.y;\n        // Continue after bounce\n      }\n    }\n\n    currentX = newX;\n    currentY = newY;\n    currentVx = newVx;\n    currentVy = newVy;\n    currentTime += stepSize;\n\n    // Add point (sample every few steps to reduce memory)\n    if (points.length === 0 || currentTime - points[points.length - 1].time >= stepSize * 5) {\n      points.push({ x: currentX, y: currentY, time: currentTime });\n    }\n\n    // Stop if bullet is moving too slowly (stuck in sun)\n    const speed = Math.sqrt(newVx * newVx + newVy * newVy);\n    if (speed < BULLET_MIN_VELOCITY) {\n      isBlocked = true;\n      break;\n    }\n  }\n\n  return {\n    points,\n    isBlocked,\n    endTime: currentTime,\n  };\n}\n\n/**\n * Predict where a tank will be based on current velocity/position\n * Uses simple linear extrapolation\n */\nexport function predictTankPosition(\n  tank: { x: number; y: number; angle: number },\n  timeAhead: number,\n  tankSpeed: number\n): { x: number; y: number } {\n  const rad = (tank.angle * Math.PI) / 180;\n  const dx = Math.cos(rad) * tankSpeed * (timeAhead / TICK_INTERVAL);\n  const dy = Math.sin(rad) * tankSpeed * (timeAhead / TICK_INTERVAL);\n  return {\n    x: tank.x + dx,\n    y: tank.y + dy,\n  };\n}\n\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1849, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/threat-assessment.ts"],"sourcesContent":["import type { Bullet, Tank, Sun, Barrier } from '@/app/games/tank-trouble/types';\nimport type { Threat } from './types';\nimport { predictBulletPath } from './prediction';\nimport { TANK_SIZE, TANK_COLLISION_SIZE } from '@/app/games/tank-trouble/config';\nimport { getTankCenter } from '@/app/games/tank-trouble/utils/tank-utils';\nimport { distance, angleToPoint, radToDeg } from '@/app/games/tank-trouble/utils/math';\nimport { COLLISION_SIZE_BUFFER, HIGH_THREAT_DISTANCE_MULTIPLIER } from '@/app/games/tank-trouble/constants/game-constants';\n\n/**\n * Assess threats from incoming bullets\n */\nexport function assessThreats(\n  tank: Tank,\n  bullets: Bullet[],\n  suns: Sun[],\n  barriers: Barrier[],\n  mapWidth: number,\n  mapHeight: number,\n  maxPredictionTime: number\n): Threat[] {\n  const threats: Threat[] = [];\n\n  for (const bullet of bullets) {\n    // Skip own bullets and exploding bullets\n    if (bullet.owner === tank.color || bullet.exploding) {\n      continue;\n    }\n\n    // Predict bullet path\n    const path = predictBulletPath(\n      bullet,\n      suns,\n      barriers,\n      mapWidth,\n      mapHeight,\n      maxPredictionTime,\n      16 // Use smaller steps for accuracy\n    );\n\n    // Check if path gets close to tank\n    let closestDistance = Infinity;\n    let closestTime = 0;\n    let collisionPoint = { x: bullet.x, y: bullet.y };\n\n    // Calculate tank center once (reused for all points)\n    const tankCenter = getTankCenter(tank);\n    const hitThreshold = TANK_COLLISION_SIZE + COLLISION_SIZE_BUFFER;\n\n    // Early exit optimization: if we find a collision, break immediately\n    for (const point of path.points) {\n      // Distance from bullet to tank center\n      const dist = distance(point.x, point.y, tankCenter.x, tankCenter.y);\n\n      // Check if bullet would hit tank (within collision size)\n      if (dist < hitThreshold) {\n        closestDistance = dist;\n        closestTime = point.time;\n        collisionPoint = { x: point.x, y: point.y };\n        break; // Early exit when collision detected\n      }\n\n      if (dist < closestDistance) {\n        closestDistance = dist;\n        closestTime = point.time;\n        collisionPoint = { x: point.x, y: point.y };\n      }\n    }\n\n    // Calculate threat level based on distance and time\n    const threatDistanceThreshold = TANK_COLLISION_SIZE * HIGH_THREAT_DISTANCE_MULTIPLIER;\n    if (closestDistance < threatDistanceThreshold) {\n      // High threat if very close\n      const timeFactor = Math.max(0, 1 - closestTime / maxPredictionTime);\n      const distanceFactor = Math.max(\n        0,\n        1 - closestDistance / threatDistanceThreshold\n      );\n      const threatLevel = (timeFactor + distanceFactor) / 2;\n\n      threats.push({\n        bullet,\n        timeToCollision: closestTime,\n        closestDistance,\n        collisionPoint,\n        threatLevel: Math.min(1, threatLevel),\n      });\n    }\n  }\n\n  // Sort by threat level (most dangerous first)\n  threats.sort((a, b) => b.threatLevel - a.threatLevel);\n\n  return threats;\n}\n\n/**\n * Check if a position is safe from bullets\n */\nexport function isPositionSafe(\n  x: number,\n  y: number,\n  bullets: Bullet[],\n  suns: Sun[],\n  barriers: Barrier[],\n  mapWidth: number,\n  mapHeight: number,\n  predictionTime: number,\n  safeMargin: number\n): boolean {\n  // Check each bullet\n  for (const bullet of bullets) {\n    if (bullet.exploding) continue;\n\n    const path = predictBulletPath(\n      bullet,\n      suns,\n      barriers,\n      mapWidth,\n      mapHeight,\n      predictionTime,\n      16\n    );\n\n    // Check if any point gets too close (early exit optimization)\n    const safeDistance = TANK_COLLISION_SIZE + safeMargin;\n    for (const point of path.points) {\n      const dist = distance(point.x, point.y, x, y);\n      if (dist < safeDistance) {\n        return false; // Early exit when unsafe position found\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Find escape direction from threats\n */\nexport function findEscapeDirection(\n  tank: Tank,\n  threats: Threat[],\n  barriers: Barrier[],\n  suns: Sun[],\n  mapWidth: number,\n  mapHeight: number\n): { angle: number; urgency: number } {\n  if (threats.length === 0) {\n    return { angle: tank.angle, urgency: 0 };\n  }\n\n  // Find the most urgent threat\n  const urgentThreat = threats[0];\n  if (urgentThreat.threatLevel < 0.5) {\n    return { angle: tank.angle, urgency: urgentThreat.threatLevel };\n  }\n\n  // Calculate direction away from threat\n  const tankCenter = getTankCenter(tank);\n  const dist = distance(tankCenter.x, tankCenter.y, urgentThreat.collisionPoint.x, urgentThreat.collisionPoint.y);\n\n  if (dist < 1) {\n    // Too close, pick random direction\n    return { angle: (tank.angle + 90) % 360, urgency: 1 };\n  }\n\n  const escapeAngle = angleToPoint(urgentThreat.collisionPoint, tankCenter);\n\n  return {\n    angle: escapeAngle,\n    urgency: urgentThreat.threatLevel,\n  };\n}\n\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1981, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/sun-calculations.ts"],"sourcesContent":["import type { Sun, Tank, Barrier } from '@/app/games/tank-trouble/types';\nimport type { ShotOpportunity } from './types';\nimport { predictBulletPath } from './prediction';\nimport { BULLET_SPEED, TANK_SIZE, GAME_CONFIG, TICK_INTERVAL } from '@/app/games/tank-trouble/config';\nimport { applyGravityFromSources, type Vector2D } from '@/lib/physics';\nimport { G, mSun, SUN_INFLUENCE_RADIUS } from '@/app/games/tank-trouble/config';\n\n/**\n * Calculate if a shot will curve around a sun to hit the target\n */\nexport function findSunLeveragedShot(\n  shooter: Tank,\n  target: { x: number; y: number },\n  suns: Sun[],\n  barriers: Barrier[],\n  mapWidth: number,\n  mapHeight: number,\n  sunSkill: number\n): ShotOpportunity | null {\n  // Only attempt sun shots if skill is high enough\n  if (sunSkill < 0.3 || suns.length === 0) {\n    return null;\n  }\n\n  let bestShot: ShotOpportunity | null = null;\n  let bestConfidence = 0;\n\n  // Check each sun for potential leverage\n  for (const sun of suns) {\n    // Find angles that will curve around this sun toward target\n    const anglesToTest = 16; // Test multiple angles\n    const angleSpread = 60; // Test 60 degrees\n\n    for (let i = 0; i < anglesToTest; i++) {\n      const baseAngle = Math.atan2(\n        target.y - (shooter.y + TANK_SIZE / 2),\n        target.x - (shooter.x + TANK_SIZE / 2)\n      );\n      const testAngle =\n        (baseAngle * 180) / Math.PI +\n        (i / (anglesToTest - 1) - 0.5) * angleSpread;\n\n      // Create test bullet\n      const rad = (testAngle * Math.PI) / 180;\n      const bulletX =\n        shooter.x +\n        TANK_SIZE / 2 +\n        Math.cos(rad) * (TANK_SIZE / 2 + GAME_CONFIG.tank.spawnOffset);\n      const bulletY =\n        shooter.y +\n        TANK_SIZE / 2 +\n        Math.sin(rad) * (TANK_SIZE / 2 + GAME_CONFIG.tank.spawnOffset);\n\n      const testBullet = {\n        x: bulletX,\n        y: bulletY,\n        angle: testAngle,\n        speed: BULLET_SPEED,\n        owner: shooter.color,\n        createdAt: 0,\n        vx: Math.cos(rad) * BULLET_SPEED,\n        vy: Math.sin(rad) * BULLET_SPEED,\n      };\n\n      // Predict path\n      const path = predictBulletPath(\n        testBullet,\n        suns,\n        barriers,\n        mapWidth,\n        mapHeight,\n        3000,\n        TICK_INTERVAL\n      );\n\n      // Check if path gets close to target\n      let closestDistance = Infinity;\n      let closestTime = 0;\n\n      for (const point of path.points) {\n        const dx = point.x - target.x;\n        const dy = point.y - target.y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n\n        if (dist < closestDistance) {\n          closestDistance = dist;\n          closestTime = point.time;\n        }\n\n        // Hit if within tank collision size\n        if (dist < 15) {\n          const confidence = sunSkill * (1 - Math.min(closestDistance / 30, 1));\n          if (confidence > bestConfidence) {\n            bestConfidence = confidence;\n            bestShot = {\n              angle: testAngle,\n              confidence,\n              timeToHit: closestTime,\n              usesSun: true,\n            };\n          }\n        }\n      }\n    }\n  }\n\n  return bestShot;\n}\n\n/**\n * Check if a position is shielded by a sun from another position\n */\nexport function isPositionShieldedBySun(\n  position: { x: number; y: number },\n  attackerPosition: { x: number; y: number },\n  suns: Sun[]\n): boolean {\n  for (const sun of suns) {\n    // Check if sun is between position and attacker\n    const dxToSun = sun.x - position.x;\n    const dyToSun = sun.y - position.y;\n    const dxToAttacker = attackerPosition.x - position.x;\n    const dyToAttacker = attackerPosition.y - position.y;\n\n    // Dot product to check if sun is in same direction as attacker\n    const dot = dxToSun * dxToAttacker + dyToSun * dyToAttacker;\n\n    if (dot > 0) {\n      // Sun is in same direction, check distance\n      const distToSun = Math.sqrt(dxToSun * dxToSun + dyToSun * dyToSun);\n      const distToAttacker = Math.sqrt(\n        dxToAttacker * dxToAttacker + dyToAttacker * dyToAttacker\n      );\n\n      // If sun is closer and large enough to block, we're shielded\n      if (distToSun < distToAttacker && distToSun < sun.size * 2) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Find the best angle to shoot at target considering sun gravity\n * Returns direct shot if better, or sun-leveraged shot\n */\nexport function calculateOptimalShotAngle(\n  shooter: Tank,\n  target: { x: number; y: number },\n  suns: Sun[],\n  barriers: Barrier[],\n  mapWidth: number,\n  mapHeight: number,\n  sunSkill: number\n): ShotOpportunity {\n  // First, try direct shot\n  const directAngle =\n    (Math.atan2(\n      target.y - (shooter.y + TANK_SIZE / 2),\n      target.x - (shooter.x + TANK_SIZE / 2)\n    ) *\n      180) /\n    Math.PI;\n\n  const rad = (directAngle * Math.PI) / 180;\n  const bulletX =\n    shooter.x +\n    TANK_SIZE / 2 +\n    Math.cos(rad) * (TANK_SIZE / 2 + GAME_CONFIG.tank.spawnOffset);\n  const bulletY =\n    shooter.y +\n    TANK_SIZE / 2 +\n    Math.sin(rad) * (TANK_SIZE / 2 + GAME_CONFIG.tank.spawnOffset);\n\n  const testBullet = {\n    x: bulletX,\n    y: bulletY,\n    angle: directAngle,\n    speed: BULLET_SPEED,\n    owner: shooter.color,\n    createdAt: 0,\n    vx: Math.cos(rad) * BULLET_SPEED,\n    vy: Math.sin(rad) * BULLET_SPEED,\n  };\n\n  const directPath = predictBulletPath(\n    testBullet,\n    suns,\n    barriers,\n    mapWidth,\n    mapHeight,\n    3000,\n    TICK_INTERVAL\n  );\n\n  let directConfidence = 0;\n  for (const point of directPath.points) {\n    const dx = point.x - target.x;\n    const dy = point.y - target.y;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    if (dist < 15) {\n      directConfidence = 0.8;\n      break;\n    }\n  }\n\n  // Try sun-leveraged shot\n  const sunShot = findSunLeveragedShot(\n    shooter,\n    target,\n    suns,\n    barriers,\n    mapWidth,\n    mapHeight,\n    sunSkill\n  );\n\n  // Return best shot\n  if (sunShot && sunShot.confidence > directConfidence) {\n    return sunShot;\n  }\n\n  return {\n    angle: directAngle,\n    confidence: directConfidence,\n    timeToHit: 1000, // Estimate\n    usesSun: false,\n  };\n}\n\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2118, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/navigation.ts"],"sourcesContent":["import type { Tank, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport { canMoveTo } from '@/app/games/tank-trouble/utils/collision';\nimport { TANK_SPEED, ROTATION_SPEED } from '@/app/games/tank-trouble/config';\n\n/**\n * Find optimal position relative to enemy\n */\nexport function calculateOptimalPosition(\n  aiTank: Tank,\n  enemyTank: Tank,\n  aggressiveness: number,\n  barriers: Barrier[],\n  suns: Sun[],\n  mapWidth: number,\n  mapHeight: number\n): { x: number; y: number; angle: number } {\n  const aiCenterX = aiTank.x + 12; // Half of TANK_SIZE\n  const aiCenterY = aiTank.y + 12;\n  const enemyCenterX = enemyTank.x + 12;\n  const enemyCenterY = enemyTank.y + 12;\n\n  // Calculate distance to enemy\n  const dx = enemyCenterX - aiCenterX;\n  const dy = enemyCenterY - aiCenterY;\n  const distance = Math.sqrt(dx * dx + dy * dy);\n\n  // Much more aggressive: always move toward enemy, minimal ideal distance\n  // Reduced ideal distance significantly to encourage close combat\n  const idealDistance = 50 + (1 - aggressiveness) * 50; // Reduced from 100 + (1-aggressiveness)*100\n\n  // Calculate angle toward enemy (always approach, never retreat)\n  const angleToEnemy = (Math.atan2(dy, dx) * 180) / Math.PI;\n\n  // Always try to move closer to enemy (removed retreat logic)\n  // Only stop approaching if already very close (within 30 pixels)\n  let targetX = enemyCenterX;\n  let targetY = enemyCenterY;\n\n  if (distance > 30) {\n    // Always move closer if not extremely close\n    const approachAngle = angleToEnemy;\n    // Move to ideal distance, but if already closer, still move forward (just slower)\n    const targetDistance = Math.min(distance * 0.8, idealDistance); // Always reduce distance by 20% minimum\n    targetX =\n      enemyCenterX - Math.cos((approachAngle * Math.PI) / 180) * targetDistance;\n    targetY =\n      enemyCenterY - Math.sin((approachAngle * Math.PI) / 180) * targetDistance;\n  } else {\n    // Very close - stay at current distance but keep facing enemy\n    targetX = aiCenterX;\n    targetY = aiCenterY;\n  }\n\n  // Clamp to map bounds\n  targetX = Math.max(12, Math.min(targetX, mapWidth - 12));\n  targetY = Math.max(12, Math.min(targetY, mapHeight - 12));\n\n  // Calculate angle toward target\n  const targetDx = targetX - aiCenterX;\n  const targetDy = targetY - aiCenterY;\n  const targetAngle =\n    (Math.atan2(targetDy, targetDx) * 180) / Math.PI;\n\n  return {\n    x: targetX - 12, // Convert center to corner\n    y: targetY - 12,\n    angle: targetAngle,\n  };\n}\n\n/**\n * Check if a path is clear to a position\n */\nexport function isPathClear(\n  from: { x: number; y: number },\n  to: { x: number; y: number },\n  barriers: Barrier[],\n  suns: Sun[],\n  tanks: Tank[],\n  mapWidth: number,\n  mapHeight: number,\n  excludeTankIndex?: number\n): boolean {\n  // Simple line-of-sight check (could be improved with proper pathfinding)\n  const steps = 20;\n  const dx = (to.x - from.x) / steps;\n  const dy = (to.y - from.y) / steps;\n\n  for (let i = 0; i <= steps; i++) {\n    const testX = from.x + dx * i;\n    const testY = from.y + dy * i;\n\n    if (\n      !canMoveTo(\n        testX,\n        testY,\n        mapWidth,\n        mapHeight,\n        barriers,\n        tanks,\n        suns,\n        excludeTankIndex\n      )\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Find a safe nearby position when dodging\n */\nexport function findSafeDodgePosition(\n  tank: Tank,\n  dodgeAngle: number,\n  dodgeDistance: number,\n  barriers: Barrier[],\n  suns: Sun[],\n  allTanks: Tank[],\n  mapWidth: number,\n  mapHeight: number,\n  tankIndex: number\n): { x: number; y: number } | null {\n  const rad = (dodgeAngle * Math.PI) / 180;\n  const targetX = tank.x + Math.cos(rad) * dodgeDistance;\n  const targetY = tank.y + Math.sin(rad) * dodgeDistance;\n\n  // Check if target position is valid\n  if (\n    canMoveTo(\n      targetX,\n      targetY,\n      mapWidth,\n      mapHeight,\n      barriers,\n      allTanks,\n      suns,\n      tankIndex\n    )\n  ) {\n    return { x: targetX, y: targetY };\n  }\n\n  // Try perpendicular directions\n  const perpAngle1 = (dodgeAngle + 90) % 360;\n  const perpAngle2 = (dodgeAngle - 90 + 360) % 360;\n\n  for (const angle of [perpAngle1, perpAngle2]) {\n    const rad = (angle * Math.PI) / 180;\n    const testX = tank.x + Math.cos(rad) * dodgeDistance;\n    const testY = tank.y + Math.sin(rad) * dodgeDistance;\n\n    if (\n      canMoveTo(\n        testX,\n        testY,\n        mapWidth,\n        mapHeight,\n        barriers,\n        allTanks,\n        suns,\n        tankIndex\n      )\n    ) {\n      return { x: testX, y: testY };\n    }\n  }\n\n  // Try smaller distance\n  if (dodgeDistance > 20) {\n    return findSafeDodgePosition(\n      tank,\n      dodgeAngle,\n      dodgeDistance * 0.5,\n      barriers,\n      suns,\n      allTanks,\n      mapWidth,\n      mapHeight,\n      tankIndex\n    );\n  }\n\n  return null;\n}\n\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2223, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/rl-actions.ts"],"sourcesContent":["/**\n * Action Space Definition\n * \n * Defines the action space for the RL agent and converts between\n * RL actions and game decisions.\n */\n\nimport type { AIDecision } from './types';\nimport { ROTATION_SPEED } from '@/app/games/tank-trouble/config';\nimport { assertType } from '@/lib/type-guards';\n\n/**\n * Discrete action space\n * \n * Each action is a number representing a combination of movements.\n * This is easier to train than continuous actions.\n */\nexport enum DiscreteAction {\n  NO_ACTION = 0,\n  ROTATE_LEFT = 1,\n  ROTATE_RIGHT = 2,\n  MOVE_FORWARD = 3,\n  MOVE_BACKWARD = 4,\n  SHOOT = 5,\n  ROTATE_LEFT_FORWARD = 6,\n  ROTATE_RIGHT_FORWARD = 7,\n  ROTATE_LEFT_SHOOT = 8,\n  ROTATE_RIGHT_SHOOT = 9,\n  MOVE_FORWARD_SHOOT = 10,\n  MOVE_BACKWARD_SHOOT = 11,\n  ROTATE_LEFT_BACKWARD = 12,\n  ROTATE_RIGHT_BACKWARD = 13,\n}\n\nexport const NUM_DISCRETE_ACTIONS = 14;\n\n/**\n * Continuous action space\n * \n * For more flexible control, use continuous actions.\n */\nexport interface ContinuousAction {\n  angleDelta: number;      // -1 to 1 (normalized rotation)\n  moveDirection: number;   // -1 to 1 (backward to forward)\n  shouldShoot: number;     // 0 to 1 (probability to shoot)\n}\n\n/**\n * Convert discrete action to game decision\n */\nexport function actionToDecision(\n  action: number | ContinuousAction,\n  currentAngle: number\n): AIDecision {\n  // Handle continuous actions\n  if (typeof action !== 'number') {\n    return {\n      angleDelta: action.angleDelta * ROTATION_SPEED,\n      moveDirection: Math.round(action.moveDirection), // Clamp to -1, 0, 1\n      shouldShoot: action.shouldShoot > 0.5,\n    };\n  }\n\n  // Handle discrete actions\n  // Type guard: ensure action is a valid DiscreteAction enum value\n  const discreteAction = assertType(\n    action,\n    (val): val is DiscreteAction =>\n      typeof val === 'number' && val >= 0 && val < NUM_DISCRETE_ACTIONS,\n    `Invalid discrete action: ${action}`\n  );\n  \n  let angleDelta = 0;\n  let moveDirection = 0;\n  let shouldShoot = false;\n\n  switch (discreteAction) {\n    case DiscreteAction.NO_ACTION:\n      // Do nothing\n      break;\n\n    case DiscreteAction.ROTATE_LEFT:\n      angleDelta = -ROTATION_SPEED;\n      break;\n\n    case DiscreteAction.ROTATE_RIGHT:\n      angleDelta = ROTATION_SPEED;\n      break;\n\n    case DiscreteAction.MOVE_FORWARD:\n      moveDirection = 1;\n      break;\n\n    case DiscreteAction.MOVE_BACKWARD:\n      moveDirection = -1;\n      break;\n\n    case DiscreteAction.SHOOT:\n      shouldShoot = true;\n      break;\n\n    case DiscreteAction.ROTATE_LEFT_FORWARD:\n      angleDelta = -ROTATION_SPEED;\n      moveDirection = 1;\n      break;\n\n    case DiscreteAction.ROTATE_RIGHT_FORWARD:\n      angleDelta = ROTATION_SPEED;\n      moveDirection = 1;\n      break;\n\n    case DiscreteAction.ROTATE_LEFT_SHOOT:\n      angleDelta = -ROTATION_SPEED;\n      shouldShoot = true;\n      break;\n\n    case DiscreteAction.ROTATE_RIGHT_SHOOT:\n      angleDelta = ROTATION_SPEED;\n      shouldShoot = true;\n      break;\n\n    case DiscreteAction.MOVE_FORWARD_SHOOT:\n      moveDirection = 1;\n      shouldShoot = true;\n      break;\n\n    case DiscreteAction.MOVE_BACKWARD_SHOOT:\n      moveDirection = -1;\n      shouldShoot = true;\n      break;\n\n    case DiscreteAction.ROTATE_LEFT_BACKWARD:\n      angleDelta = -ROTATION_SPEED;\n      moveDirection = -1;\n      break;\n\n    case DiscreteAction.ROTATE_RIGHT_BACKWARD:\n      angleDelta = ROTATION_SPEED;\n      moveDirection = -1;\n      break;\n\n    default:\n      // Removed warning log\n  }\n\n  return {\n    angleDelta,\n    moveDirection,\n    shouldShoot,\n  };\n}\n\n/**\n * Convert decision to action (for logging/debugging)\n */\nexport type DecisionToAction = {\n  type: 'discrete' | 'continuous';\n  value: number | ContinuousAction;\n};\n\nexport function decisionToAction(decision: AIDecision): DecisionToAction {\n  // Convert decision back to action representation\n  // This is approximate since multiple actions can map to same decision\n  \n  const hasRotation = Math.abs(decision.angleDelta) > 0.1;\n  const hasMovement = decision.moveDirection !== 0;\n  const hasShoot = decision.shouldShoot;\n\n  if (!hasRotation && !hasMovement && !hasShoot) {\n    return { type: 'discrete', value: DiscreteAction.NO_ACTION };\n  }\n\n  // Try to match to discrete action\n  if (hasRotation && hasMovement && hasShoot) {\n    // Complex combination - use continuous\n    return {\n      type: 'continuous',\n      value: {\n        angleDelta: decision.angleDelta / ROTATION_SPEED,\n        moveDirection: decision.moveDirection,\n        shouldShoot: hasShoot ? 1 : 0,\n      },\n    };\n  }\n\n  // Simple combinations\n  if (hasRotation && decision.angleDelta < 0) {\n    if (hasMovement && decision.moveDirection > 0) {\n      return { type: 'discrete', value: DiscreteAction.ROTATE_LEFT_FORWARD };\n    }\n    if (hasShoot) {\n      return { type: 'discrete', value: DiscreteAction.ROTATE_LEFT_SHOOT };\n    }\n    return { type: 'discrete', value: DiscreteAction.ROTATE_LEFT };\n  }\n\n  if (hasRotation && decision.angleDelta > 0) {\n    if (hasMovement && decision.moveDirection > 0) {\n      return { type: 'discrete', value: DiscreteAction.ROTATE_RIGHT_FORWARD };\n    }\n    if (hasShoot) {\n      return { type: 'discrete', value: DiscreteAction.ROTATE_RIGHT_SHOOT };\n    }\n    return { type: 'discrete', value: DiscreteAction.ROTATE_RIGHT };\n  }\n\n  if (hasMovement && decision.moveDirection > 0) {\n    if (hasShoot) {\n      return { type: 'discrete', value: DiscreteAction.MOVE_FORWARD_SHOOT };\n    }\n    return { type: 'discrete', value: DiscreteAction.MOVE_FORWARD };\n  }\n\n  if (hasMovement && decision.moveDirection < 0) {\n    if (hasShoot) {\n      return { type: 'discrete', value: DiscreteAction.MOVE_BACKWARD_SHOOT };\n    }\n    return { type: 'discrete', value: DiscreteAction.MOVE_BACKWARD };\n  }\n\n  if (hasShoot) {\n    return { type: 'discrete', value: DiscreteAction.SHOOT };\n  }\n\n  return { type: 'discrete', value: DiscreteAction.NO_ACTION };\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2433, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/rl-observation.ts"],"sourcesContent":["/**\n * Observation Space Definition\n * \n * Converts game state into a numerical observation vector for the RL agent.\n * The observation should be normalized and contain all relevant information.\n */\n\nimport type { Tank, Bullet, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport type { AIContext } from './types';\nimport { TANK_SIZE, TANK_SPEED, BULLET_SPEED } from '@/app/games/tank-trouble/config';\n\n// Cache for barrier bounds (barriers are static during gameplay)\ninterface BarrierBounds {\n  left: number;\n  right: number;\n  top: number;\n  bottom: number;\n}\nlet cachedBarrierBounds: BarrierBounds[] | null = null;\nlet cachedBarriersReference: Barrier[] | null = null;\n\n/**\n * Get or compute barrier bounds (cached for performance)\n */\nfunction getBarrierBounds(barriers: Barrier[]): BarrierBounds[] {\n  // Check if barriers array reference changed\n  if (cachedBarrierBounds === null || cachedBarriersReference !== barriers) {\n    cachedBarrierBounds = barriers.map(barrier => ({\n      left: barrier.x,\n      right: barrier.x + barrier.width,\n      top: barrier.y,\n      bottom: barrier.y + barrier.height,\n    }));\n    cachedBarriersReference = barriers;\n  }\n  return cachedBarrierBounds;\n}\n\n/**\n * Observation vector structure\n * \n * This is a flattened array of normalized features:\n * - Tank positions and angles (normalized 0-1)\n * - Enemy positions and angles\n * - Bullet states (fixed-size array)\n * - Sun positions (fixed-size array)\n * - Barrier distances (8 directions)\n * - Game state (lives, time, etc.)\n */\nexport interface Observation {\n  vector: number[];\n  size: number;\n}\n\n// Constants for observation space\nconst MAX_BULLETS = 20; // Maximum bullets to track\nconst MAX_SUNS = 10; // Maximum suns to track\nconst BARRIER_DIRECTIONS = 8; // 8 directions for barrier detection\nconst BULLET_FEATURES = 5; // x, y, vx, vy, owner\nconst SUN_FEATURES = 3; // x, y, size\n\n/**\n * Extract observation from game context\n * \n * Returns a normalized feature vector that the RL agent can use.\n */\nexport function extractObservation(context: AIContext): Observation {\n  const {\n    aiTank,\n    enemyTank,\n    bullets,\n    suns,\n    barriers,\n    mapWidth,\n    mapHeight,\n  } = context;\n\n  const features: number[] = [];\n\n  // 1. AI Tank state (4 features)\n  features.push(normalize(aiTank.x, 0, mapWidth));\n  features.push(normalize(aiTank.y, 0, mapHeight));\n  features.push(normalizeAngle(aiTank.angle));\n  features.push(normalize(aiTank.lives, 0, 3));\n\n  // 2. Enemy Tank state (4 features)\n  features.push(normalize(enemyTank.x, 0, mapWidth));\n  features.push(normalize(enemyTank.y, 0, mapHeight));\n  features.push(normalizeAngle(enemyTank.angle));\n  features.push(normalize(enemyTank.lives, 0, 3));\n\n  // 3. Relative position and distance (3 features)\n  const dx = enemyTank.x - aiTank.x;\n  const dy = enemyTank.y - aiTank.y;\n  const distance = Math.sqrt(dx * dx + dy * dy);\n  const maxDistance = Math.sqrt(mapWidth * mapWidth + mapHeight * mapHeight);\n  \n  features.push(normalize(dx, -mapWidth, mapWidth));\n  features.push(normalize(dy, -mapHeight, mapHeight));\n  features.push(normalize(distance, 0, maxDistance));\n\n  // 4. Angle to enemy (1 feature)\n  const angleToEnemy = (Math.atan2(dy, dx) * 180) / Math.PI;\n  const angleDiff = normalizeAngleDifference(angleToEnemy - aiTank.angle);\n  features.push(angleDiff);\n\n  // 5. Bullet states (MAX_BULLETS * BULLET_FEATURES features)\n  // Optimized: single pass to collect active bullets (avoid filter + slice creating intermediate array)\n  const activeBullets: Bullet[] = [];\n  for (let i = 0; i < bullets.length && activeBullets.length < MAX_BULLETS; i++) {\n    const bullet = bullets[i];\n    if (!bullet.exploding) {\n      activeBullets.push(bullet);\n    }\n  }\n  \n  for (let i = 0; i < MAX_BULLETS; i++) {\n    if (i < activeBullets.length) {\n      const bullet = activeBullets[i];\n      features.push(normalize(bullet.x, 0, mapWidth));\n      features.push(normalize(bullet.y, 0, mapHeight));\n      features.push(normalize(bullet.vx, -BULLET_SPEED * 2, BULLET_SPEED * 2));\n      features.push(normalize(bullet.vy, -BULLET_SPEED * 2, BULLET_SPEED * 2));\n      features.push(bullet.owner === aiTank.color ? 1 : 0); // Owner (0 or 1)\n    } else {\n      // Pad with zeros\n      features.push(0, 0, 0, 0, 0);\n    }\n  }\n\n  // 6. Sun states (MAX_SUNS * SUN_FEATURES features)\n  const activeSuns = (suns || []).slice(0, MAX_SUNS);\n  for (let i = 0; i < MAX_SUNS; i++) {\n    if (i < activeSuns.length) {\n      const sun = activeSuns[i];\n      features.push(normalize(sun.x, 0, mapWidth));\n      features.push(normalize(sun.y, 0, mapHeight));\n      features.push(normalize(sun.size, 0, 100));\n    } else {\n      features.push(0, 0, 0);\n    }\n  }\n\n  // 7. Barrier distances in 8 directions (BARRIER_DIRECTIONS features)\n  const barrierDistances = getBarrierDistances(\n    aiTank.x + TANK_SIZE / 2,\n    aiTank.y + TANK_SIZE / 2,\n    barriers,\n    mapWidth,\n    mapHeight\n  );\n  features.push(...barrierDistances.map(d => normalize(d, 0, Math.max(mapWidth, mapHeight))));\n\n  // 8. Game state (2 features)\n  features.push(normalize(context.tickTime % 10000, 0, 10000)); // Time modulo\n  features.push(normalize(mapWidth, 0, 2000)); // Map size indicator\n\n  // Total: 4 + 4 + 3 + 1 + (20 * 5) + (10 * 3) + 8 + 2 = 152 features\n\n  return {\n    vector: features,\n    size: features.length,\n  };\n}\n\n/**\n * Normalize a value to [0, 1] range\n */\nfunction normalize(value: number, min: number, max: number): number {\n  if (max === min) return 0.5;\n  return Math.max(0, Math.min(1, (value - min) / (max - min)));\n}\n\n/**\n * Normalize angle to [0, 1] range (0-360 degrees -> 0-1)\n */\nfunction normalizeAngle(angle: number): number {\n  // Normalize angle to 0-360\n  let normalized = angle % 360;\n  if (normalized < 0) normalized += 360;\n  return normalized / 360;\n}\n\n/**\n * Normalize angle difference to [-1, 1] range\n */\nfunction normalizeAngleDifference(angleDiff: number): number {\n  // Normalize to -180 to 180\n  while (angleDiff > 180) angleDiff -= 360;\n  while (angleDiff < -180) angleDiff += 360;\n  return angleDiff / 180; // Normalize to -1 to 1\n}\n\n/**\n * Get distances to nearest barriers in 8 directions\n * Optimized with pre-computed barrier bounds\n */\nfunction getBarrierDistances(\n  x: number,\n  y: number,\n  barriers: Barrier[],\n  mapWidth: number,\n  mapHeight: number\n): number[] {\n  const directions = [\n    { dx: 1, dy: 0 },   // Right\n    { dx: 1, dy: 1 },   // Down-right\n    { dx: 0, dy: 1 },   // Down\n    { dx: -1, dy: 1 },  // Down-left\n    { dx: -1, dy: 0 },  // Left\n    { dx: -1, dy: -1 }, // Up-left\n    { dx: 0, dy: -1 },  // Up\n    { dx: 1, dy: -1 },  // Up-right\n  ];\n\n  // Get cached barrier bounds (only recomputed if barriers array reference changes)\n  const barrierBounds = getBarrierBounds(barriers);\n\n  const step = 5; // Check every 5 pixels\n  const maxDistance = Math.max(mapWidth, mapHeight);\n\n  return directions.map(dir => {\n    let distance = 0;\n\n    while (distance < maxDistance) {\n      const testX = x + dir.dx * distance;\n      const testY = y + dir.dy * distance;\n\n      // Check if out of bounds\n      if (testX < 0 || testX > mapWidth || testY < 0 || testY > mapHeight) {\n        break;\n      }\n\n      // Use pre-computed bounds for faster barrier check\n      // Early exit when barrier found\n      let hitBarrier = false;\n      for (const bounds of barrierBounds) {\n        if (\n          testX >= bounds.left &&\n          testX <= bounds.right &&\n          testY >= bounds.top &&\n          testY <= bounds.bottom\n        ) {\n          hitBarrier = true;\n          break;\n        }\n      }\n\n      if (hitBarrier) {\n        break;\n      }\n\n      distance += step;\n    }\n\n    return distance;\n  });\n}\n\n/**\n * Get observation size (for model initialization)\n */\nexport function getObservationSize(): number {\n  return 4 + 4 + 3 + 1 + (MAX_BULLETS * BULLET_FEATURES) + (MAX_SUNS * SUN_FEATURES) + BARRIER_DIRECTIONS + 2;\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2637, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/rl-model.ts"],"sourcesContent":["/**\n * RL Model Interface\n * \n * Defines the interface for RL models and provides a way to load/use\n * trained models. Supports both TensorFlow.js models and custom implementations.\n */\n\nimport type { Observation } from './rl-observation';\nimport type { AIDecision } from './types';\nimport { actionToDecision } from './rl-actions';\nimport { NUM_DISCRETE_ACTIONS } from './rl-actions';\nimport { getObservationSize } from './rl-observation';\n\n/**\n * RL Model interface\n * \n * Any RL model implementation should implement this interface.\n */\nexport interface RLModel {\n  /**\n   * Check if model is loaded and ready\n   */\n  isLoaded(): boolean;\n\n  /**\n   * Load model from URL or path\n   */\n  load(path: string): Promise<void>;\n\n  /**\n   * Predict action from observation\n   * \n   * @param observation - Current game observation\n   * @param currentAngle - Current tank angle (for action conversion)\n   * @returns Decision for the tank\n   */\n  predict(observation: Observation, currentAngle: number): AIDecision;\n\n  /**\n   * Get model info\n   */\n  getInfo(): ModelInfo;\n}\n\nexport interface ModelInfo {\n  name: string;\n  type: 'discrete' | 'continuous';\n  observationSize: number;\n  actionSize: number;\n  version?: string;\n}\n\n/**\n * Simple rule-based model (for testing/fallback)\n * \n * This can be used as a baseline or fallback when RL model isn't available.\n */\nexport class RuleBasedRLModel implements RLModel {\n  private loaded = true;\n\n  isLoaded(): boolean {\n    return this.loaded;\n  }\n\n  async load(_path: string): Promise<void> {\n    this.loaded = true;\n  }\n\n  predict(observation: Observation, currentAngle: number): AIDecision {\n    // Simple rule-based decision based on observation\n    // This is just a placeholder - in practice, you'd use a trained model\n    \n    // Extract some key features\n    const enemyX = observation.vector[4];\n    const enemyY = observation.vector[5];\n    const angleToEnemy = observation.vector[11]; // Normalized angle difference\n    \n    // Simple strategy: rotate toward enemy and shoot\n    let angleDelta = 0;\n    let moveDirection = 0;\n    let shouldShoot = false;\n\n    // Rotate toward enemy\n    if (Math.abs(angleToEnemy) > 0.1) {\n      angleDelta = angleToEnemy > 0 ? 5 : -5;\n    }\n\n    // Move forward if roughly facing enemy\n    if (Math.abs(angleToEnemy) < 0.2) {\n      moveDirection = 1;\n      shouldShoot = true;\n    }\n\n    return {\n      angleDelta,\n      moveDirection,\n      shouldShoot,\n    };\n  }\n\n  getInfo(): ModelInfo {\n    return {\n      name: 'Rule-Based Fallback',\n      type: 'discrete',\n      observationSize: getObservationSize(), // From rl-observation.ts\n      actionSize: NUM_DISCRETE_ACTIONS,\n    };\n  }\n}\n\n/**\n * TensorFlow.js model wrapper\n * \n * This is a placeholder for when you implement TensorFlow.js integration.\n * To use this, you'll need to:\n * 1. Install @tensorflow/tfjs\n * 2. Train a model (Python or TypeScript)\n * 3. Export it in a format TensorFlow.js can load\n * 4. Implement the predict method\n */\n// Extended interface for models that need additional properties\n// This properly extends RLModel with all required methods\nexport interface ExtendedRLModel extends RLModel {\n  // Additional properties for agent integration\n  agent?: unknown;\n}\n\nexport class TensorFlowJSModel implements RLModel {\n  private loaded = false;\n  private model: unknown = null; // tf.LayersModel when implemented\n  private info: ModelInfo;\n\n  constructor(info: ModelInfo) {\n    this.info = info;\n  }\n\n  isLoaded(): boolean {\n    return this.loaded && this.model !== null;\n  }\n\n  async load(path: string): Promise<void> {\n    try {\n      // TODO: Implement TensorFlow.js model loading\n      // Example:\n      // const tf = await import('@tensorflow/tfjs');\n      // this.model = await tf.loadLayersModel(path);\n      // this.loaded = true;\n      \n      // Removed warning logs\n      this.loaded = false;\n    } catch (error) {\n      // Removed error log\n      this.loaded = false;\n      throw error;\n    }\n  }\n\n  predict(observation: Observation, currentAngle: number): AIDecision {\n    if (!this.isLoaded()) {\n      throw new Error('Model not loaded');\n    }\n\n    // TODO: Implement TensorFlow.js prediction\n    // Example:\n    // const tf = await import('@tensorflow/tfjs');\n    // const input = tf.tensor2d([observation.vector]);\n    // const output = this.model.predict(input) as tf.Tensor;\n    // const action = await output.data();\n    // return actionToDecision(action[0], currentAngle);\n\n    throw new Error('TensorFlow.js prediction not yet implemented');\n  }\n\n  getInfo(): ModelInfo {\n    return this.info;\n  }\n}\n\n/**\n * Model manager\n * \n * Manages the current RL model and provides a unified interface.\n */\nexport class RLModelManager {\n  private model: RLModel | null = null;\n  private fallbackModel: RLModel;\n\n  constructor() {\n    this.fallbackModel = new RuleBasedRLModel();\n  }\n\n  /**\n   * Set the active model\n   */\n  setModel(model: RLModel | ExtendedRLModel): void {\n    this.model = model;\n  }\n\n  /**\n   * Get the active model (or fallback)\n   */\n  getModel(): RLModel | ExtendedRLModel {\n    return this.model && this.model.isLoaded() ? this.model : this.fallbackModel;\n  }\n\n  /**\n   * Check if RL model is active\n   */\n  isRLActive(): boolean {\n    return this.model !== null && this.model.isLoaded();\n  }\n\n  /**\n   * Load model from path\n   */\n  async loadModel(path: string): Promise<void> {\n    if (!this.model) {\n      throw new Error('No model set. Call setModel() first.');\n    }\n    await this.model.load(path);\n  }\n}\n\n// Global model manager instance\nexport const rlModelManager = new RLModelManager();\n\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;;;;;AAKD;AACA;;;AA8CO,MAAM;IACH,SAAS,KAAK;IAEtB,WAAoB;QAClB,OAAO,IAAI,CAAC,MAAM;IACpB;IAEA,MAAM,KAAK,KAAa,EAAiB;QACvC,IAAI,CAAC,MAAM,GAAG;IAChB;IAEA,QAAQ,WAAwB,EAAE,YAAoB,EAAc;QAClE,kDAAkD;QAClD,sEAAsE;QAEtE,4BAA4B;QAC5B,MAAM,SAAS,YAAY,MAAM,CAAC,EAAE;QACpC,MAAM,SAAS,YAAY,MAAM,CAAC,EAAE;QACpC,MAAM,eAAe,YAAY,MAAM,CAAC,GAAG,EAAE,8BAA8B;QAE3E,iDAAiD;QACjD,IAAI,aAAa;QACjB,IAAI,gBAAgB;QACpB,IAAI,cAAc;QAElB,sBAAsB;QACtB,IAAI,KAAK,GAAG,CAAC,gBAAgB,KAAK;YAChC,aAAa,eAAe,IAAI,IAAI,CAAC;QACvC;QAEA,uCAAuC;QACvC,IAAI,KAAK,GAAG,CAAC,gBAAgB,KAAK;YAChC,gBAAgB;YAChB,cAAc;QAChB;QAEA,OAAO;YACL;YACA;YACA;QACF;IACF;IAEA,UAAqB;QACnB,OAAO;YACL,MAAM;YACN,MAAM;YACN,iBAAiB,IAAA,mMAAkB;YACnC,YAAY,iMAAoB;QAClC;IACF;AACF;AAmBO,MAAM;IACH,SAAS,MAAM;IACf,QAAiB,KAAK;IACtB,KAAgB;IAExB,YAAY,IAAe,CAAE;QAC3B,IAAI,CAAC,IAAI,GAAG;IACd;IAEA,WAAoB;QAClB,OAAO,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,KAAK,KAAK;IACvC;IAEA,MAAM,KAAK,IAAY,EAAiB;QACtC,IAAI;YACF,8CAA8C;YAC9C,WAAW;YACX,+CAA+C;YAC/C,+CAA+C;YAC/C,sBAAsB;YAEtB,uBAAuB;YACvB,IAAI,CAAC,MAAM,GAAG;QAChB,EAAE,OAAO,OAAO;YACd,oBAAoB;YACpB,IAAI,CAAC,MAAM,GAAG;YACd,MAAM;QACR;IACF;IAEA,QAAQ,WAAwB,EAAE,YAAoB,EAAc;QAClE,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI;YACpB,MAAM,IAAI,MAAM;QAClB;QAEA,2CAA2C;QAC3C,WAAW;QACX,+CAA+C;QAC/C,mDAAmD;QACnD,yDAAyD;QACzD,sCAAsC;QACtC,oDAAoD;QAEpD,MAAM,IAAI,MAAM;IAClB;IAEA,UAAqB;QACnB,OAAO,IAAI,CAAC,IAAI;IAClB;AACF;AAOO,MAAM;IACH,QAAwB,KAAK;IAC7B,cAAuB;IAE/B,aAAc;QACZ,IAAI,CAAC,aAAa,GAAG,IAAI;IAC3B;IAEA;;GAEC,GACD,SAAS,KAAgC,EAAQ;QAC/C,IAAI,CAAC,KAAK,GAAG;IACf;IAEA;;GAEC,GACD,WAAsC;QACpC,OAAO,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,KAAK,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,aAAa;IAC9E;IAEA;;GAEC,GACD,aAAsB;QACpB,OAAO,IAAI,CAAC,KAAK,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ;IACnD;IAEA;;GAEC,GACD,MAAM,UAAU,IAAY,EAAiB;QAC3C,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;YACf,MAAM,IAAI,MAAM;QAClB;QACA,MAAM,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;IACxB;AACF;AAGO,MAAM,iBAAiB,IAAI"}},
    {"offset": {"line": 2776, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/controller.ts"],"sourcesContent":["import type { Tank, Bullet, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport type { AIContext, AIDecision, AIConfig } from './types';\nimport { assessThreats, isPositionSafe, findEscapeDirection } from './threat-assessment';\nimport { calculateOptimalShotAngle } from './sun-calculations';\nimport { calculateOptimalPosition, findSafeDodgePosition } from './navigation';\nimport { predictTankPosition } from './prediction';\nimport { TANK_SPEED, ROTATION_SPEED, TANK_SIZE, MAX_BULLETS_PER_TANK } from '@/app/games/tank-trouble/config';\nimport { canMoveTo } from '@/app/games/tank-trouble/utils/collision';\nimport { rlModelManager } from './rl-model';\nimport { extractObservation } from './rl-observation';\nimport { URGENT_THREAT_THRESHOLD, ENEMY_PREDICTION_TIME_MS, MOVE_FORWARD_ANGLE_TOLERANCE, MOVE_BACKWARD_ANGLE_TOLERANCE } from '@/app/games/tank-trouble/constants/game-constants';\nimport { getTankCenter } from '@/app/games/tank-trouble/utils/tank-utils';\nimport { normalizeAngleDifference, angleToPoint } from '@/app/games/tank-trouble/utils/math';\nimport { countBulletsByOwner } from '@/app/games/tank-trouble/utils/bullet-optimization';\n\n/**\n * Main AI controller - decides what actions the AI tank should take\n * \n * Supports both RL-based and rule-based decision making.\n * If an RL model is loaded, it will be used; otherwise falls back to rules.\n */\nexport function makeAIDecision(context: AIContext): AIDecision {\n  const {\n    aiTank,\n    enemyTank,\n    bullets,\n    barriers,\n    suns,\n    mapWidth,\n    mapHeight,\n    tickTime,\n    config,\n  } = context;\n\n  // Skip if tank is respawning or exploding\n  if (aiTank.respawning || aiTank.exploding || aiTank.lives <= 0) {\n    return {\n      angleDelta: 0,\n      moveDirection: 0,\n      shouldShoot: false,\n    };\n  }\n\n  // Try to use RL model if available\n  if (rlModelManager.isRLActive()) {\n    try {\n      const model = rlModelManager.getModel();\n      const observation = extractObservation(context);\n      const decision = model.predict(observation, aiTank.angle);\n      return decision;\n    } catch (error) {\n      // Removed warning log\n      // Fall through to rule-based AI\n    }\n  }\n\n  // Fall back to rule-based AI\n  return makeRuleBasedDecision(context);\n}\n\n/**\n * Rule-based decision making (original implementation)\n */\nfunction makeRuleBasedDecision(context: AIContext): AIDecision {\n  const {\n    aiTank,\n    enemyTank,\n    bullets,\n    barriers,\n    suns,\n    mapWidth,\n    mapHeight,\n    config,\n  } = context;\n\n  // Assess threats\n  const threats = assessThreats(\n    aiTank,\n    bullets,\n    suns,\n    barriers,\n    mapWidth,\n    mapHeight,\n    config.maxPredictionTime\n  );\n\n  // More aggressive: only dodge if threat is truly imminent (very high threat level)\n  // This encourages movement toward enemy even when under moderate threat\n  const hasUrgentThreat = threats.length > 0 && threats[0].threatLevel > URGENT_THREAT_THRESHOLD;\n\n  // Decision making: only dodge for truly urgent threats, otherwise always attack\n  if (hasUrgentThreat) {\n    return handleDodge(context, threats);\n  }\n\n  // Otherwise, pursue and attack aggressively\n  return handleAttack(context);\n}\n\n/**\n * Handle dodging from threats\n */\nfunction handleDodge(\n  context: AIContext,\n  threats: ReturnType<typeof assessThreats>\n): AIDecision {\n  const {\n    aiTank,\n    enemyTank,\n    barriers,\n    suns,\n    mapWidth,\n    mapHeight,\n    config,\n    bullets,\n  } = context;\n\n  // Find escape direction\n  const escape = findEscapeDirection(\n    aiTank,\n    threats,\n    barriers,\n    suns,\n    mapWidth,\n    mapHeight\n  );\n\n  // Find safe position to dodge to\n  const dodgePos = findSafeDodgePosition(\n    aiTank,\n    escape.angle,\n    config.dodgeMargin * 2,\n    barriers,\n    suns,\n    [aiTank, enemyTank],\n    mapWidth,\n    mapHeight,\n    1 // AI is tank index 1\n  );\n\n  let angleDelta = 0;\n  let moveDirection = 0;\n\n    if (dodgePos) {\n    // Calculate angle to dodge position\n    const aiCenter = getTankCenter(aiTank);\n    const targetAngle = angleToPoint(aiCenter, dodgePos);\n\n    // Calculate angle difference\n    let angleDiff = normalizeAngleDifference(targetAngle - aiTank.angle);\n\n    // Rotate toward target\n    if (Math.abs(angleDiff) > ROTATION_SPEED) {\n      angleDelta = angleDiff > 0 ? ROTATION_SPEED : -ROTATION_SPEED;\n    } else {\n      angleDelta = angleDiff;\n    }\n\n    // Move forward\n    moveDirection = 1;\n  } else {\n    // Can't dodge to position, just rotate away from threat\n    let angleDiff = normalizeAngleDifference(escape.angle - aiTank.angle);\n\n    if (Math.abs(angleDiff) > ROTATION_SPEED) {\n      angleDelta = angleDiff > 0 ? ROTATION_SPEED : -ROTATION_SPEED;\n    } else {\n      angleDelta = angleDiff;\n    }\n\n    // Try to move backward\n    moveDirection = -1;\n  }\n\n  // Even while dodging, try to shoot if possible (more aggressive)\n  // But prioritize dodging movement\n  return {\n    angleDelta,\n    moveDirection,\n    shouldShoot: false, // Still don't shoot while dodging to focus on survival\n  };\n}\n\n/**\n * Handle attacking the enemy\n */\nfunction handleAttack(context: AIContext): AIDecision {\n  const {\n    aiTank,\n    enemyTank,\n    bullets,\n    barriers,\n    suns,\n    mapWidth,\n    mapHeight,\n    tickTime,\n    config,\n  } = context;\n\n  // Predict enemy position\n  const predictedEnemyPos = predictTankPosition(enemyTank, ENEMY_PREDICTION_TIME_MS, TANK_SPEED);\n\n  // Calculate optimal shot\n  const shot = calculateOptimalShotAngle(\n    aiTank,\n    predictedEnemyPos,\n    suns,\n    barriers,\n    mapWidth,\n    mapHeight,\n    config.sunSkill\n  );\n\n  // Calculate optimal position\n  const optimalPos = calculateOptimalPosition(\n    aiTank,\n    enemyTank,\n    config.aggressiveness,\n    barriers,\n    suns,\n    mapWidth,\n    mapHeight\n  );\n\n  // Calculate movement decision - always aggressive\n  let angleDelta = 0;\n  let moveDirection = 0;\n\n  // Always rotate toward enemy/shot angle (prioritize shooting over positioning)\n  const targetAngle = shot.angle; // Always prioritize shooting angle\n\n  let angleDiff = normalizeAngleDifference(targetAngle - aiTank.angle);\n\n  if (Math.abs(angleDiff) > ROTATION_SPEED) {\n    angleDelta = angleDiff > 0 ? ROTATION_SPEED : -ROTATION_SPEED;\n  } else {\n    angleDelta = angleDiff;\n  }\n\n  // Always move toward enemy (aggressive behavior - move forward whenever possible)\n  // Calculate angle directly to enemy\n  const aiCenter = getTankCenter(aiTank);\n  const enemyCenter = getTankCenter(enemyTank);\n  const moveAngle = angleToPoint(aiCenter, enemyCenter);\n\n  const normalizedMoveDiff = normalizeAngleDifference(moveAngle - aiTank.angle);\n\n  // Always move forward toward enemy if facing roughly the right direction (wider tolerance)\n  if (Math.abs(normalizedMoveDiff) < MOVE_FORWARD_ANGLE_TOLERANCE) {\n    moveDirection = 1; // Forward\n  } else if (Math.abs(normalizedMoveDiff) > MOVE_BACKWARD_ANGLE_TOLERANCE) {\n    moveDirection = -1; // Backward (to quickly reorient)\n  } else {\n    // Even if not perfectly aligned, still move forward if somewhat close\n    moveDirection = 1; // Always move forward aggressively\n  }\n\n  // Decide whether to shoot - more aggressive shooting\n  let shouldShoot = false;\n  let shootAngle: number | undefined;\n\n  // Check if we have bullets available (use optimized counting)\n  const bulletCounts = countBulletsByOwner(bullets);\n  const bulletCount = bulletCounts.get(aiTank.color) || 0;\n  const canShoot = bulletCount < MAX_BULLETS_PER_TANK;\n\n  // More aggressive shooting: lower confidence threshold, wider angle tolerance\n  if (canShoot && shot.confidence > 0.2 - config.accuracyPenalty) { // Reduced from 0.3\n    // Apply accuracy penalty\n    const adjustedConfidence = shot.confidence * (1 - config.accuracyPenalty);\n    \n    // Shoot if confidence is reasonable and angle is somewhat close (wider tolerance)\n    if (adjustedConfidence > 0.15 && Math.abs(angleDiff) < 45) { // Reduced confidence from 0.2 to 0.15, increased angle from 30 to 45\n      shouldShoot = true;\n      shootAngle = shot.angle;\n    }\n  }\n\n  return {\n    angleDelta,\n    moveDirection,\n    shouldShoot,\n    shootAngle,\n  };\n}\n\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2954, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/config.ts"],"sourcesContent":["import type { AIConfig } from './types';\n\n/**\n * Default AI configuration\n * Adjust these values to balance difficulty\n * More aggressive settings to reduce stalemates during training\n */\nexport const DEFAULT_AI_CONFIG: AIConfig = {\n  reactionDelay: 30, // 30ms reaction time (reduced from 50ms for faster reactions)\n  accuracyPenalty: 0.08, // 8% accuracy penalty (reduced from 15% to shoot more)\n  aggressiveness: 0.85, // 85% aggressive (increased from 70% to encourage closer engagement)\n  sunSkill: 0.65, // 65% skill at using suns (slightly increased)\n  maxPredictionTime: 3000, // Predict up to 3 seconds ahead\n  dodgeMargin: 25, // Keep 25 pixels away from predicted bullet paths (reduced from 30 for more aggressive positioning)\n};\n\n/**\n * Easy difficulty AI config\n */\nexport const EASY_AI_CONFIG: AIConfig = {\n  reactionDelay: 150,\n  accuracyPenalty: 0.3,\n  aggressiveness: 0.4,\n  sunSkill: 0.3,\n  maxPredictionTime: 2000,\n  dodgeMargin: 40,\n};\n\n/**\n * Hard difficulty AI config\n */\nexport const HARD_AI_CONFIG: AIConfig = {\n  reactionDelay: 20,\n  accuracyPenalty: 0.05,\n  aggressiveness: 0.9,\n  sunSkill: 0.85,\n  maxPredictionTime: 4000,\n  dodgeMargin: 20,\n};\n\n\n"],"names":[],"mappings":";;;;;;;;AAOO,MAAM,oBAA8B;IACzC,eAAe;IACf,iBAAiB;IACjB,gBAAgB;IAChB,UAAU;IACV,mBAAmB;IACnB,aAAa;AACf;AAKO,MAAM,iBAA2B;IACtC,eAAe;IACf,iBAAiB;IACjB,gBAAgB;IAChB,UAAU;IACV,mBAAmB;IACnB,aAAa;AACf;AAKO,MAAM,iBAA2B;IACtC,eAAe;IACf,iBAAiB;IACjB,gBAAgB;IAChB,UAAU;IACV,mBAAmB;IACnB,aAAa;AACf"}},
    {"offset": {"line": 2990, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/rl-reward-config.ts"],"sourcesContent":["/**\n * Reward Configuration\n * \n * Defines reward constants that match the shared game-config.json\n * This ensures consistency between TypeScript and Go implementations\n */\n\nexport interface RewardConfig {\n  timeoutPenalty: number;\n  maxEpisodeTimeMs: number;\n  survivalRewardPerTick: number;\n  hitEnemyReward: number;\n  gotHitPenalty: number;\n  optimalDistanceToEnemy: number;\n  inactivityThresholdMs: number;\n  significantMovementThreshold: number;\n  aggressionCheckIntervalMs: number;\n  dodgeRewardPerBullet: number;\n  recentBulletThresholdMs: number;\n  positionHistorySize: number;\n  positionRepeatThreshold: number;\n  threatDistance: number;\n  bulletMatchDistance: number;\n  movementAwayThreshold: number;\n  shotAccuracyMaxDistance: number;\n  movementRewardMax: number;\n  movementRewardMultiplier: number;\n  stagnationPenalty: number;\n  stalematePenalty: number;\n  repetitiveActionPenalty: number;\n  positionDiversityReward: number;\n  lifeAdvantageReward: number;\n  inactivityBasePenalty: number;\n  inactivityMaxPenalty: number;\n  inactivityScalingFactor: number;\n  lackOfAggressionPenalty: number;\n}\n\n/**\n * Default reward config matching shared/config/game-config.json\n */\nexport const DEFAULT_REWARD_CONFIG: RewardConfig = {\n  timeoutPenalty: -100,\n  maxEpisodeTimeMs: 60000,\n  survivalRewardPerTick: 0.01,\n  hitEnemyReward: 100,\n  gotHitPenalty: -100,\n  optimalDistanceToEnemy: 120,\n  inactivityThresholdMs: 1500,\n  significantMovementThreshold: 5,\n  aggressionCheckIntervalMs: 2000,\n  dodgeRewardPerBullet: 10,\n  recentBulletThresholdMs: 100,\n  positionHistorySize: 10,\n  positionRepeatThreshold: 30,\n  threatDistance: 50,\n  bulletMatchDistance: 10,\n  movementAwayThreshold: 10,\n  shotAccuracyMaxDistance: 50,\n  movementRewardMax: 0.15,\n  movementRewardMultiplier: 0.0015,\n  stagnationPenalty: -0.1,\n  stalematePenalty: -0.2,\n  repetitiveActionPenalty: -0.03,\n  positionDiversityReward: 0.02,\n  lifeAdvantageReward: 0.02,\n  inactivityBasePenalty: -0.3,\n  inactivityMaxPenalty: -0.5,\n  inactivityScalingFactor: 0.1,\n  lackOfAggressionPenalty: -0.15,\n};\n\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAoCM,MAAM,wBAAsC;IACjD,gBAAgB,CAAC;IACjB,kBAAkB;IAClB,uBAAuB;IACvB,gBAAgB;IAChB,eAAe,CAAC;IAChB,wBAAwB;IACxB,uBAAuB;IACvB,8BAA8B;IAC9B,2BAA2B;IAC3B,sBAAsB;IACtB,yBAAyB;IACzB,qBAAqB;IACrB,yBAAyB;IACzB,gBAAgB;IAChB,qBAAqB;IACrB,uBAAuB;IACvB,yBAAyB;IACzB,mBAAmB;IACnB,0BAA0B;IAC1B,mBAAmB,CAAC;IACpB,kBAAkB,CAAC;IACnB,yBAAyB,CAAC;IAC1B,yBAAyB;IACzB,qBAAqB;IACrB,uBAAuB,CAAC;IACxB,sBAAsB,CAAC;IACvB,yBAAyB;IACzB,yBAAyB,CAAC;AAC5B"}},
    {"offset": {"line": 3033, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/rl-reward.ts"],"sourcesContent":["/**\n * Reward Function\n * \n * Calculates rewards for the RL agent based on game state transitions.\n * Reward shaping is critical for RL success - rewards should guide the agent\n * toward desired behaviors.\n */\n\nimport type { Tank, Bullet } from '@/app/games/tank-trouble/types';\nimport type { AIDecision } from './types';\nimport { TANK_SIZE } from '@/app/games/tank-trouble/config';\nimport { distance } from '@/app/games/tank-trouble/utils/math';\nimport { getTankCenter } from '@/app/games/tank-trouble/utils/tank-utils';\nimport { MAX_EPISODE_TIME_MS } from '@/app/games/tank-trouble/constants/game-constants';\nimport type { RewardConfig } from './rl-reward-config';\nimport { DEFAULT_REWARD_CONFIG } from './rl-reward-config';\n\nexport interface PreviousState {\n  aiTank: Tank;\n  enemyTank: Tank;\n  bullets: Bullet[];\n  aiLives: number;\n  enemyLives: number;\n  tickTime: number;\n  aiPositionHistory?: Array<{ x: number; y: number; tickTime: number }>; // Track position history for stalemate detection\n  lastMovementTime?: number; // Track when tank last moved significantly (for inactivity penalty)\n  lastShotTime?: number; // Track when tank last shot (for aggression penalty)\n  episodeStartTime?: number; // Track episode start time for timeout penalty\n  timeoutApplied?: boolean; // Track if timeout penalty has been applied\n}\n\nexport interface CurrentState {\n  aiTank: Tank;\n  enemyTank: Tank;\n  bullets: Bullet[];\n  aiLives: number;\n  enemyLives: number;\n  tickTime: number;\n}\n\nexport interface RewardInfo {\n  reward: number;\n  breakdown: {\n    survival?: number;\n    hitEnemy?: number;\n    gotHit?: number;\n    distanceReward?: number;\n    dodgedBullet?: number;\n    shotAccuracy?: number;\n    lifeAdvantage?: number;\n    movement?: number;\n    stagnationPenalty?: number;\n    stalematePenalty?: number;\n    repetitiveActionPenalty?: number;\n    timeoutPenalty?: number;\n    inactivityPenalty?: number;\n    lackOfAggressionPenalty?: number;\n  };\n}\n\n/**\n * Calculate reward based on state transition\n * \n * This function implements reward shaping to guide the agent:\n * - Dense rewards for intermediate behaviors (dodging, positioning)\n * - Sparse rewards for major events (hits, deaths)\n * - Automatic penalties for timeout, inactivity, and lack of aggression\n */\nexport function calculateReward(\n  previous: PreviousState,\n  current: CurrentState,\n  action: AIDecision,\n  maxEpisodeTimeMs: number = MAX_EPISODE_TIME_MS,\n  config: RewardConfig = DEFAULT_REWARD_CONFIG\n): RewardInfo {\n  let totalReward = 0;\n  const breakdown: RewardInfo['breakdown'] = {};\n  \n  // Apply timeout penalty if episode exceeded max episode time (only once)\n  if (previous.episodeStartTime && !previous.timeoutApplied) {\n    const episodeElapsed = current.tickTime - previous.episodeStartTime;\n    if (episodeElapsed >= maxEpisodeTimeMs) {\n      const timeoutPenalty = config.timeoutPenalty;\n      totalReward += timeoutPenalty;\n      breakdown.timeoutPenalty = timeoutPenalty;\n    }\n  }\n\n  // 1. Survival reward (small positive per tick)\n  // Encourages staying alive\n  const survivalReward = config.survivalRewardPerTick;\n  totalReward += survivalReward;\n  breakdown.survival = survivalReward;\n\n  // 2. Hit enemy (large positive)\n  // Check if enemy lost a life\n  if (current.enemyLives < previous.enemyLives) {\n    const hitReward = config.hitEnemyReward;\n    totalReward += hitReward;\n    breakdown.hitEnemy = hitReward;\n  }\n\n  // 3. Got hit (large negative)\n  // Check if AI lost a life\n  if (current.aiLives < previous.aiLives) {\n    const hitPenalty = config.gotHitPenalty;\n    totalReward += hitPenalty;\n    breakdown.gotHit = hitPenalty;\n  }\n\n  // 4. Distance to enemy (shaped reward)\n  // Reward maintaining optimal distance (not too close, not too far)\n  // Optimal distance reasoning:\n  // - Too close (< 80px): Hard to dodge, easy to get hit, bullets travel too fast\n  // - Too far (> 200px): Hard to hit enemy, bullets take too long, less pressure\n  // - Sweet spot (100-150px): Good balance - can dodge, can hit, maintains engagement\n  // - Based on: map size (480x360), tank size (24px), bullet speed (~2px/tick)\n  // - At 150px: ~75 ticks for bullet to travel, gives ~1 second reaction time at 72 FPS\n  const prevDistance = getDistance(previous.aiTank, previous.enemyTank);\n  const currDistance = getDistance(current.aiTank, current.enemyTank);\n  const optimalDistance = config.optimalDistanceToEnemy;\n  \n  const prevDistanceError = Math.abs(prevDistance - optimalDistance) / optimalDistance;\n  const currDistanceError = Math.abs(currDistance - optimalDistance) / optimalDistance;\n  \n  // Reward getting closer to optimal distance\n  const distanceImprovement = prevDistanceError - currDistanceError;\n  const distanceReward = distanceImprovement * 2; // Scale factor\n  totalReward += distanceReward;\n  breakdown.distanceReward = distanceReward;\n\n  // 5. Dodged bullet (positive)\n  // Check if a bullet that was threatening is now gone or missed\n  const dodgedReward = checkDodgedBullet(previous, current, config);\n  if (dodgedReward > 0) {\n    totalReward += dodgedReward;\n    breakdown.dodgedBullet = dodgedReward;\n  }\n\n  // 6. Shot accuracy (reward for shots that get close to enemy)\n  if (action.shouldShoot) {\n    // Find bullets that were just created (within threshold)\n    const recentBulletThresholdMs = config.recentBulletThresholdMs;\n    \n    for (const bullet of current.bullets) {\n      // Check owner and recency in single pass\n      if (bullet.owner === current.aiTank.color && \n          current.tickTime - bullet.createdAt < recentBulletThresholdMs) {\n        const closestApproach = getClosestBulletApproach(bullet, current.enemyTank);\n        // Reward inversely proportional to closest approach\n        const accuracyReward = Math.max(0, 5 * (1 - closestApproach / config.shotAccuracyMaxDistance));\n        totalReward += accuracyReward;\n        breakdown.shotAccuracy = (breakdown.shotAccuracy || 0) + accuracyReward;\n      }\n    }\n  }\n\n  // 7. Life advantage (encourage maintaining/improving life advantage)\n  // Only reward maintaining advantage, not changes (changes are handled by hit rewards above)\n  const prevLifeDiff = previous.aiLives - previous.enemyLives;\n  const currLifeDiff = current.aiLives - current.enemyLives;\n  \n  // Small bonus for having life advantage (maintains incentive when ahead)\n  if (currLifeDiff > 0) {\n    const lifeAdvantageReward = config.lifeAdvantageReward;\n    totalReward += lifeAdvantageReward;\n    breakdown.lifeAdvantage = lifeAdvantageReward;\n  }\n\n  // 8. Movement reward (encourage active movement, penalize staying still)\n  // Cache distance calculation to avoid redundant sqrt operations\n  const movementDistance = getDistance(previous.aiTank, current.aiTank);\n  const moved = movementDistance > 0.1;\n  \n  if (moved) {\n    // Reward proportional to distance moved (encourage significant movement)\n    const movementReward = Math.min(config.movementRewardMax, movementDistance * config.movementRewardMultiplier);\n    totalReward += movementReward;\n    breakdown.movement = movementReward;\n  } else {\n    // Increased penalty for not moving (stalling) - stronger penalty to encourage movement\n    const stagnationPenalty = config.stagnationPenalty;\n    totalReward += stagnationPenalty;\n    breakdown.stagnationPenalty = stagnationPenalty;\n    breakdown.movement = stagnationPenalty;\n  }\n\n  // 9. Stalemate detection (both tanks in similar positions, not making progress)\n  // Cache distance calculations to avoid redundant sqrt operations\n  const tankDistance = getDistance(current.aiTank, current.enemyTank);\n  const prevTankDistance = getDistance(previous.aiTank, previous.enemyTank);\n  const distanceChange = Math.abs(tankDistance - prevTankDistance);\n  \n  // Check if both tanks are in a stalemate situation\n  // Stalemate: tanks aren't changing relative positions much, and AI isn't moving much\n  // This catches both close-range standoffs and long-range circling\n  const isStalemate = \n    distanceChange < 5 && // Distance between tanks isn't changing much\n    movementDistance < 2; // AI tank isn't moving much\n  \n  if (isStalemate) {\n    // Stronger penalty for stalemate - encourages breaking out of deadlock\n    const stalematePenalty = config.stalematePenalty;\n    totalReward += stalematePenalty;\n    breakdown.stalematePenalty = stalematePenalty;\n  }\n\n  // 10. Repetitive action penalty (shooting without movement or progress)\n  // Penalize if shooting repeatedly without moving or making progress\n  if (action.shouldShoot && !moved && current.bullets.length >= previous.bullets.length) {\n    // Shooting but not moving and bullet count isn't decreasing (bullets colliding or missing)\n    const repetitiveActionPenalty = config.repetitiveActionPenalty;\n    totalReward += repetitiveActionPenalty;\n    breakdown.repetitiveActionPenalty = repetitiveActionPenalty;\n  }\n\n  // 11. Position diversity reward (encourage exploring different positions)\n  // Track if tank has been in similar position recently (if history available)\n  if (previous.aiPositionHistory && previous.aiPositionHistory.length > 0) {\n    const positionRepeatThreshold = config.positionRepeatThreshold;\n    const positionHistorySize = config.positionHistorySize;\n    \n    // Only check recent positions (avoid full array slice if history is large)\n    const startIdx = Math.max(0, previous.aiPositionHistory.length - positionHistorySize);\n    const currentPos = { x: current.aiTank.x, y: current.aiTank.y };\n    \n    // Check if current position is similar to recent positions (early exit optimization)\n    let isRepeatingPosition = false;\n    for (let i = startIdx; i < previous.aiPositionHistory.length; i++) {\n      const pos = previous.aiPositionHistory[i];\n      const dist = distance(currentPos.x, currentPos.y, pos.x, pos.y);\n      if (dist < positionRepeatThreshold) {\n        isRepeatingPosition = true;\n        break; // Early exit when repeat found\n      }\n    }\n    \n    if (!isRepeatingPosition && moved) {\n      // Reward for moving to a new area\n      const diversityReward = config.positionDiversityReward;\n      totalReward += diversityReward;\n      breakdown.movement = (breakdown.movement || 0) + diversityReward;\n    }\n  }\n\n  // 12. Inactivity penalty (tank sitting still for more than 1.5 seconds)\n  const inactivityThreshold = config.inactivityThresholdMs;\n  const significantMovementThreshold = config.significantMovementThreshold;\n  \n  if (moved && movementDistance >= significantMovementThreshold) {\n    // Tank moved significantly, update last movement time\n    // This will be tracked in the environment state\n  } else {\n    // Tank didn't move significantly, check if it's been inactive too long\n    const lastMovementTime = previous.lastMovementTime || previous.episodeStartTime || previous.tickTime;\n    const timeSinceLastMovement = current.tickTime - lastMovementTime;\n    \n    if (timeSinceLastMovement >= inactivityThreshold) {\n      // Stronger penalty that scales with inactivity duration\n      const inactivityDuration = timeSinceLastMovement - inactivityThreshold;\n      const scalingPenalty = Math.min(\n        config.inactivityMaxPenalty,\n        config.inactivityBasePenalty - (inactivityDuration / 1000) * config.inactivityScalingFactor\n      );\n      totalReward += scalingPenalty;\n      breakdown.inactivityPenalty = scalingPenalty;\n    }\n  }\n\n  // 13. Lack of aggression penalty\n  // Penalize if tank is not being aggressive enough (not shooting, not moving toward enemy, etc.)\n  const aggressionCheckInterval = config.aggressionCheckIntervalMs;\n  const timeSinceLastShot = previous.lastShotTime ? current.tickTime - previous.lastShotTime : Infinity;\n  \n  // Check if tank is being passive:\n  // - Not shooting for a while (more than 2 seconds)\n  // - Moving away from enemy\n  // - Not closing distance to enemy\n  const isPassive = \n    timeSinceLastShot > aggressionCheckInterval && // Not shooting\n    !action.shouldShoot && // Not about to shoot\n    movementDistance < 2; // Not moving much\n  \n  // Also check if moving away from enemy\n  const distanceToEnemyChange = currDistance - prevDistance;\n  const isMovingAway = distanceToEnemyChange > config.movementAwayThreshold;\n  \n  if (isPassive || (isMovingAway && !action.shouldShoot)) {\n    const lackOfAggressionPenalty = config.lackOfAggressionPenalty;\n    totalReward += lackOfAggressionPenalty;\n    breakdown.lackOfAggressionPenalty = lackOfAggressionPenalty;\n  }\n\n  return {\n    reward: totalReward,\n    breakdown,\n  };\n}\n\n/**\n * Get Euclidean distance between two tanks\n * Uses utility function for consistency\n */\nfunction getDistance(tank1: Tank, tank2: Tank): number {\n  return distance(tank1.x, tank1.y, tank2.x, tank2.y);\n}\n\n/**\n * Check if AI successfully dodged a bullet\n * \n * Returns reward if a bullet that was close to AI is now gone or far away\n * Optimized to use Map for O(1) lookups instead of O(n) searches\n */\nfunction checkDodgedBullet(previous: PreviousState, current: CurrentState, config: RewardConfig): number {\n  const threatDistance = config.threatDistance;\n  const bulletMatchDistance = config.bulletMatchDistance;\n  \n  // Find bullets that were threatening AI in previous state\n  const threateningBullets: Bullet[] = [];\n  for (const bullet of previous.bullets) {\n    if (bullet.owner === previous.aiTank.color || bullet.exploding) {\n      continue; // Ignore own bullets and exploding bullets\n    }\n    \n    const dist = getDistanceToTank(bullet, previous.aiTank);\n    if (dist < threatDistance) {\n      threateningBullets.push(bullet);\n    }\n  }\n\n  // Create a Map of current bullets by owner for faster lookup\n  // Key: owner, Value: array of bullets from that owner\n  const currentBulletsByOwner = new Map<'blue' | 'red', Bullet[]>();\n  for (const bullet of current.bullets) {\n    if (!bullet.exploding) {\n      const bullets = currentBulletsByOwner.get(bullet.owner) || [];\n      bullets.push(bullet);\n      currentBulletsByOwner.set(bullet.owner, bullets);\n    }\n  }\n\n  // Check if any threatening bullets are now gone or far away\n  let dodgedCount = 0;\n  const aiTankCenter = getTankCenter(current.aiTank);\n  \n  for (const prevBullet of threateningBullets) {\n    const ownerBullets = currentBulletsByOwner.get(prevBullet.owner) || [];\n    \n    // Check if a similar bullet still exists (matching by position)\n    let stillThreatening = false;\n    for (const currBullet of ownerBullets) {\n      const dist = distance(currBullet.x, currBullet.y, prevBullet.x, prevBullet.y);\n      if (dist < bulletMatchDistance) {\n        stillThreatening = true;\n        break;\n      }\n    }\n\n    if (!stillThreatening) {\n      // Bullet is gone - check if closest bullet from same owner is now far away\n      let minDistance = Infinity;\n      for (const currBullet of ownerBullets) {\n        const dist = distance(currBullet.x, currBullet.y, aiTankCenter.x, aiTankCenter.y);\n        if (dist < minDistance) {\n          minDistance = dist;\n        }\n      }\n      \n      if (minDistance > threatDistance) {\n        dodgedCount++;\n      }\n    }\n  }\n\n  return dodgedCount * config.dodgeRewardPerBullet;\n}\n\n/**\n * Get distance from bullet to tank center\n * Uses utility functions for consistency and performance\n */\nfunction getDistanceToTank(bullet: Bullet, tank: Tank): number {\n  const tankCenter = getTankCenter(tank);\n  return distance(bullet.x, bullet.y, tankCenter.x, tankCenter.y);\n}\n\n/**\n * Calculate closest approach distance of bullet to tank\n * \n * This is a simplified calculation - in reality, we'd need to account for\n * bullet trajectory and tank movement.\n */\nfunction getClosestBulletApproach(bullet: Bullet, tank: Tank): number {\n  // Simplified: just use current distance\n  // In a full implementation, we'd predict the bullet path\n  return getDistanceToTank(bullet, tank);\n}\n\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;AAKD;AACA;AACA;AAEA;;;;;AAqDO,SAAS,gBACd,QAAuB,EACvB,OAAqB,EACrB,MAAkB,EAClB,mBAA2B,mMAAmB,EAC9C,SAAuB,2MAAqB;IAE5C,IAAI,cAAc;IAClB,MAAM,YAAqC,CAAC;IAE5C,yEAAyE;IACzE,IAAI,SAAS,gBAAgB,IAAI,CAAC,SAAS,cAAc,EAAE;QACzD,MAAM,iBAAiB,QAAQ,QAAQ,GAAG,SAAS,gBAAgB;QACnE,IAAI,kBAAkB,kBAAkB;YACtC,MAAM,iBAAiB,OAAO,cAAc;YAC5C,eAAe;YACf,UAAU,cAAc,GAAG;QAC7B;IACF;IAEA,+CAA+C;IAC/C,2BAA2B;IAC3B,MAAM,iBAAiB,OAAO,qBAAqB;IACnD,eAAe;IACf,UAAU,QAAQ,GAAG;IAErB,gCAAgC;IAChC,6BAA6B;IAC7B,IAAI,QAAQ,UAAU,GAAG,SAAS,UAAU,EAAE;QAC5C,MAAM,YAAY,OAAO,cAAc;QACvC,eAAe;QACf,UAAU,QAAQ,GAAG;IACvB;IAEA,8BAA8B;IAC9B,0BAA0B;IAC1B,IAAI,QAAQ,OAAO,GAAG,SAAS,OAAO,EAAE;QACtC,MAAM,aAAa,OAAO,aAAa;QACvC,eAAe;QACf,UAAU,MAAM,GAAG;IACrB;IAEA,uCAAuC;IACvC,mEAAmE;IACnE,8BAA8B;IAC9B,gFAAgF;IAChF,+EAA+E;IAC/E,oFAAoF;IACpF,6EAA6E;IAC7E,sFAAsF;IACtF,MAAM,eAAe,YAAY,SAAS,MAAM,EAAE,SAAS,SAAS;IACpE,MAAM,eAAe,YAAY,QAAQ,MAAM,EAAE,QAAQ,SAAS;IAClE,MAAM,kBAAkB,OAAO,sBAAsB;IAErD,MAAM,oBAAoB,KAAK,GAAG,CAAC,eAAe,mBAAmB;IACrE,MAAM,oBAAoB,KAAK,GAAG,CAAC,eAAe,mBAAmB;IAErE,4CAA4C;IAC5C,MAAM,sBAAsB,oBAAoB;IAChD,MAAM,iBAAiB,sBAAsB,GAAG,eAAe;IAC/D,eAAe;IACf,UAAU,cAAc,GAAG;IAE3B,8BAA8B;IAC9B,+DAA+D;IAC/D,MAAM,eAAe,kBAAkB,UAAU,SAAS;IAC1D,IAAI,eAAe,GAAG;QACpB,eAAe;QACf,UAAU,YAAY,GAAG;IAC3B;IAEA,8DAA8D;IAC9D,IAAI,OAAO,WAAW,EAAE;QACtB,yDAAyD;QACzD,MAAM,0BAA0B,OAAO,uBAAuB;QAE9D,KAAK,MAAM,UAAU,QAAQ,OAAO,CAAE;YACpC,yCAAyC;YACzC,IAAI,OAAO,KAAK,KAAK,QAAQ,MAAM,CAAC,KAAK,IACrC,QAAQ,QAAQ,GAAG,OAAO,SAAS,GAAG,yBAAyB;gBACjE,MAAM,kBAAkB,yBAAyB,QAAQ,QAAQ,SAAS;gBAC1E,oDAAoD;gBACpD,MAAM,iBAAiB,KAAK,GAAG,CAAC,GAAG,IAAI,CAAC,IAAI,kBAAkB,OAAO,uBAAuB;gBAC5F,eAAe;gBACf,UAAU,YAAY,GAAG,CAAC,UAAU,YAAY,IAAI,CAAC,IAAI;YAC3D;QACF;IACF;IAEA,qEAAqE;IACrE,4FAA4F;IAC5F,MAAM,eAAe,SAAS,OAAO,GAAG,SAAS,UAAU;IAC3D,MAAM,eAAe,QAAQ,OAAO,GAAG,QAAQ,UAAU;IAEzD,yEAAyE;IACzE,IAAI,eAAe,GAAG;QACpB,MAAM,sBAAsB,OAAO,mBAAmB;QACtD,eAAe;QACf,UAAU,aAAa,GAAG;IAC5B;IAEA,yEAAyE;IACzE,gEAAgE;IAChE,MAAM,mBAAmB,YAAY,SAAS,MAAM,EAAE,QAAQ,MAAM;IACpE,MAAM,QAAQ,mBAAmB;IAEjC,IAAI,OAAO;QACT,yEAAyE;QACzE,MAAM,iBAAiB,KAAK,GAAG,CAAC,OAAO,iBAAiB,EAAE,mBAAmB,OAAO,wBAAwB;QAC5G,eAAe;QACf,UAAU,QAAQ,GAAG;IACvB,OAAO;QACL,uFAAuF;QACvF,MAAM,oBAAoB,OAAO,iBAAiB;QAClD,eAAe;QACf,UAAU,iBAAiB,GAAG;QAC9B,UAAU,QAAQ,GAAG;IACvB;IAEA,gFAAgF;IAChF,iEAAiE;IACjE,MAAM,eAAe,YAAY,QAAQ,MAAM,EAAE,QAAQ,SAAS;IAClE,MAAM,mBAAmB,YAAY,SAAS,MAAM,EAAE,SAAS,SAAS;IACxE,MAAM,iBAAiB,KAAK,GAAG,CAAC,eAAe;IAE/C,mDAAmD;IACnD,qFAAqF;IACrF,kEAAkE;IAClE,MAAM,cACJ,iBAAiB,KAAK,6CAA6C;IACnE,mBAAmB,GAAG,4BAA4B;IAEpD,IAAI,aAAa;QACf,uEAAuE;QACvE,MAAM,mBAAmB,OAAO,gBAAgB;QAChD,eAAe;QACf,UAAU,gBAAgB,GAAG;IAC/B;IAEA,wEAAwE;IACxE,oEAAoE;IACpE,IAAI,OAAO,WAAW,IAAI,CAAC,SAAS,QAAQ,OAAO,CAAC,MAAM,IAAI,SAAS,OAAO,CAAC,MAAM,EAAE;QACrF,2FAA2F;QAC3F,MAAM,0BAA0B,OAAO,uBAAuB;QAC9D,eAAe;QACf,UAAU,uBAAuB,GAAG;IACtC;IAEA,0EAA0E;IAC1E,6EAA6E;IAC7E,IAAI,SAAS,iBAAiB,IAAI,SAAS,iBAAiB,CAAC,MAAM,GAAG,GAAG;QACvE,MAAM,0BAA0B,OAAO,uBAAuB;QAC9D,MAAM,sBAAsB,OAAO,mBAAmB;QAEtD,2EAA2E;QAC3E,MAAM,WAAW,KAAK,GAAG,CAAC,GAAG,SAAS,iBAAiB,CAAC,MAAM,GAAG;QACjE,MAAM,aAAa;YAAE,GAAG,QAAQ,MAAM,CAAC,CAAC;YAAE,GAAG,QAAQ,MAAM,CAAC,CAAC;QAAC;QAE9D,qFAAqF;QACrF,IAAI,sBAAsB;QAC1B,IAAK,IAAI,IAAI,UAAU,IAAI,SAAS,iBAAiB,CAAC,MAAM,EAAE,IAAK;YACjE,MAAM,MAAM,SAAS,iBAAiB,CAAC,EAAE;YACzC,MAAM,OAAO,IAAA,uKAAQ,EAAC,WAAW,CAAC,EAAE,WAAW,CAAC,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC;YAC9D,IAAI,OAAO,yBAAyB;gBAClC,sBAAsB;gBACtB,OAAO,+BAA+B;YACxC;QACF;QAEA,IAAI,CAAC,uBAAuB,OAAO;YACjC,kCAAkC;YAClC,MAAM,kBAAkB,OAAO,uBAAuB;YACtD,eAAe;YACf,UAAU,QAAQ,GAAG,CAAC,UAAU,QAAQ,IAAI,CAAC,IAAI;QACnD;IACF;IAEA,wEAAwE;IACxE,MAAM,sBAAsB,OAAO,qBAAqB;IACxD,MAAM,+BAA+B,OAAO,4BAA4B;IAExE,IAAI,SAAS,oBAAoB,8BAA8B;IAC7D,sDAAsD;IACtD,gDAAgD;IAClD,OAAO;QACL,uEAAuE;QACvE,MAAM,mBAAmB,SAAS,gBAAgB,IAAI,SAAS,gBAAgB,IAAI,SAAS,QAAQ;QACpG,MAAM,wBAAwB,QAAQ,QAAQ,GAAG;QAEjD,IAAI,yBAAyB,qBAAqB;YAChD,wDAAwD;YACxD,MAAM,qBAAqB,wBAAwB;YACnD,MAAM,iBAAiB,KAAK,GAAG,CAC7B,OAAO,oBAAoB,EAC3B,OAAO,qBAAqB,GAAG,AAAC,qBAAqB,OAAQ,OAAO,uBAAuB;YAE7F,eAAe;YACf,UAAU,iBAAiB,GAAG;QAChC;IACF;IAEA,iCAAiC;IACjC,gGAAgG;IAChG,MAAM,0BAA0B,OAAO,yBAAyB;IAChE,MAAM,oBAAoB,SAAS,YAAY,GAAG,QAAQ,QAAQ,GAAG,SAAS,YAAY,GAAG;IAE7F,kCAAkC;IAClC,mDAAmD;IACnD,2BAA2B;IAC3B,kCAAkC;IAClC,MAAM,YACJ,oBAAoB,2BAA2B,eAAe;IAC9D,CAAC,OAAO,WAAW,IAAI,qBAAqB;IAC5C,mBAAmB,GAAG,kBAAkB;IAE1C,uCAAuC;IACvC,MAAM,wBAAwB,eAAe;IAC7C,MAAM,eAAe,wBAAwB,OAAO,qBAAqB;IAEzE,IAAI,aAAc,gBAAgB,CAAC,OAAO,WAAW,EAAG;QACtD,MAAM,0BAA0B,OAAO,uBAAuB;QAC9D,eAAe;QACf,UAAU,uBAAuB,GAAG;IACtC;IAEA,OAAO;QACL,QAAQ;QACR;IACF;AACF;AAEA;;;CAGC,GACD,SAAS,YAAY,KAAW,EAAE,KAAW;IAC3C,OAAO,IAAA,uKAAQ,EAAC,MAAM,CAAC,EAAE,MAAM,CAAC,EAAE,MAAM,CAAC,EAAE,MAAM,CAAC;AACpD;AAEA;;;;;CAKC,GACD,SAAS,kBAAkB,QAAuB,EAAE,OAAqB,EAAE,MAAoB;IAC7F,MAAM,iBAAiB,OAAO,cAAc;IAC5C,MAAM,sBAAsB,OAAO,mBAAmB;IAEtD,0DAA0D;IAC1D,MAAM,qBAA+B,EAAE;IACvC,KAAK,MAAM,UAAU,SAAS,OAAO,CAAE;QACrC,IAAI,OAAO,KAAK,KAAK,SAAS,MAAM,CAAC,KAAK,IAAI,OAAO,SAAS,EAAE;YAC9D,UAAU,2CAA2C;QACvD;QAEA,MAAM,OAAO,kBAAkB,QAAQ,SAAS,MAAM;QACtD,IAAI,OAAO,gBAAgB;YACzB,mBAAmB,IAAI,CAAC;QAC1B;IACF;IAEA,6DAA6D;IAC7D,sDAAsD;IACtD,MAAM,wBAAwB,IAAI;IAClC,KAAK,MAAM,UAAU,QAAQ,OAAO,CAAE;QACpC,IAAI,CAAC,OAAO,SAAS,EAAE;YACrB,MAAM,UAAU,sBAAsB,GAAG,CAAC,OAAO,KAAK,KAAK,EAAE;YAC7D,QAAQ,IAAI,CAAC;YACb,sBAAsB,GAAG,CAAC,OAAO,KAAK,EAAE;QAC1C;IACF;IAEA,4DAA4D;IAC5D,IAAI,cAAc;IAClB,MAAM,eAAe,IAAA,qLAAa,EAAC,QAAQ,MAAM;IAEjD,KAAK,MAAM,cAAc,mBAAoB;QAC3C,MAAM,eAAe,sBAAsB,GAAG,CAAC,WAAW,KAAK,KAAK,EAAE;QAEtE,gEAAgE;QAChE,IAAI,mBAAmB;QACvB,KAAK,MAAM,cAAc,aAAc;YACrC,MAAM,OAAO,IAAA,uKAAQ,EAAC,WAAW,CAAC,EAAE,WAAW,CAAC,EAAE,WAAW,CAAC,EAAE,WAAW,CAAC;YAC5E,IAAI,OAAO,qBAAqB;gBAC9B,mBAAmB;gBACnB;YACF;QACF;QAEA,IAAI,CAAC,kBAAkB;YACrB,2EAA2E;YAC3E,IAAI,cAAc;YAClB,KAAK,MAAM,cAAc,aAAc;gBACrC,MAAM,OAAO,IAAA,uKAAQ,EAAC,WAAW,CAAC,EAAE,WAAW,CAAC,EAAE,aAAa,CAAC,EAAE,aAAa,CAAC;gBAChF,IAAI,OAAO,aAAa;oBACtB,cAAc;gBAChB;YACF;YAEA,IAAI,cAAc,gBAAgB;gBAChC;YACF;QACF;IACF;IAEA,OAAO,cAAc,OAAO,oBAAoB;AAClD;AAEA;;;CAGC,GACD,SAAS,kBAAkB,MAAc,EAAE,IAAU;IACnD,MAAM,aAAa,IAAA,qLAAa,EAAC;IACjC,OAAO,IAAA,uKAAQ,EAAC,OAAO,CAAC,EAAE,OAAO,CAAC,EAAE,WAAW,CAAC,EAAE,WAAW,CAAC;AAChE;AAEA;;;;;CAKC,GACD,SAAS,yBAAyB,MAAc,EAAE,IAAU;IAC1D,wCAAwC;IACxC,yDAAyD;IACzD,OAAO,kBAAkB,QAAQ;AACnC"}},
    {"offset": {"line": 3328, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/rl-environment.ts"],"sourcesContent":["/**\n * RL Environment Wrapper\n * \n * Wraps the Tank Trouble game as a reinforcement learning environment.\n * Converts game state to observations, executes actions, and calculates rewards.\n */\n\nimport type { Tank, Bullet, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport type { AIContext } from './types';\nimport { extractObservation, Observation } from './rl-observation';\nimport { calculateReward, RewardInfo } from './rl-reward';\nimport { actionToDecision, DecisionToAction } from './rl-actions';\nimport type { AIDecision } from './types';\nimport { MAX_EPISODE_TIME_MS } from '@/app/games/tank-trouble/constants/game-constants';\nimport { DEFAULT_REWARD_CONFIG } from './rl-reward-config';\n\nexport interface RLEnvironmentState {\n  observation: Observation;\n  reward: number;\n  done: boolean;\n  info: RewardInfo['breakdown'] & {\n    episodeLength: number;\n    totalReward: number;\n    aiLives: number;\n    enemyLives: number;\n  };\n}\n\nexport interface PreviousState {\n  aiTank: Tank;\n  enemyTank: Tank;\n  bullets: Bullet[];\n  aiLives: number;\n  enemyLives: number;\n  tickTime: number;\n  aiPositionHistory?: Array<{ x: number; y: number; tickTime: number }>;\n  lastMovementTime?: number;\n  lastShotTime?: number;\n  episodeStartTime?: number;\n  timeoutApplied?: boolean;\n}\n\n/**\n * RL Environment for Tank Trouble\n * \n * This class wraps the game state and provides a standard RL interface:\n * - reset(): Initialize/reset environment\n * - step(action): Execute action and return next state\n * - getObservation(): Get current observation\n */\nexport class TankTroubleRLEnv {\n  private previousState: PreviousState | null = null;\n  private episodeStartTime: number = 0;\n  private episodeLength: number = 0;\n  private totalReward: number = 0;\n  private positionHistory: Array<{ x: number; y: number; tickTime: number }> = [];\n  private maxEpisodeTimeMs: number;\n\n  constructor(maxEpisodeTimeMs: number = MAX_EPISODE_TIME_MS) {\n    this.maxEpisodeTimeMs = maxEpisodeTimeMs;\n  }\n\n  /**\n   * Reset the environment to initial state\n   */\n  reset(context: AIContext): RLEnvironmentState {\n    const observation = extractObservation(context);\n    \n    // Reset position history\n    this.positionHistory = [{ x: context.aiTank.x, y: context.aiTank.y, tickTime: context.tickTime }];\n    \n    // Store initial state\n    this.episodeStartTime = context.tickTime;\n    this.previousState = {\n      aiTank: { ...context.aiTank },\n      enemyTank: { ...context.enemyTank },\n      bullets: context.bullets.map(b => ({ ...b })),\n      aiLives: context.aiTank.lives,\n      enemyLives: context.enemyTank.lives,\n      tickTime: context.tickTime,\n      aiPositionHistory: [],\n      lastMovementTime: context.tickTime, // Initialize movement tracking\n      lastShotTime: 0, // Initialize shot tracking\n      episodeStartTime: context.tickTime, // Track episode start for timeout\n      timeoutApplied: false,\n    };\n    \n    this.episodeLength = 0;\n    this.totalReward = 0;\n\n    return {\n      observation,\n      reward: 0,\n      done: false,\n      info: {\n        episodeLength: 0,\n        totalReward: 0,\n        aiLives: context.aiTank.lives,\n        enemyLives: context.enemyTank.lives,\n      },\n    };\n  }\n\n  /**\n   * Step the environment with an action\n   * \n   * @param action - Action from RL agent (discrete or continuous)\n   * @param context - Current game context\n   * @param decision - The decision that was executed (for reward calculation)\n   * @returns Next state, reward, done flag, and info\n   */\n  step(\n    action: number | DecisionToAction,\n    context: AIContext,\n    decision: AIDecision\n  ): RLEnvironmentState {\n    if (!this.previousState) {\n      // If not initialized, reset first\n      return this.reset(context);\n    }\n\n    // Calculate reward based on state transition (no boolean arguments needed)\n    const rewardInfo = calculateReward(\n      this.previousState,\n      {\n        aiTank: context.aiTank,\n        enemyTank: context.enemyTank,\n        bullets: context.bullets,\n        aiLives: context.aiTank.lives,\n        enemyLives: context.enemyTank.lives,\n        tickTime: context.tickTime,\n      },\n      decision,\n      this.maxEpisodeTimeMs,\n      DEFAULT_REWARD_CONFIG\n    );\n\n    this.totalReward += rewardInfo.reward;\n    this.episodeLength++;\n\n    // Check if episode is done\n    const done = this.isDone(context);\n\n    // Extract new observation\n    const observation = extractObservation(context);\n\n    // Update position history (keep last 20 positions)\n    this.positionHistory.push({ x: context.aiTank.x, y: context.aiTank.y, tickTime: context.tickTime });\n    if (this.positionHistory.length > 20) {\n      this.positionHistory.shift();\n    }\n    \n    // Track movement and shooting for inactivity/aggression penalties\n    const movementDistance = Math.sqrt(\n      Math.pow(context.aiTank.x - this.previousState.aiTank.x, 2) +\n      Math.pow(context.aiTank.y - this.previousState.aiTank.y, 2)\n    );\n    const SIGNIFICANT_MOVEMENT_THRESHOLD = 5; // pixels\n    const lastMovementTime = movementDistance >= SIGNIFICANT_MOVEMENT_THRESHOLD \n      ? context.tickTime \n      : (this.previousState.lastMovementTime || context.tickTime);\n    \n    const lastShotTime = decision.shouldShoot \n      ? context.tickTime \n      : (this.previousState.lastShotTime || 0);\n    \n    // Check if timeout penalty was applied (check in reward function, but track here)\n    const episodeElapsed = context.tickTime - this.episodeStartTime;\n    const timeoutApplied = episodeElapsed >= this.maxEpisodeTimeMs && !this.previousState?.timeoutApplied;\n    \n    // Update previous state\n    this.previousState = {\n      aiTank: { ...context.aiTank },\n      enemyTank: { ...context.enemyTank },\n      bullets: context.bullets.map(b => ({ ...b })),\n      aiLives: context.aiTank.lives,\n      enemyLives: context.enemyTank.lives,\n      tickTime: context.tickTime,\n      aiPositionHistory: [...this.positionHistory], // Include position history for stalemate detection\n      lastMovementTime, // Track when tank last moved significantly\n      lastShotTime, // Track when tank last shot\n      episodeStartTime: this.episodeStartTime, // Pass episode start time for timeout check\n      timeoutApplied: timeoutApplied || this.previousState?.timeoutApplied || false, // Track if timeout penalty was applied\n    };\n\n    return {\n      observation,\n      reward: rewardInfo.reward,\n      done,\n      info: {\n        episodeLength: this.episodeLength,\n        totalReward: this.totalReward,\n        aiLives: context.aiTank.lives,\n        enemyLives: context.enemyTank.lives,\n        ...rewardInfo.breakdown,\n      },\n    };\n  }\n\n  /**\n   * Get current observation without stepping\n   */\n  getObservation(context: AIContext): Observation {\n    return extractObservation(context);\n  }\n\n  /**\n   * Check if episode is done\n   */\n  private isDone(context: AIContext): boolean {\n    // Episode ends when:\n    // 1. AI tank has no lives left\n    // 2. Enemy tank has no lives left\n    // 3. Episode exceeds max episode time (timeout)\n    if (context.aiTank.lives <= 0 || context.enemyTank.lives <= 0) {\n      return true;\n    }\n    \n    // Check if episode has exceeded max episode time\n    const episodeElapsed = context.tickTime - this.episodeStartTime;\n    if (episodeElapsed >= this.maxEpisodeTimeMs) {\n      return true;\n    }\n    \n    return false;\n  }\n\n  /**\n   * Get episode statistics\n   */\n  getStats() {\n    return {\n      episodeLength: this.episodeLength,\n      totalReward: this.totalReward,\n    };\n  }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3516, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/rl-training-example.ts"],"sourcesContent":["/**\n * Example RL Training Script\n * \n * This is a template for training an RL agent. In practice, you would:\n * 1. Use Python with Stable-Baselines3 for faster training\n * 2. Or use TensorFlow.js for browser-based training (slower but simpler)\n * \n * This example shows the structure but requires actual RL implementation.\n */\n\nimport { TankTroubleRLEnv } from './rl-environment';\nimport { rlModelManager, TensorFlowJSModel } from './rl-model';\nimport { getObservationSize } from './rl-observation';\nimport { NUM_DISCRETE_ACTIONS } from './rl-actions';\nimport type { AIContext } from './types';\n\n/**\n * Example training loop structure\n * \n * NOTE: This is a template. Actual training requires:\n * - A proper RL algorithm (DQN, PPO, etc.)\n * - Experience replay buffer\n * - Model optimization\n * - Hyperparameter tuning\n */\nexport async function trainRLAgent(\n  episodes: number = 1000,\n  modelPath?: string\n) {\n  // Removed debug logs\n\n  // Initialize environment\n  const env = new TankTroubleRLEnv();\n\n  // Initialize model (placeholder - would be actual RL model)\n  const model = new TensorFlowJSModel({\n    name: 'TankTroubleRL',\n    type: 'discrete',\n    observationSize: getObservationSize(),\n    actionSize: NUM_DISCRETE_ACTIONS,\n  });\n\n  rlModelManager.setModel(model);\n\n  if (modelPath) {\n    try {\n      await model.load(modelPath);\n      // Model loaded\n    } catch (error) {\n      // No existing model found, starting fresh\n    }\n  }\n\n  // Training statistics\n  const stats = {\n    episode: 0,\n    totalReward: 0,\n  };\n\n  // Example training loop structure\n  for (let episode = 0; episode < episodes; episode++) {\n    stats.episode = episode;\n\n    // Reset environment (would get initial game state)\n    // const initialState = getInitialGameState();\n    // let state = env.reset(initialState);\n\n    let episodeReward = 0;\n    let done = false;\n    let stepCount = 0;\n\n    // Episode loop\n    while (!done && stepCount < 10000) {\n      // TODO: Implement actual RL algorithm\n      // 1. Select action (epsilon-greedy, policy, etc.)\n      // 2. Execute action in environment\n      // 3. Observe reward and next state\n      // 4. Store experience in replay buffer\n      // 5. Update model (if batch ready)\n\n      stepCount++;\n    }\n\n    // Log episode statistics (removed console.log)\n    // TODO: Save model periodically\n    if (episode % 1000 === 0 && modelPath) {\n      // await model.save(modelPath);\n    }\n  }\n  return stats;\n}\n\n/**\n * Example: How to use trained model in game\n */\nexport function useTrainedModel(modelPath: string) {\n  const model = new TensorFlowJSModel({\n    name: 'TankTroubleRL',\n    type: 'discrete',\n    observationSize: getObservationSize(),\n    actionSize: NUM_DISCRETE_ACTIONS,\n  });\n\n  rlModelManager.setModel(model);\n\n  // Load model\n  model.load(modelPath)\n    .then(() => {\n      // Model loaded successfully\n    })\n    .catch((error) => {\n      // Failed to load model, falling back to rule-based AI\n    });\n}\n\n/**\n * Python Training Example (Recommended)\n * \n * For actual training, use Python with Stable-Baselines3:\n * \n * ```python\n * from stable_baselines3 import PPO\n * from stable_baselines3.common.env_util import make_vec_env\n * from tank_trouble_env import TankTroubleEnv\n * \n * # Create environment\n * env = make_vec_env(TankTroubleEnv, n_envs=4)\n * \n * # Create and train model\n * model = PPO(\"MlpPolicy\", env, verbose=1)\n * model.learn(total_timesteps=1_000_000)\n * \n * # Save model\n * model.save(\"tank_ai_ppo\")\n * \n * # Export for TensorFlow.js (requires conversion)\n * # See: https://www.tensorflow.org/js/guide/conversion\n * ```\n */\n\n"],"names":[],"mappings":";;;;;;AAAA;;;;;;;;CAQC,GAED;AACA;AACA;AACA;;;;;AAYO,eAAe,aACpB,WAAmB,IAAI,EACvB,SAAkB;IAElB,qBAAqB;IAErB,yBAAyB;IACzB,MAAM,MAAM,IAAI,iMAAgB;IAEhC,4DAA4D;IAC5D,MAAM,QAAQ,IAAI,4LAAiB,CAAC;QAClC,MAAM;QACN,MAAM;QACN,iBAAiB,IAAA,mMAAkB;QACnC,YAAY,iMAAoB;IAClC;IAEA,yLAAc,CAAC,QAAQ,CAAC;IAExB,IAAI,WAAW;QACb,IAAI;YACF,MAAM,MAAM,IAAI,CAAC;QACjB,eAAe;QACjB,EAAE,OAAO,OAAO;QACd,0CAA0C;QAC5C;IACF;IAEA,sBAAsB;IACtB,MAAM,QAAQ;QACZ,SAAS;QACT,aAAa;IACf;IAEA,kCAAkC;IAClC,IAAK,IAAI,UAAU,GAAG,UAAU,UAAU,UAAW;QACnD,MAAM,OAAO,GAAG;QAEhB,mDAAmD;QACnD,8CAA8C;QAC9C,uCAAuC;QAEvC,IAAI,gBAAgB;QACpB,IAAI,OAAO;QACX,IAAI,YAAY;QAEhB,eAAe;QACf,MAAO,CAAC,QAAQ,YAAY,MAAO;YACjC,sCAAsC;YACtC,kDAAkD;YAClD,mCAAmC;YACnC,mCAAmC;YACnC,uCAAuC;YACvC,mCAAmC;YAEnC;QACF;QAEA,+CAA+C;QAC/C,gCAAgC;QAChC,IAAI,UAAU,SAAS,KAAK,WAAW;QACrC,+BAA+B;QACjC;IACF;IACA,OAAO;AACT;AAKO,SAAS,gBAAgB,SAAiB;IAC/C,MAAM,QAAQ,IAAI,4LAAiB,CAAC;QAClC,MAAM;QACN,MAAM;QACN,iBAAiB,IAAA,mMAAkB;QACnC,YAAY,iMAAoB;IAClC;IAEA,yLAAc,CAAC,QAAQ,CAAC;IAExB,aAAa;IACb,MAAM,IAAI,CAAC,WACR,IAAI,CAAC;IACJ,4BAA4B;IAC9B,GACC,KAAK,CAAC,CAAC;IACN,sDAAsD;IACxD;AACJ,EAEA;;;;;;;;;;;;;;;;;;;;;;;CAuBC"}},
    {"offset": {"line": 3632, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/index.ts"],"sourcesContent":["/**\n * AI Tank System - Main Entry Point\n * \n * This module exports the main AI tank update function and configuration\n */\n\nimport type { Tank, Bullet, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport type { UpdateTankResult, UpdateTankParams } from '@/app/games/tank-trouble/utils/tank';\nimport type { AIConfig, AIContext, AIDecision } from './types';\nimport { makeAIDecision } from './controller';\nimport { DEFAULT_AI_CONFIG } from './config';\nimport { TANK_SPEED, ROTATION_SPEED, MAX_BULLETS_PER_TANK, GAME_CONFIG } from '@/app/games/tank-trouble/config';\nimport { canMoveTo } from '@/app/games/tank-trouble/utils/collision';\nimport { createBullet } from '@/app/games/tank-trouble/utils/bullet-creation';\nimport { clampTankPosition } from '@/app/games/tank-trouble/utils/tank-utils';\nimport { degToRad } from '@/app/games/tank-trouble/utils/math';\nimport { countBulletsByOwner } from '@/app/games/tank-trouble/utils/bullet-optimization';\nimport type { RLTrainingManager } from './rl-training-manager';\n\n/**\n * Update AI tank - similar to updatePlayer1Tank/updatePlayer2Tank\n */\nexport function updateAITank(\n  params: UpdateTankParams,\n  aiConfig: AIConfig = DEFAULT_AI_CONFIG,\n  trainingManager?: RLTrainingManager | null,\n  gameId?: string\n): UpdateTankResult & { decision?: AIDecision } {\n  const {\n    tank,\n    tankIndex,\n    tickTime,\n    lastShotTime,\n    bullets,\n    mapWidth,\n    mapHeight,\n    barriers,\n    suns,\n    allTanks,\n  } = params;\n\n  // Find enemy tank - optimized O(1) lookup instead of O(n) find\n  // Tanks array is always [blue, red], so use index directly\n  let enemyTank: Tank | undefined;\n  if (allTanks.length >= 2 && tankIndex !== undefined) {\n    // Direct index lookup: enemy is the other tank\n    const enemyIndex = tankIndex === 0 ? 1 : 0;\n    enemyTank = allTanks[enemyIndex];\n    \n    // Validate enemy tank exists and has lives\n    if (!enemyTank || enemyTank.lives <= 0) {\n      // Fallback: try the other index if current enemy is invalid\n      const fallbackIndex = enemyIndex === 0 ? 1 : 0;\n      enemyTank = allTanks[fallbackIndex] || enemyTank;\n    }\n  } else {\n    // Fallback to find if array structure is unexpected (defensive)\n    enemyTank = allTanks.find((t) => t && t.color !== tank.color && t.lives > 0) ||\n                allTanks.find((t) => t && t !== tank);\n  }\n  \n  // If still no enemy tank, use a dummy tank at center of map (shouldn't happen in normal gameplay)\n  if (!enemyTank) {\n    enemyTank = {\n      x: mapWidth / 2,\n      y: mapHeight / 2,\n      angle: 0,\n      lives: 3,\n      color: tank.color === 'blue' ? 'red' : 'blue',\n    };\n  }\n\n  // Create AI context\n  const context: AIContext = {\n    aiTank: tank,\n    enemyTank,\n    bullets,\n    barriers,\n    suns,\n    mapWidth,\n    mapHeight,\n    tickTime,\n    config: aiConfig,\n  };\n\n  // Get AI decision\n  const decision = makeAIDecision(context);\n\n  // If training, collect step (async, don't wait)\n  if (trainingManager && trainingManager.getIsTraining()) {\n    trainingManager.step(context, decision, undefined, gameId).catch(() => {\n      // Silently handle errors\n    });\n  }\n\n  // Apply decision to tank\n  let newAngle = tank.angle + decision.angleDelta;\n  let newX = tank.x;\n  let newY = tank.y;\n  const newBullets: Bullet[] = [];\n  let newLastShotTime = lastShotTime;\n\n  // Handle movement\n  if (decision.moveDirection !== 0) {\n    const rad = degToRad(newAngle);\n    const speed = decision.moveDirection > 0 ? TANK_SPEED : -TANK_SPEED * 0.7; // Backward is slower\n    const dx = Math.cos(rad) * speed;\n    const dy = Math.sin(rad) * speed;\n    const testX = newX + dx;\n    const testY = newY + dy;\n\n    if (canMoveTo(testX, testY, mapWidth, mapHeight, barriers, allTanks, suns, tankIndex)) {\n      newX = testX;\n      newY = testY;\n    }\n  }\n\n  // Handle shooting\n  if (\n    decision.shouldShoot &&\n    tickTime - lastShotTime > GAME_CONFIG.game.shootingCooldown\n  ) {\n    const bulletCounts = countBulletsByOwner(bullets);\n    const bulletCount = bulletCounts.get(tank.color) || 0;\n    if (bulletCount < MAX_BULLETS_PER_TANK) {\n      const shootAngle = decision.shootAngle ?? newAngle;\n      const bullet = createBullet(\n        { ...tank, x: newX, y: newY, angle: shootAngle },\n        shootAngle,\n        tickTime,\n        tank.color\n      );\n      newBullets.push(bullet);\n      newLastShotTime = tickTime;\n    }\n  }\n\n  // Clamp position\n  const clamped = clampTankPosition(newX, newY, mapWidth, mapHeight);\n  newX = clamped.x;\n  newY = clamped.y;\n\n  return {\n    updatedTank: { ...tank, x: newX, y: newY, angle: newAngle },\n    newBullets,\n    lastShotTime: newLastShotTime,\n    decision, // Include decision for training\n  };\n}\n\n// Export types and config for external use\nexport type { AIConfig, AIContext } from './types';\nexport { DEFAULT_AI_CONFIG, EASY_AI_CONFIG, HARD_AI_CONFIG } from './config';\n\n// Export RL components\nexport { rlModelManager, type RLModel, type ModelInfo } from './rl-model';\nexport { TankTroubleRLEnv, type RLEnvironmentState } from './rl-environment';\nexport { extractObservation, getObservationSize, type Observation } from './rl-observation';\nexport { calculateReward, type RewardInfo } from './rl-reward';\nexport { actionToDecision, NUM_DISCRETE_ACTIONS, DiscreteAction, type ContinuousAction } from './rl-actions';\nexport { useTrainedModel } from './rl-training-example';\n\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3774, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/components/GameLogic.tsx"],"sourcesContent":["import React, { useCallback, useRef, useEffect } from 'react';\nimport type { Tank, Bullet, Barrier, Sun, TankTroubleMapData } from '@/app/games/tank-trouble/types';\nimport { TICK_INTERVAL, GAME_CONFIG } from '@/app/games/tank-trouble/config';\nimport { updatePlayer1Tank, updatePlayer2Tank } from '@/app/games/tank-trouble/utils/tank';\nimport { updateBullets } from '@/app/games/tank-trouble/utils/bullet';\nimport { generateRandomSpawnPosition } from '@/app/games/tank-trouble/utils/spawn';\nimport { updateAITank, type AIConfig } from '@/app/games/tank-trouble/ai-tank';\nimport type { RLTrainingManager } from '@/app/games/tank-trouble/ai-tank/rl-training-manager';\nimport { MAX_EPISODE_TIME_MS } from '@/app/games/tank-trouble/constants/game-constants';\n\nexport interface GameInstance {\n  id: number;\n  tanks: Tank[];\n  bullets: Bullet[];\n  lastShotTimes: { blue: number; red: number };\n  gameMode: 'ai' | 'person-vs-ai';\n  gameId: string;\n  isPaused: boolean;\n  speedMultiplier: number;\n  episodeStartTime?: number;\n  keysRef: React.MutableRefObject<Set<string>>;\n}\n\ninterface MultiGameLogicProps {\n  mapData: TankTroubleMapData;\n  barriers: Barrier[];\n  suns: Sun[];\n  aiConfig?: AIConfig;\n  trainingManager?: RLTrainingManager | null;\n  maxEpisodeTimeMs?: number;\n  gameInstances: GameInstance[];\n  onTanksUpdate: (gameId: number, tanks: Tank[]) => void;\n  onBulletsUpdate: (gameId: number, bullets: Bullet[]) => void;\n  onLastShotTimesUpdate: (gameId: number, times: { blue: number; red: number }) => void;\n  onGameOver: (gameId: number, winner: 'blue' | 'red' | null) => void;\n}\n\ninterface GameTickOptions {\n  skipIntervalCheck?: boolean;\n  gameId?: number; // Optional: tick specific game, otherwise tick all\n}\n\n/**\n * Multi-game logic hook - handles game ticks for multiple game instances\n * This replaces the previous pattern of calling useGameLogic multiple times (which violated Rules of Hooks)\n */\nexport function useMultiGameLogic({\n  mapData,\n  barriers,\n  suns,\n  aiConfig,\n  trainingManager,\n  maxEpisodeTimeMs = MAX_EPISODE_TIME_MS,\n  gameInstances,\n  onTanksUpdate,\n  onBulletsUpdate,\n  onLastShotTimesUpdate,\n  onGameOver,\n}: MultiGameLogicProps) {\n  // Track game over states per game\n  const gameOverTriggeredRefs = useRef<Map<number, boolean>>(new Map());\n  \n  // Track last tick times per game\n  const lastTickRefs = useRef<Map<number, number>>(new Map());\n  \n  // Track tank/bullet refs per game\n  const tanksRefs = useRef<Map<number, Tank[]>>(new Map());\n  const bulletsRefs = useRef<Map<number, Bullet[]>>(new Map());\n  \n  // Store latest gameInstances in ref for access in callback (avoid stale closure)\n  const gameInstancesRef = useRef(gameInstances);\n  \n  // Create a Map for O(1) lookup by gameId instead of O(n) filter\n  const gameInstancesMapRef = useRef<Map<number, GameInstance>>(new Map());\n  \n  useEffect(() => {\n    gameInstancesRef.current = gameInstances;\n    // Update Map for efficient lookups\n    const map = new Map<number, GameInstance>();\n    gameInstances.forEach(instance => {\n      map.set(instance.id, instance);\n    });\n    gameInstancesMapRef.current = map;\n  }, [gameInstances]);\n  \n  // Initialize refs for all games\n  useEffect(() => {\n    gameInstances.forEach((instance) => {\n      if (!tanksRefs.current.has(instance.id)) {\n        tanksRefs.current.set(instance.id, instance.tanks);\n      }\n      if (!bulletsRefs.current.has(instance.id)) {\n        bulletsRefs.current.set(instance.id, instance.bullets);\n      }\n    });\n  }, [gameInstances]);\n  \n  // Update refs when state changes\n  useEffect(() => {\n    gameInstances.forEach((instance) => {\n      const prevTanks = tanksRefs.current.get(instance.id);\n      tanksRefs.current.set(instance.id, instance.tanks);\n      bulletsRefs.current.set(instance.id, instance.bullets);\n      \n      // Reset game over flag when tanks are reset (new game started)\n      if (instance.tanks.length >= 2 && \n          instance.tanks[0]?.lives === GAME_CONFIG.tank.lives && \n          instance.tanks[1]?.lives === GAME_CONFIG.tank.lives) {\n        gameOverTriggeredRefs.current.set(instance.id, false);\n      }\n    });\n  }, [gameInstances]);\n\n  const gameTick = useCallback((options?: GameTickOptions) => {\n    // Use ref to get latest game instances (avoid stale closure)\n    const currentGameInstances = gameInstancesRef.current;\n    const gamesToTick = options?.gameId !== undefined \n      ? (() => {\n          // Use Map for O(1) lookup instead of O(n) filter\n          const instance = gameInstancesMapRef.current.get(options.gameId);\n          return instance ? [instance] : [];\n        })()\n      : currentGameInstances;\n\n    gamesToTick.forEach((instance) => {\n      // Skip if paused\n      if (instance.isPaused) {\n        return;\n      }\n      \n      const now = Date.now();\n      const lastTickTime = lastTickRefs.current.get(instance.id) || 0;\n      \n      // Check interval (unless skipIntervalCheck is true)\n      if (!options?.skipIntervalCheck) {\n        const adjustedTickInterval = TICK_INTERVAL / instance.speedMultiplier;\n        if (now - lastTickTime < adjustedTickInterval) {\n          return;\n        }\n      }\n      \n      const tickTime = now;\n      lastTickRefs.current.set(instance.id, tickTime);\n\n      const currentTanks = [...(tanksRefs.current.get(instance.id) || [])];\n      const currentBullets = [...(bulletsRefs.current.get(instance.id) || [])];\n      let newLastShotTimes = { ...instance.lastShotTimes };\n      const keys = instance.keysRef.current;\n      \n      // Validate tanks exist\n      if (!currentTanks || currentTanks.length < 2) {\n        return;\n      }\n\n      // Update Player 1 (Blue)\n      if (currentTanks[0]?.lives > 0) {\n        let result;\n        \n        if (instance.gameMode === 'person-vs-ai') {\n          result = updatePlayer1Tank({\n            tank: currentTanks[0],\n            tankIndex: 0,\n            keys,\n            tickTime,\n            lastShotTime: instance.lastShotTimes.blue,\n            bullets: currentBullets,\n            mapWidth: mapData.width,\n            mapHeight: mapData.height,\n            barriers,\n            suns,\n            allTanks: currentTanks,\n          });\n        } else if (trainingManager && trainingManager.getIsTraining() && instance.gameMode === 'ai') {\n          result = updateAITank(\n            {\n              tank: currentTanks[0],\n              tankIndex: 0,\n              keys,\n              tickTime,\n              lastShotTime: instance.lastShotTimes.blue,\n              bullets: currentBullets,\n              mapWidth: mapData.width,\n              mapHeight: mapData.height,\n              barriers,\n              suns,\n              allTanks: currentTanks,\n            },\n            aiConfig,\n            trainingManager,\n            `${instance.gameId}-blue`\n          );\n        } else {\n          result = updatePlayer1Tank({\n            tank: currentTanks[0],\n            tankIndex: 0,\n            keys,\n            tickTime,\n            lastShotTime: instance.lastShotTimes.blue,\n            bullets: currentBullets,\n            mapWidth: mapData.width,\n            mapHeight: mapData.height,\n            barriers,\n            suns,\n            allTanks: currentTanks,\n          });\n        }\n        \n        currentTanks[0] = result.updatedTank;\n        currentBullets.push(...result.newBullets);\n        newLastShotTimes.blue = result.lastShotTime;\n      }\n\n      // Update Player 2 (Red)\n      if (currentTanks[1]?.lives > 0) {\n        // Always use AI for red tank (simplified logic - removed duplicate branch)\n        const result = updateAITank(\n          {\n            tank: currentTanks[1],\n            tankIndex: 1,\n            keys,\n            tickTime,\n            lastShotTime: instance.lastShotTimes.red,\n            bullets: currentBullets,\n            mapWidth: mapData.width,\n            mapHeight: mapData.height,\n            barriers,\n            suns,\n            allTanks: currentTanks,\n          },\n          aiConfig,\n          trainingManager,\n          instance.gameId\n        );\n        \n        currentTanks[1] = result.updatedTank;\n        currentBullets.push(...result.newBullets);\n        newLastShotTimes.red = result.lastShotTime;\n      }\n\n      // Update bullets\n      const bulletResult = updateBullets({\n        bullets: currentBullets,\n        tickTime,\n        mapWidth: mapData.width,\n        mapHeight: mapData.height,\n        barriers,\n        suns,\n        tanks: currentTanks,\n      });\n\n      const gameOverTriggered = gameOverTriggeredRefs.current.get(instance.id) || false;\n\n      // Check for timeout\n      if (!gameOverTriggered && instance.episodeStartTime) {\n        const episodeElapsed = tickTime - instance.episodeStartTime;\n        if (episodeElapsed >= maxEpisodeTimeMs) {\n          gameOverTriggeredRefs.current.set(instance.id, true);\n          const blueTank = bulletResult.updatedTanks[0];\n          const redTank = bulletResult.updatedTanks[1];\n          \n          let winner: 'blue' | 'red' | null = null;\n          if (blueTank && redTank) {\n            if (blueTank.lives > redTank.lives) {\n              winner = 'blue';\n            } else if (redTank.lives > blueTank.lives) {\n              winner = 'red';\n            }\n          }\n          \n          bulletResult.updatedBullets = [];\n          bulletResult.updatedTanks[0] = {\n            ...blueTank,\n            exploding: false,\n            explosionStartTime: undefined,\n            respawning: false,\n            respawnStartTime: undefined,\n            respawnTargetX: undefined,\n            respawnTargetY: undefined,\n            respawnTargetAngle: undefined,\n            invincibleUntil: undefined,\n          };\n          bulletResult.updatedTanks[1] = {\n            ...redTank,\n            exploding: false,\n            explosionStartTime: undefined,\n            respawning: false,\n            respawnStartTime: undefined,\n            respawnTargetX: undefined,\n            respawnTargetY: undefined,\n            respawnTargetAngle: undefined,\n            invincibleUntil: undefined,\n          };\n          \n          onTanksUpdate(instance.id, bulletResult.updatedTanks);\n          onBulletsUpdate(instance.id, bulletResult.updatedBullets);\n          onGameOver(instance.id, winner);\n          return;\n        }\n      }\n\n      // Check for game over (tank reached 0 lives)\n      const blueTankAfterBullets = bulletResult.updatedTanks[0];\n      const redTankAfterBullets = bulletResult.updatedTanks[1];\n      \n      if (!gameOverTriggered && blueTankAfterBullets && redTankAfterBullets) {\n        if (blueTankAfterBullets.lives <= 0 || redTankAfterBullets.lives <= 0) {\n          gameOverTriggeredRefs.current.set(instance.id, true);\n          const winner = blueTankAfterBullets.lives <= 0 ? 'red' : 'blue';\n          \n          bulletResult.updatedBullets = [];\n          bulletResult.updatedTanks[0] = {\n            ...blueTankAfterBullets,\n            exploding: false,\n            explosionStartTime: undefined,\n            respawning: false,\n            respawnStartTime: undefined,\n            respawnTargetX: undefined,\n            respawnTargetY: undefined,\n            respawnTargetAngle: undefined,\n            invincibleUntil: undefined,\n          };\n          bulletResult.updatedTanks[1] = {\n            ...redTankAfterBullets,\n            exploding: false,\n            explosionStartTime: undefined,\n            respawning: false,\n            respawnStartTime: undefined,\n            respawnTargetX: undefined,\n            respawnTargetY: undefined,\n            respawnTargetAngle: undefined,\n            invincibleUntil: undefined,\n          };\n          \n          onTanksUpdate(instance.id, bulletResult.updatedTanks);\n          onBulletsUpdate(instance.id, bulletResult.updatedBullets);\n          onGameOver(instance.id, winner);\n          return;\n        }\n      }\n\n      // Handle respawning\n      for (let i = 0; i < bulletResult.updatedTanks.length; i++) {\n        const tank = bulletResult.updatedTanks[i];\n        const originalTank = currentTanks[i];\n        \n        if (tank.lives < originalTank.lives && tank.lives > 0) {\n          const tankColor = tank.color;\n          // Optimized: build new array instead of filter (more explicit, same complexity but clearer intent)\n          const filteredBullets: typeof bulletResult.updatedBullets = [];\n          for (const bullet of bulletResult.updatedBullets) {\n            if (bullet.owner !== tankColor) {\n              filteredBullets.push(bullet);\n            }\n          }\n          bulletResult.updatedBullets = filteredBullets;\n          \n          const spawn = generateRandomSpawnPosition(\n            mapData,\n            barriers,\n            bulletResult.updatedTanks,\n            suns,\n            i === 0 ? bulletResult.updatedTanks[1] : bulletResult.updatedTanks[0]\n              ? { x: bulletResult.updatedTanks[i === 0 ? 1 : 0].x, y: bulletResult.updatedTanks[i === 0 ? 1 : 0].y }\n              : undefined\n          );\n          \n          // Set invincibility for 2 seconds after respawn\n          const INVINCIBILITY_DURATION_MS = 2000; // 2 seconds\n          bulletResult.updatedTanks[i] = {\n            ...tank,\n            x: spawn.x,\n            y: spawn.y,\n            angle: spawn.angle,\n            exploding: false,\n            explosionStartTime: undefined,\n            respawning: false,\n            respawnStartTime: undefined,\n            respawnTargetX: undefined,\n            respawnTargetY: undefined,\n            respawnTargetAngle: undefined,\n            invincibleUntil: tickTime + INVINCIBILITY_DURATION_MS,\n          };\n        }\n        \n        if (tank.exploding || tank.respawning) {\n          bulletResult.updatedTanks[i] = {\n            ...tank,\n            exploding: false,\n            explosionStartTime: undefined,\n            respawning: false,\n            respawnStartTime: undefined,\n            respawnTargetX: undefined,\n            respawnTargetY: undefined,\n            respawnTargetAngle: undefined,\n            // Don't clear invincibleUntil here - it may still be active\n          };\n        }\n        \n        // Clear invincibility if it has expired\n        if (tank.invincibleUntil !== undefined && tickTime >= tank.invincibleUntil) {\n          bulletResult.updatedTanks[i] = {\n            ...tank,\n            invincibleUntil: undefined,\n          };\n        }\n      }\n\n      if (!gameOverTriggered) {\n        onTanksUpdate(instance.id, bulletResult.updatedTanks);\n        onBulletsUpdate(instance.id, bulletResult.updatedBullets);\n        onLastShotTimesUpdate(instance.id, newLastShotTimes);\n      }\n    });\n  }, [\n    mapData,\n    barriers,\n    suns,\n    aiConfig,\n    trainingManager,\n    maxEpisodeTimeMs,\n    onTanksUpdate,\n    onBulletsUpdate,\n    onLastShotTimesUpdate,\n    onGameOver,\n  ]);\n\n  return { gameTick };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4124, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/components/GameCanvas.tsx"],"sourcesContent":["import { useRef, useEffect } from 'react';\nimport type { Tank, Bullet, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport { GAME_CONFIG, TANK_SIZE, SUN_INFLUENCE_RADIUS, BULLET_MAX_AGE } from '@/app/games/tank-trouble/config';\n\ninterface GameCanvasProps {\n  width: number;\n  height: number;\n  tanks: Tank[];\n  bullets: Bullet[];\n  barriers: Barrier[];\n  suns: Sun[];\n  isPaused: boolean;\n  tankImages: { blue: HTMLImageElement | null; red: HTMLImageElement | null };\n  gameOverWinner: 'blue' | 'red' | null;\n  scale?: number; // Optional scale factor for display\n}\n\nexport function GameCanvas({\n  width,\n  height,\n  tanks,\n  bullets,\n  barriers,\n  suns,\n  isPaused,\n  tankImages,\n  gameOverWinner,\n  scale = 1,\n}: GameCanvasProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  // Auto-focus canvas on mount to enable immediate keyboard input\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas) {\n      // Focus the canvas so keyboard events work immediately\n      canvas.focus();\n      \n      // Also focus on click to ensure it stays focused\n      const handleCanvasClick = () => {\n        canvas.focus();\n      };\n      \n      canvas.addEventListener('click', handleCanvasClick);\n      \n      return () => {\n        canvas.removeEventListener('click', handleCanvasClick);\n      };\n    }\n  }, []);\n\n  // Render function\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Scale factor for crisp rendering\n    const scale = 2;\n    canvas.width = width * scale;\n    canvas.height = height * scale;\n    \n    // Reset transform matrix and scale the context\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.scale(scale, scale);\n\n    // Clear canvas completely\n    ctx.clearRect(0, 0, width, height);\n    ctx.fillStyle = '#2D3748';\n    ctx.fillRect(0, 0, width, height);\n\n    // Draw barriers\n    ctx.fillStyle = '#4A5568';\n    for (const barrier of barriers) {\n      ctx.fillRect(barrier.x, barrier.y, barrier.width, barrier.height);\n    }\n\n    // Draw gravitational field arrows (before suns so they appear behind)\n    // Skip if sun gravity is disabled via debug flag\n    if (!GAME_CONFIG.debug.disableSunGravity) {\n      ctx.strokeStyle = 'rgba(98, 156, 119, 0.3)';\n      ctx.fillStyle = 'rgba(98, 156, 119, 0.3)';\n      ctx.lineWidth = 1 / scale;\n      for (const sun of suns) {\n      const gridSpacing = 30;\n      const arrowLength = 8;\n      const arrowHeadSize = 3;\n      \n      // Draw arrows in a grid around the sun\n      for (let x = sun.x - SUN_INFLUENCE_RADIUS; x <= sun.x + SUN_INFLUENCE_RADIUS; x += gridSpacing) {\n        for (let y = sun.y - SUN_INFLUENCE_RADIUS; y <= sun.y + SUN_INFLUENCE_RADIUS; y += gridSpacing) {\n          const dx = sun.x - x;\n          const dy = sun.y - y;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n          \n          // Only draw if within influence radius and not too close to sun\n          if (distance > sun.size + 5 && distance < SUN_INFLUENCE_RADIUS) {\n            const angle = Math.atan2(dy, dx);\n            const normalizedDx = dx / distance;\n            const normalizedDy = dy / distance;\n            \n            // Draw arrow line\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n            ctx.lineTo(\n              x + normalizedDx * arrowLength,\n              y + normalizedDy * arrowLength\n            );\n            ctx.stroke();\n            \n            // Draw arrowhead\n            ctx.save();\n            ctx.translate(x + normalizedDx * arrowLength, y + normalizedDy * arrowLength);\n            ctx.rotate(angle);\n            ctx.beginPath();\n            ctx.moveTo(0, 0);\n            ctx.lineTo(-arrowHeadSize, -arrowHeadSize / 2);\n            ctx.lineTo(-arrowHeadSize, arrowHeadSize / 2);\n            ctx.closePath();\n            ctx.fill();\n            ctx.restore();\n          }\n        }\n      }\n      }\n    }\n\n    // Draw suns (skip if disabled via debug flag)\n    if (!GAME_CONFIG.debug.disableSunGravity) {\n      for (const sun of suns) {\n      const gradient = ctx.createRadialGradient(sun.x, sun.y, 0, sun.x, sun.y, sun.size);\n      gradient.addColorStop(0, 'rgba(98, 156, 119, 0.9)');\n      gradient.addColorStop(0.7, 'rgba(98, 156, 119, 0.75)');\n      gradient.addColorStop(1, 'rgba(98, 156, 119, 0)');\n      ctx.fillStyle = gradient;\n      ctx.beginPath();\n      ctx.arc(sun.x, sun.y, sun.size, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Draw sun outline\n      ctx.strokeStyle = 'rgba(98, 156, 119, 0.5)';\n      ctx.lineWidth = 2 / scale;\n      ctx.stroke();\n      }\n    }\n\n    // Draw tanks (no animations)\n    // Only draw valid tanks (exactly 2 tanks expected: blue and red)\n    // Optimized: direct array access instead of filter (tanks are guaranteed to be valid)\n    const validTanks = tanks.length >= 2 \n      ? [tanks[0], tanks[1]] \n      : tanks.slice(0, 2);\n    \n    for (const tank of validTanks) {\n      // Skip tanks with 0 lives or invalid positions\n      if (tank.lives <= 0 || tank.x === undefined || tank.y === undefined) continue;\n\n      ctx.save();\n      \n      // Check if tank is invincible (recently respawned)\n      // Use Date.now() for visual feedback (rendering doesn't need precise tick time)\n      const isInvincible = tank.invincibleUntil !== undefined && Date.now() < tank.invincibleUntil;\n      \n      // Draw golden circle for invincibility (before tank rotation so it stays centered)\n      if (isInvincible) {\n        const tankCenterX = tank.x + TANK_SIZE / 2;\n        const tankCenterY = tank.y + TANK_SIZE / 2;\n        const circleRadius = TANK_SIZE / 2 + 3; // Slightly larger than tank\n        \n        ctx.beginPath();\n        ctx.arc(tankCenterX, tankCenterY, circleRadius, 0, Math.PI * 2);\n        ctx.strokeStyle = '#FFD700'; // Golden color\n        ctx.lineWidth = 2 / scale;\n        ctx.stroke();\n      }\n      \n      ctx.translate(tank.x + TANK_SIZE / 2, tank.y + TANK_SIZE / 2);\n      ctx.rotate((tank.angle * Math.PI) / 180);\n      ctx.translate(-TANK_SIZE / 2, -TANK_SIZE / 2);\n      \n      // Draw tank image\n      const tankImage = tank.color === 'blue' ? tankImages.blue : tankImages.red;\n      if (tankImage) {\n        ctx.drawImage(tankImage, 0, 0, TANK_SIZE, TANK_SIZE);\n      } else {\n        // Fallback: draw colored rectangle if image not loaded\n        ctx.fillStyle = tank.color === 'blue' ? '#3B82F6' : '#EF4444';\n        ctx.fillRect(0, 0, TANK_SIZE, TANK_SIZE);\n        ctx.strokeStyle = tank.color === 'blue' ? '#1E40AF' : '#DC2626';\n        ctx.lineWidth = 2 / scale;\n        ctx.strokeRect(0, 0, TANK_SIZE, TANK_SIZE);\n      }\n\n      ctx.restore();\n\n      // Draw lives indicator\n      ctx.fillStyle = tank.color === 'blue' ? '#3B82F6' : '#EF4444';\n      for (let i = 0; i < tank.lives; i++) {\n        ctx.beginPath();\n        ctx.arc(\n          tank.x + GAME_CONFIG.visual.livesIndicatorOffsetX + i * GAME_CONFIG.visual.livesIndicatorSpacing,\n          tank.y + GAME_CONFIG.visual.livesIndicatorOffsetY,\n          GAME_CONFIG.visual.livesIndicatorRadius,\n          0,\n          Math.PI * 2\n        );\n        ctx.fill();\n      }\n    }\n\n    // Draw bullets (no explosion animations)\n    for (const bullet of bullets) {\n      // Skip exploding bullets (they're removed immediately, no animation)\n      if (bullet.exploding) {\n        continue;\n      }\n      \n      // Calculate fade alpha for bullets that are expiring (after 7 seconds)\n      const age = Date.now() - bullet.createdAt;\n      const fadeDuration = GAME_CONFIG.bullet.fadeDuration;\n      let alpha = 1;\n      \n      if (age > BULLET_MAX_AGE) {\n        // Bullet is fading out\n        const fadeProgress = (age - BULLET_MAX_AGE) / fadeDuration;\n        alpha = Math.max(0, 1 - fadeProgress);\n      }\n      \n      // Only draw if still visible\n      if (alpha > 0) {\n        // Extract RGB values and apply alpha\n        const r = bullet.owner === 'blue' ? 59 : 239;\n        const g = bullet.owner === 'blue' ? 130 : 68;\n        const b = bullet.owner === 'blue' ? 246 : 68;\n        \n        ctx.save();\n        ctx.globalAlpha = alpha;\n        \n        // Draw simple rectangle bullet with rounded corners\n        const bulletLength = 6;\n        const bulletWidth = 3;\n        const radius = 1; // Small border radius\n        const angleRad = (bullet.angle * Math.PI) / 180;\n        \n        // Translate and rotate to bullet position and angle\n        ctx.translate(bullet.x, bullet.y);\n        ctx.rotate(angleRad);\n        \n        // Draw rounded rectangle\n        const x = -bulletLength / 2;\n        const y = -bulletWidth / 2;\n        const w = bulletLength;\n        const h = bulletWidth;\n        \n        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;\n        ctx.beginPath();\n        ctx.moveTo(x + radius, y);\n        ctx.lineTo(x + w - radius, y);\n        ctx.quadraticCurveTo(x + w, y, x + w, y + radius);\n        ctx.lineTo(x + w, y + h - radius);\n        ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);\n        ctx.lineTo(x + radius, y + h);\n        ctx.quadraticCurveTo(x, y + h, x, y + h - radius);\n        ctx.lineTo(x, y + radius);\n        ctx.quadraticCurveTo(x, y, x + radius, y);\n        ctx.closePath();\n        ctx.fill();\n        \n        ctx.restore();\n      }\n    }\n\n    // Draw UI (lives counter removed from bottom-left)\n    \n    // Draw instructions in top-right corner\n    ctx.textAlign = 'right';\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n    ctx.font = `${GAME_CONFIG.visual.uiTextSize - 1}px Inter`;\n    const instructionY = GAME_CONFIG.visual.uiTextOffsetY;\n    const instructionX = width - GAME_CONFIG.visual.uiTextOffsetX;\n    ctx.fillText('Player 1 (Blue): Arrows + Space', instructionX, instructionY);\n    ctx.fillText('Player 2 (Red): WASD + Q', instructionX, instructionY + 12);\n    ctx.textAlign = 'left'; // Reset alignment\n    \n    // Draw game over screen\n    if (gameOverWinner) {\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n      ctx.fillRect(0, 0, width, height);\n      ctx.fillStyle = '#FFFFFF';\n      ctx.font = 'bold 32px Inter';\n      ctx.textAlign = 'center';\n      const winnerText = gameOverWinner === 'blue' ? 'BLUE WINS!' : 'RED WINS!';\n      ctx.fillText(winnerText, width / 2, height / 2 - 20);\n      ctx.font = '20px Inter';\n      ctx.fillText('Press any key to play again', width / 2, height / 2 + 20);\n      ctx.textAlign = 'left'; // Reset alignment\n    }\n    \n    // Draw pause indicator\n    if (isPaused && !gameOverWinner) {\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n      ctx.fillRect(0, 0, width, height);\n      ctx.fillStyle = '#FFFFFF';\n      ctx.font = 'bold 48px Inter';\n      ctx.textAlign = 'center';\n      ctx.fillText('PAUSED', width / 2, height / 2);\n      ctx.textAlign = 'left'; // Reset alignment\n    }\n    \n    // Debug text removed\n  }, [width, height, tanks, bullets, barriers, suns, isPaused, tankImages, gameOverWinner]);\n\n  // Calculate display size: internal resolution is 2x for crisp rendering, then apply scale\n  const displayWidth = width * 2 * scale;\n  const displayHeight = height * 2 * scale;\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className=\"border-2 border-[#4A5568] rounded outline-none\"\n      style={{ \n        width: `${displayWidth}px`, \n        height: `${displayHeight}px`,\n        display: 'block',\n      }}\n      tabIndex={0}\n      onFocus={(e) => e.target.focus()}\n    />\n  );\n}\n\n"],"names":[],"mappings":";;;;;AAAA;AAEA;;;;AAeO,SAAS,WAAW,EACzB,KAAK,EACL,MAAM,EACN,KAAK,EACL,OAAO,EACP,QAAQ,EACR,IAAI,EACJ,QAAQ,EACR,UAAU,EACV,cAAc,EACd,QAAQ,CAAC,EACO;IAChB,MAAM,YAAY,IAAA,gXAAM,EAAoB;IAE5C,gEAAgE;IAChE,IAAA,mXAAS,EAAC;QACR,MAAM,SAAS,UAAU,OAAO;QAChC,IAAI,QAAQ;YACV,uDAAuD;YACvD,OAAO,KAAK;YAEZ,iDAAiD;YACjD,MAAM,oBAAoB;gBACxB,OAAO,KAAK;YACd;YAEA,OAAO,gBAAgB,CAAC,SAAS;YAEjC,OAAO;gBACL,OAAO,mBAAmB,CAAC,SAAS;YACtC;QACF;IACF,GAAG,EAAE;IAEL,kBAAkB;IAClB,IAAA,mXAAS,EAAC;QACR,MAAM,SAAS,UAAU,OAAO;QAChC,IAAI,CAAC,QAAQ;QAEb,MAAM,MAAM,OAAO,UAAU,CAAC;QAC9B,IAAI,CAAC,KAAK;QAEV,mCAAmC;QACnC,MAAM,QAAQ;QACd,OAAO,KAAK,GAAG,QAAQ;QACvB,OAAO,MAAM,GAAG,SAAS;QAEzB,+CAA+C;QAC/C,IAAI,YAAY,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG;QAChC,IAAI,KAAK,CAAC,OAAO;QAEjB,0BAA0B;QAC1B,IAAI,SAAS,CAAC,GAAG,GAAG,OAAO;QAC3B,IAAI,SAAS,GAAG;QAChB,IAAI,QAAQ,CAAC,GAAG,GAAG,OAAO;QAE1B,gBAAgB;QAChB,IAAI,SAAS,GAAG;QAChB,KAAK,MAAM,WAAW,SAAU;YAC9B,IAAI,QAAQ,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,EAAE,QAAQ,KAAK,EAAE,QAAQ,MAAM;QAClE;QAEA,sEAAsE;QACtE,iDAAiD;QACjD,IAAI,CAAC,mKAAW,CAAC,KAAK,CAAC,iBAAiB,EAAE;YACxC,IAAI,WAAW,GAAG;YAClB,IAAI,SAAS,GAAG;YAChB,IAAI,SAAS,GAAG,IAAI;YACpB,KAAK,MAAM,OAAO,KAAM;gBACxB,MAAM,cAAc;gBACpB,MAAM,cAAc;gBACpB,MAAM,gBAAgB;gBAEtB,uCAAuC;gBACvC,IAAK,IAAI,IAAI,IAAI,CAAC,GAAG,4KAAoB,EAAE,KAAK,IAAI,CAAC,GAAG,4KAAoB,EAAE,KAAK,YAAa;oBAC9F,IAAK,IAAI,IAAI,IAAI,CAAC,GAAG,4KAAoB,EAAE,KAAK,IAAI,CAAC,GAAG,4KAAoB,EAAE,KAAK,YAAa;wBAC9F,MAAM,KAAK,IAAI,CAAC,GAAG;wBACnB,MAAM,KAAK,IAAI,CAAC,GAAG;wBACnB,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK,KAAK,KAAK;wBAE1C,gEAAgE;wBAChE,IAAI,WAAW,IAAI,IAAI,GAAG,KAAK,WAAW,4KAAoB,EAAE;4BAC9D,MAAM,QAAQ,KAAK,KAAK,CAAC,IAAI;4BAC7B,MAAM,eAAe,KAAK;4BAC1B,MAAM,eAAe,KAAK;4BAE1B,kBAAkB;4BAClB,IAAI,SAAS;4BACb,IAAI,MAAM,CAAC,GAAG;4BACd,IAAI,MAAM,CACR,IAAI,eAAe,aACnB,IAAI,eAAe;4BAErB,IAAI,MAAM;4BAEV,iBAAiB;4BACjB,IAAI,IAAI;4BACR,IAAI,SAAS,CAAC,IAAI,eAAe,aAAa,IAAI,eAAe;4BACjE,IAAI,MAAM,CAAC;4BACX,IAAI,SAAS;4BACb,IAAI,MAAM,CAAC,GAAG;4BACd,IAAI,MAAM,CAAC,CAAC,eAAe,CAAC,gBAAgB;4BAC5C,IAAI,MAAM,CAAC,CAAC,eAAe,gBAAgB;4BAC3C,IAAI,SAAS;4BACb,IAAI,IAAI;4BACR,IAAI,OAAO;wBACb;oBACF;gBACF;YACA;QACF;QAEA,8CAA8C;QAC9C,IAAI,CAAC,mKAAW,CAAC,KAAK,CAAC,iBAAiB,EAAE;YACxC,KAAK,MAAM,OAAO,KAAM;gBACxB,MAAM,WAAW,IAAI,oBAAoB,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,IAAI,IAAI;gBACjF,SAAS,YAAY,CAAC,GAAG;gBACzB,SAAS,YAAY,CAAC,KAAK;gBAC3B,SAAS,YAAY,CAAC,GAAG;gBACzB,IAAI,SAAS,GAAG;gBAChB,IAAI,SAAS;gBACb,IAAI,GAAG,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,IAAI,IAAI,EAAE,GAAG,KAAK,EAAE,GAAG;gBAC7C,IAAI,IAAI;gBAER,mBAAmB;gBACnB,IAAI,WAAW,GAAG;gBAClB,IAAI,SAAS,GAAG,IAAI;gBACpB,IAAI,MAAM;YACV;QACF;QAEA,6BAA6B;QAC7B,iEAAiE;QACjE,sFAAsF;QACtF,MAAM,aAAa,MAAM,MAAM,IAAI,IAC/B;YAAC,KAAK,CAAC,EAAE;YAAE,KAAK,CAAC,EAAE;SAAC,GACpB,MAAM,KAAK,CAAC,GAAG;QAEnB,KAAK,MAAM,QAAQ,WAAY;YAC7B,+CAA+C;YAC/C,IAAI,KAAK,KAAK,IAAI,KAAK,KAAK,CAAC,KAAK,aAAa,KAAK,CAAC,KAAK,WAAW;YAErE,IAAI,IAAI;YAER,mDAAmD;YACnD,gFAAgF;YAChF,MAAM,eAAe,KAAK,eAAe,KAAK,aAAa,KAAK,GAAG,KAAK,KAAK,eAAe;YAE5F,mFAAmF;YACnF,IAAI,cAAc;gBAChB,MAAM,cAAc,KAAK,CAAC,GAAG,iKAAS,GAAG;gBACzC,MAAM,cAAc,KAAK,CAAC,GAAG,iKAAS,GAAG;gBACzC,MAAM,eAAe,iKAAS,GAAG,IAAI,GAAG,4BAA4B;gBAEpE,IAAI,SAAS;gBACb,IAAI,GAAG,CAAC,aAAa,aAAa,cAAc,GAAG,KAAK,EAAE,GAAG;gBAC7D,IAAI,WAAW,GAAG,WAAW,eAAe;gBAC5C,IAAI,SAAS,GAAG,IAAI;gBACpB,IAAI,MAAM;YACZ;YAEA,IAAI,SAAS,CAAC,KAAK,CAAC,GAAG,iKAAS,GAAG,GAAG,KAAK,CAAC,GAAG,iKAAS,GAAG;YAC3D,IAAI,MAAM,CAAC,AAAC,KAAK,KAAK,GAAG,KAAK,EAAE,GAAI;YACpC,IAAI,SAAS,CAAC,CAAC,iKAAS,GAAG,GAAG,CAAC,iKAAS,GAAG;YAE3C,kBAAkB;YAClB,MAAM,YAAY,KAAK,KAAK,KAAK,SAAS,WAAW,IAAI,GAAG,WAAW,GAAG;YAC1E,IAAI,WAAW;gBACb,IAAI,SAAS,CAAC,WAAW,GAAG,GAAG,iKAAS,EAAE,iKAAS;YACrD,OAAO;gBACL,uDAAuD;gBACvD,IAAI,SAAS,GAAG,KAAK,KAAK,KAAK,SAAS,YAAY;gBACpD,IAAI,QAAQ,CAAC,GAAG,GAAG,iKAAS,EAAE,iKAAS;gBACvC,IAAI,WAAW,GAAG,KAAK,KAAK,KAAK,SAAS,YAAY;gBACtD,IAAI,SAAS,GAAG,IAAI;gBACpB,IAAI,UAAU,CAAC,GAAG,GAAG,iKAAS,EAAE,iKAAS;YAC3C;YAEA,IAAI,OAAO;YAEX,uBAAuB;YACvB,IAAI,SAAS,GAAG,KAAK,KAAK,KAAK,SAAS,YAAY;YACpD,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,KAAK,EAAE,IAAK;gBACnC,IAAI,SAAS;gBACb,IAAI,GAAG,CACL,KAAK,CAAC,GAAG,mKAAW,CAAC,MAAM,CAAC,qBAAqB,GAAG,IAAI,mKAAW,CAAC,MAAM,CAAC,qBAAqB,EAChG,KAAK,CAAC,GAAG,mKAAW,CAAC,MAAM,CAAC,qBAAqB,EACjD,mKAAW,CAAC,MAAM,CAAC,oBAAoB,EACvC,GACA,KAAK,EAAE,GAAG;gBAEZ,IAAI,IAAI;YACV;QACF;QAEA,yCAAyC;QACzC,KAAK,MAAM,UAAU,QAAS;YAC5B,qEAAqE;YACrE,IAAI,OAAO,SAAS,EAAE;gBACpB;YACF;YAEA,uEAAuE;YACvE,MAAM,MAAM,KAAK,GAAG,KAAK,OAAO,SAAS;YACzC,MAAM,eAAe,mKAAW,CAAC,MAAM,CAAC,YAAY;YACpD,IAAI,QAAQ;YAEZ,IAAI,MAAM,sKAAc,EAAE;gBACxB,uBAAuB;gBACvB,MAAM,eAAe,CAAC,MAAM,sKAAc,IAAI;gBAC9C,QAAQ,KAAK,GAAG,CAAC,GAAG,IAAI;YAC1B;YAEA,6BAA6B;YAC7B,IAAI,QAAQ,GAAG;gBACb,qCAAqC;gBACrC,MAAM,IAAI,OAAO,KAAK,KAAK,SAAS,KAAK;gBACzC,MAAM,IAAI,OAAO,KAAK,KAAK,SAAS,MAAM;gBAC1C,MAAM,IAAI,OAAO,KAAK,KAAK,SAAS,MAAM;gBAE1C,IAAI,IAAI;gBACR,IAAI,WAAW,GAAG;gBAElB,oDAAoD;gBACpD,MAAM,eAAe;gBACrB,MAAM,cAAc;gBACpB,MAAM,SAAS,GAAG,sBAAsB;gBACxC,MAAM,WAAW,AAAC,OAAO,KAAK,GAAG,KAAK,EAAE,GAAI;gBAE5C,oDAAoD;gBACpD,IAAI,SAAS,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC;gBAChC,IAAI,MAAM,CAAC;gBAEX,yBAAyB;gBACzB,MAAM,IAAI,CAAC,eAAe;gBAC1B,MAAM,IAAI,CAAC,cAAc;gBACzB,MAAM,IAAI;gBACV,MAAM,IAAI;gBAEV,IAAI,SAAS,GAAG,CAAC,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;gBACvC,IAAI,SAAS;gBACb,IAAI,MAAM,CAAC,IAAI,QAAQ;gBACvB,IAAI,MAAM,CAAC,IAAI,IAAI,QAAQ;gBAC3B,IAAI,gBAAgB,CAAC,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI;gBAC1C,IAAI,MAAM,CAAC,IAAI,GAAG,IAAI,IAAI;gBAC1B,IAAI,gBAAgB,CAAC,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,QAAQ,IAAI;gBACvD,IAAI,MAAM,CAAC,IAAI,QAAQ,IAAI;gBAC3B,IAAI,gBAAgB,CAAC,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI;gBAC1C,IAAI,MAAM,CAAC,GAAG,IAAI;gBAClB,IAAI,gBAAgB,CAAC,GAAG,GAAG,IAAI,QAAQ;gBACvC,IAAI,SAAS;gBACb,IAAI,IAAI;gBAER,IAAI,OAAO;YACb;QACF;QAEA,mDAAmD;QAEnD,wCAAwC;QACxC,IAAI,SAAS,GAAG;QAChB,IAAI,SAAS,GAAG;QAChB,IAAI,IAAI,GAAG,GAAG,mKAAW,CAAC,MAAM,CAAC,UAAU,GAAG,EAAE,QAAQ,CAAC;QACzD,MAAM,eAAe,mKAAW,CAAC,MAAM,CAAC,aAAa;QACrD,MAAM,eAAe,QAAQ,mKAAW,CAAC,MAAM,CAAC,aAAa;QAC7D,IAAI,QAAQ,CAAC,mCAAmC,cAAc;QAC9D,IAAI,QAAQ,CAAC,4BAA4B,cAAc,eAAe;QACtE,IAAI,SAAS,GAAG,QAAQ,kBAAkB;QAE1C,wBAAwB;QACxB,IAAI,gBAAgB;YAClB,IAAI,SAAS,GAAG;YAChB,IAAI,QAAQ,CAAC,GAAG,GAAG,OAAO;YAC1B,IAAI,SAAS,GAAG;YAChB,IAAI,IAAI,GAAG;YACX,IAAI,SAAS,GAAG;YAChB,MAAM,aAAa,mBAAmB,SAAS,eAAe;YAC9D,IAAI,QAAQ,CAAC,YAAY,QAAQ,GAAG,SAAS,IAAI;YACjD,IAAI,IAAI,GAAG;YACX,IAAI,QAAQ,CAAC,+BAA+B,QAAQ,GAAG,SAAS,IAAI;YACpE,IAAI,SAAS,GAAG,QAAQ,kBAAkB;QAC5C;QAEA,uBAAuB;QACvB,IAAI,YAAY,CAAC,gBAAgB;YAC/B,IAAI,SAAS,GAAG;YAChB,IAAI,QAAQ,CAAC,GAAG,GAAG,OAAO;YAC1B,IAAI,SAAS,GAAG;YAChB,IAAI,IAAI,GAAG;YACX,IAAI,SAAS,GAAG;YAChB,IAAI,QAAQ,CAAC,UAAU,QAAQ,GAAG,SAAS;YAC3C,IAAI,SAAS,GAAG,QAAQ,kBAAkB;QAC5C;IAEA,qBAAqB;IACvB,GAAG;QAAC;QAAO;QAAQ;QAAO;QAAS;QAAU;QAAM;QAAU;QAAY;KAAe;IAExF,0FAA0F;IAC1F,MAAM,eAAe,QAAQ,IAAI;IACjC,MAAM,gBAAgB,SAAS,IAAI;IAEnC,qBACE,+YAAC;QACC,KAAK;QACL,WAAU;QACV,OAAO;YACL,OAAO,GAAG,aAAa,EAAE,CAAC;YAC1B,QAAQ,GAAG,cAAc,EAAE,CAAC;YAC5B,SAAS;QACX;QACA,UAAU;QACV,SAAS,CAAC,IAAM,EAAE,MAAM,CAAC,KAAK;;;;;;AAGpC"}},
    {"offset": {"line": 4462, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/rl-dqn-model.ts"],"sourcesContent":["/**\n * DQN (Deep Q-Network) Model Implementation\n * \n * Implements a DQN agent using TensorFlow.js for browser-based training.\n * DQN is well-suited for discrete action spaces.\n */\n\nimport * as tf from '@tensorflow/tfjs';\nimport type { Observation } from './rl-observation';\nimport type { AIDecision } from './types';\nimport { actionToDecision, NUM_DISCRETE_ACTIONS } from './rl-actions';\nimport { getObservationSize } from './rl-observation';\nimport { ROTATION_SPEED } from '@/app/games/tank-trouble/config';\nimport { assertType, is2DNumberArray, isError } from '@/lib/type-guards';\n\nexport interface DQNConfig {\n  observationSize: number;\n  actionSize: number;\n  learningRate: number;\n  hiddenLayers: number[];\n  gamma: number; // Discount factor\n  epsilonStart: number;\n  epsilonEnd: number;\n  epsilonDecay: number;\n  batchSize: number;\n  replayBufferSize: number;\n  targetUpdateFrequency: number;\n}\n\nexport const DEFAULT_DQN_CONFIG: DQNConfig = {\n  observationSize: getObservationSize(),\n  actionSize: NUM_DISCRETE_ACTIONS,\n  learningRate: 0.001,\n  hiddenLayers: [128, 128, 64],\n  gamma: 0.99,\n  epsilonStart: 1.0,\n  epsilonEnd: 0.01,\n  epsilonDecay: 0.995,\n  batchSize: 32,\n  replayBufferSize: 10000,\n  targetUpdateFrequency: 100,\n};\n\n/**\n * Step for replay buffer (state, action, reward, nextState, done)\n */\nexport interface Step {\n  state: number[];\n  action: number;\n  reward: number;\n  nextState: number[];\n  done: boolean;\n}\n\n/**\n * DQN Agent\n */\nexport class DQNAgent {\n  private qNetwork: tf.LayersModel | null = null;\n  private targetNetwork: tf.LayersModel | null = null;\n  private config: DQNConfig;\n  private epsilon: number;\n  private stepCount: number = 0;\n  private trainingInProgress: Promise<number> | null = null; // Active training promise - null means no training\n  private isDisposed: boolean = false; // Track if agent has been disposed\n\n  constructor(config: Partial<DQNConfig> = {}) {\n    this.config = { ...DEFAULT_DQN_CONFIG, ...config };\n    this.epsilon = this.config.epsilonStart;\n  }\n\n  /**\n   * Initialize the neural networks\n   */\n  async initialize(): Promise<void> {\n    this.qNetwork = this.createNetwork();\n    this.targetNetwork = this.createNetwork();\n    this.updateTargetNetwork();\n  }\n\n  /**\n   * Create the Q-network architecture\n   */\n  private createNetwork(): tf.LayersModel {\n    const model = tf.sequential();\n\n    // Input layer\n    model.add(\n      tf.layers.dense({\n        inputShape: [this.config.observationSize],\n        units: this.config.hiddenLayers[0],\n        activation: 'relu',\n        kernelInitializer: 'heNormal',\n      })\n    );\n\n    // Hidden layers\n    for (let i = 1; i < this.config.hiddenLayers.length; i++) {\n      model.add(\n        tf.layers.dense({\n          units: this.config.hiddenLayers[i],\n          activation: 'relu',\n          kernelInitializer: 'heNormal',\n        })\n      );\n    }\n\n    // Output layer (Q-values for each action)\n    model.add(\n      tf.layers.dense({\n        units: this.config.actionSize,\n        activation: 'linear',\n        kernelInitializer: 'zeros',\n      })\n    );\n\n    // Compile model\n    model.compile({\n      optimizer: tf.train.adam(this.config.learningRate),\n      loss: 'meanSquaredError',\n    });\n\n    return model;\n  }\n\n  /**\n   * Check if networks are valid and not disposed\n   */\n  private areNetworksValid(): boolean {\n    return !this.isDisposed && this.qNetwork !== null && this.targetNetwork !== null;\n  }\n\n  /**\n   * Select action using epsilon-greedy policy\n   */\n  async selectAction(observation: Observation, training: boolean = true): Promise<number> {\n    if (!this.qNetwork) {\n      throw new Error('Network not initialized. Call initialize() first.');\n    }\n\n    // Exploration: random action\n    if (training && Math.random() < this.epsilon) {\n      return Math.floor(Math.random() * this.config.actionSize);\n    }\n\n    // Exploitation: best action according to Q-network\n    const stateTensor = tf.tensor2d([observation.vector]);\n    const qValuesResult = this.qNetwork.predict(stateTensor);\n    // Type guard for TensorFlow Tensor\n    const qValues = assertType(\n      qValuesResult,\n      (val): val is tf.Tensor => val instanceof tf.Tensor,\n      'Expected Tensor from predict'\n    );\n    const qValuesArray = await qValues.data();\n    stateTensor.dispose();\n    qValues.dispose();\n\n    // Find action with highest Q-value\n    let bestAction = 0;\n    let bestQValue = qValuesArray[0];\n    for (let i = 1; i < qValuesArray.length; i++) {\n      if (qValuesArray[i] > bestQValue) {\n        bestQValue = qValuesArray[i];\n        bestAction = i;\n      }\n    }\n\n    return bestAction;\n  }\n\n  /**\n   * Predict action (for inference, no exploration)\n   */\n  async predict(observation: Observation, currentAngle: number): Promise<AIDecision> {\n    const action = await this.selectAction(observation, false);\n    return actionToDecision(action, currentAngle);\n  }\n\n  /**\n   * Train on a batch of steps\n   * \n   * Note: This method prevents concurrent training calls by using a promise-based lock.\n   * If training is already in progress, this call will wait for it and skip (return 0).\n   */\n  async train(steps: Step[]): Promise<number> {\n    if (!this.areNetworksValid() || steps.length === 0) {\n      return 0;\n    }\n\n    // If training is already in progress, wait for it and skip this call\n    if (this.trainingInProgress) {\n      try {\n        await this.trainingInProgress;\n      } catch (error) {\n        // Ignore errors from previous training - we're just waiting\n      }\n      return 0;\n    }\n\n    // Create and assign the promise SYNCHRONOUSLY before any async work\n    let resolveTraining: ((value: number) => void) | undefined;\n    let rejectTraining: ((error: unknown) => void) | undefined;\n    \n    this.trainingInProgress = new Promise<number>((resolve, reject) => {\n      resolveTraining = resolve;\n      rejectTraining = reject;\n    });\n\n    // Start async training work\n    this.executeTraining(steps, this.trainingInProgress)\n      .then((result) => {\n        this.trainingInProgress = null;\n        if (resolveTraining) resolveTraining(result);\n      })\n      .catch((error) => {\n        this.trainingInProgress = null;\n        if (rejectTraining) rejectTraining(error);\n      });\n\n    try {\n      return await this.trainingInProgress;\n    } catch (error) {\n      // Return 0 on error instead of throwing - training errors shouldn't crash the app\n      return 0;\n    }\n  }\n\n  /**\n   * Internal method that performs the actual training\n   */\n  private async executeTraining(steps: Step[], currentTrainingPromise: Promise<number>): Promise<number> {\n    // Prepare batch\n    const batchSize = Math.min(steps.length, this.config.batchSize);\n    const states: number[][] = [];\n    const actions: number[] = [];\n    const rewards: number[] = [];\n    const nextStates: number[][] = [];\n    const dones: boolean[] = [];\n\n    for (let i = 0; i < batchSize; i++) {\n      const step = steps[i];\n      states.push(step.state);\n      actions.push(step.action);\n      rewards.push(step.reward);\n      nextStates.push(step.nextState);\n      dones.push(step.done);\n    }\n\n    // Create tensors\n    const statesTensor = tf.tensor2d(states);\n    const nextStatesTensor = tf.tensor2d(nextStates);\n    \n    // Track all tensors for cleanup\n    const tensorsToDispose: tf.Tensor[] = [statesTensor, nextStatesTensor];\n\n    try {\n      // Verify we're still the active training call and networks are valid\n      if (!this.areNetworksValid() || this.trainingInProgress !== currentTrainingPromise) {\n        return 0;\n      }\n\n      // Get Q-values from both networks\n      if (!this.qNetwork || !this.targetNetwork) {\n        throw new Error('Networks not initialized');\n      }\n      const currentQValuesResult = this.qNetwork.predict(statesTensor);\n      const nextQValuesResult = this.targetNetwork.predict(nextStatesTensor);\n      \n      // Type guards for TensorFlow Tensors\n      const currentQValues = assertType(\n        currentQValuesResult,\n        (val): val is tf.Tensor => val instanceof tf.Tensor,\n        'Expected Tensor from predict'\n      );\n      const nextQValues = assertType(\n        nextQValuesResult,\n        (val): val is tf.Tensor => val instanceof tf.Tensor,\n        'Expected Tensor from predict'\n      );\n      tensorsToDispose.push(currentQValues, nextQValues);\n\n      // Extract arrays (this is async, but if network is disposed, it will throw)\n      const currentQArrayResult = await currentQValues.array();\n      const nextQArrayResult = await nextQValues.array();\n      \n      // Type guard for 2D number arrays\n      const currentQArray = assertType(\n        currentQArrayResult,\n        is2DNumberArray,\n        'Expected 2D number array from tensor.array()'\n      );\n      const nextQArray = assertType(\n        nextQArrayResult,\n        is2DNumberArray,\n        'Expected 2D number array from tensor.array()'\n      );\n\n      // Verify again after async operation\n      if (!this.areNetworksValid() || this.trainingInProgress !== currentTrainingPromise) {\n        return 0;\n      }\n\n      // Compute target Q-values\n      const targets: number[][] = [];\n      for (let i = 0; i < batchSize; i++) {\n        const target = [...currentQArray[i]];\n        const maxNextQ = Math.max(...nextQArray[i]);\n        const targetQ = rewards[i] + (dones[i] ? 0 : this.config.gamma * maxNextQ);\n        target[actions[i]] = targetQ;\n        targets.push(target);\n      }\n\n      const targetsTensor = tf.tensor2d(targets);\n      tensorsToDispose.push(targetsTensor);\n\n      // Final check before training\n      if (!this.areNetworksValid() || this.trainingInProgress !== currentTrainingPromise) {\n        return 0;\n      }\n\n      // Train the network\n      if (!this.qNetwork) {\n        throw new Error('Network not initialized');\n      }\n      const history = await this.qNetwork.fit(statesTensor, targetsTensor, {\n        epochs: 1,\n        verbose: 0,\n        batchSize: batchSize,\n      });\n\n      // Extract loss value\n      let loss: number = 0;\n      if (Array.isArray(history.history.loss)) {\n        const firstLoss = history.history.loss[0];\n        if (typeof firstLoss === 'number') {\n          loss = firstLoss;\n        }\n      } else if (typeof history.history.loss === 'number') {\n        loss = history.history.loss;\n      } else if (history.history.loss && typeof history.history.loss === 'object') {\n        // Check if it has dataSync method (TensorFlow Tensor)\n        // Use JSON to safely access properties without type assertions\n        try {\n          const jsonString = JSON.stringify(history.history.loss);\n          const parsed = JSON.parse(jsonString);\n          // TensorFlow tensors can't be serialized, so if we get here it's not a tensor\n          // Skip this branch for tensor objects\n        } catch {\n          // If JSON.stringify fails, it might be a TensorFlow tensor\n          // Check for dataSync method using property access\n          // Skip tensor handling to avoid type assertions\n          // In practice, loss should be a number or array, not a tensor\n          // TensorFlow tensors can't be safely handled without type assertions\n        }\n      }\n\n      // Update epsilon\n      this.epsilon = Math.max(\n        this.config.epsilonEnd,\n        this.epsilon * this.config.epsilonDecay\n      );\n\n      // Update target network periodically\n      this.stepCount++;\n      if (this.stepCount % this.config.targetUpdateFrequency === 0) {\n        this.updateTargetNetwork();\n      }\n\n      return loss;\n    } catch (error: unknown) {\n      // If network was disposed, silently return 0\n      // Otherwise, log the error but don't throw (training errors shouldn't crash)\n      const errorMessage = isError(error) ? error.message : String(error);\n      if (!errorMessage.includes('disposed')) {\n      }\n      return 0;\n    } finally {\n      // Always cleanup tensors\n      tensorsToDispose.forEach(tensor => {\n        try {\n          tensor.dispose();\n        } catch (e) {\n          // Ignore disposal errors\n        }\n      });\n    }\n  }\n\n  /**\n   * Copy weights from Q-network to target network\n   */\n  private updateTargetNetwork(): void {\n    if (!this.qNetwork || !this.targetNetwork) {\n      return;\n    }\n\n    const weights = this.qNetwork.getWeights();\n    this.targetNetwork.setWeights(weights);\n  }\n\n  /**\n   * Get current epsilon (for logging)\n   */\n  getEpsilon(): number {\n    return this.epsilon;\n  }\n\n  /**\n   * Save model\n   */\n  async save(path: string): Promise<void> {\n    if (typeof window === 'undefined') {\n      throw new Error('Cannot save model: IndexedDB is only available in the browser (not during SSR)');\n    }\n    \n    if (!this.qNetwork) {\n      throw new Error('Network not initialized. Cannot save model.');\n    }\n    \n    // Verify the model is valid and not disposed\n    if (!this.areNetworksValid()) {\n      throw new Error('Network has been disposed. Cannot save model.');\n    }\n    \n    // Check if IndexedDB is available\n    if (typeof indexedDB === 'undefined') {\n      throw new Error('IndexedDB is not available in this browser. Cannot save model.');\n    }\n    \n    try {\n      \n      // Verify path format - TensorFlow.js expects 'indexeddb://model-name'\n      // Common issue: extra slashes or special characters cause silent failures\n      if (!path.startsWith('indexeddb://')) {\n        throw new Error(`Invalid path format. Expected 'indexeddb://...', got: ${path}`);\n      }\n      \n      const cleanPath = path.replace('indexeddb://', '');\n      \n      // Validate clean path - TensorFlow.js object store names have restrictions\n      // They cannot contain certain characters and should be simple identifiers\n      if (cleanPath.includes('/') || cleanPath.includes('\\\\') || cleanPath.includes(' ')) {\n        throw new Error(`Invalid model name. Object store names cannot contain slashes or spaces. Got: ${cleanPath}`);\n      }\n      \n      if (cleanPath.length === 0) {\n        throw new Error('Invalid model name. Model name cannot be empty.');\n      }\n      \n      \n      // Check browser IndexedDB support and permissions\n      if (typeof indexedDB === 'undefined') {\n        throw new Error('IndexedDB is not available in this browser. Cannot save model.');\n      }\n      \n      // Check if we're in a context where IndexedDB might be restricted\n      // (e.g., Safari private browsing, iframe without permissions)\n      try {\n        const testDbName = '__tfjs_test_db__';\n        const testRequest = indexedDB.open(testDbName);\n        await new Promise<void>((resolve, reject) => {\n          testRequest.onsuccess = () => {\n            testRequest.result.close();\n            indexedDB.deleteDatabase(testDbName);\n            resolve();\n          };\n          testRequest.onerror = () => reject(new Error('IndexedDB open failed - may be restricted'));\n          testRequest.onblocked = () => reject(new Error('IndexedDB is blocked - may need user interaction'));\n        });\n      } catch (testError) {\n        const error = testError instanceof Error ? testError : new Error(String(testError));\n        console.warn('DQNAgent: IndexedDB access test failed:', error.message);\n        throw new Error(`IndexedDB access restricted: ${error.message}. This may be due to browser privacy settings, private browsing mode, or iframe permissions.`);\n      }\n      \n      // Save the model - TensorFlow.js will create the object store automatically\n      // Note: TensorFlow.js save() returns a ModelArtifactsInfo object with modelTopology and weightData\n      let saveResult: any = null;\n      \n      \n      try {\n        // Check model state before saving\n        const weights = this.qNetwork.getWeights();\n        \n        // Try saving - TensorFlow.js should create the object store\n        // Note: model.save() should work for LayersModel, but let's verify it's actually saving\n        // CRITICAL: TensorFlow.js save() can fail silently if:\n        // 1. Model isn't compiled (we check this above)\n        // 2. Path format is wrong (we validate this above)\n        // 3. IndexedDB permissions are restricted (browser issue)\n        // 4. Model hasn't been trained (weights are still initial values)\n        \n        // Verify model is in a saveable state\n        if (!this.qNetwork.optimizer) {\n          throw new Error('Model is not compiled. Cannot save uncompiled model.');\n        }\n        \n        // Check if model has been trained (weights updated from initial values)\n        // TensorFlow.js may have issues saving models that haven't been trained\n        // We check stepCount to see if training has occurred\n        if (this.stepCount === 0) {\n          console.warn('DQNAgent: WARNING - Model has not been trained yet (stepCount = 0). Saving anyway, but this may cause issues.');\n        }\n        \n        // Try saving - wrap in additional error handling\n        try {\n          saveResult = await this.qNetwork.save(path);\n        } catch (saveError) {\n          // Re-throw with more context\n          const error = saveError instanceof Error ? saveError : new Error(String(saveError));\n          console.error('DQNAgent: TensorFlow.js save() threw an error:', error);\n          console.error('DQNAgent: Error details:', {\n            message: error.message,\n            stack: error.stack,\n            path: path,\n            modelCompiled: !!this.qNetwork.optimizer,\n          });\n          throw new Error(`TensorFlow.js save() failed: ${error.message}`);\n        }\n        \n        // Wait a brief moment for IndexedDB transaction to commit\n        // IndexedDB operations are asynchronous and may need time to complete\n        await new Promise(resolve => setTimeout(resolve, 200));\n        \n        // Check what databases exist after saving\n        if (indexedDB.databases) {\n          try {\n            const databasesAfter = await indexedDB.databases();\n            \n            // Look for TensorFlow.js database\n            const tfDb = databasesAfter.find(db => db.name === 'tensorflowjs_models' || (db.name && db.name.includes('tensorflow')));\n            if (tfDb && tfDb.name) {\n              // Try to inspect the database\n              const inspectRequest = indexedDB.open(tfDb.name);\n              inspectRequest.onsuccess = () => {\n                const db = inspectRequest.result;\n                db.close();\n              };\n              inspectRequest.onerror = () => {\n                console.warn('DQNAgent: Could not inspect TensorFlow.js database');\n              };\n            } else {\n              console.warn('DQNAgent: WARNING - No TensorFlow.js database found after save!');\n            }\n          } catch (dbError) {\n            console.warn('DQNAgent: Could not list databases:', dbError);\n          }\n        }\n        \n        // Check if TensorFlow.js can list the model\n        // TensorFlow.js provides tf.io.listModels() to enumerate saved models\n        try {\n          const savedModels = await tf.io.listModels();\n          const modelKeys = Object.keys(savedModels);\n          \n          // Check if our model is in the list\n          const cleanPath = path.replace('indexeddb://', '');\n          const modelInList = modelKeys.some(key => key.includes(cleanPath) || key === path || key.endsWith(cleanPath));\n          \n          if (!modelInList) {\n            console.warn('DQNAgent: WARNING - Model not found in TensorFlow.js list, but save() completed');\n            console.warn('DQNAgent: Expected path:', path);\n            console.warn('DQNAgent: Clean path:', cleanPath);\n          }\n        } catch (listError) {\n          console.warn('DQNAgent: Could not list models (this is okay):', listError);\n        }\n        \n        // Immediately try to load the model to verify it was saved\n        // This is a common pattern to catch silent failures\n        try {\n          const testLoad = await tf.loadLayersModel(path);\n          // Dispose the test load - we don't need it\n          testLoad.dispose();\n        } catch (loadError) {\n          const error = loadError instanceof Error ? loadError : new Error(String(loadError));\n          console.error('DQNAgent: CRITICAL - Model save() completed but cannot be loaded!');\n          console.error('DQNAgent: Load error:', error.message);\n          console.error('DQNAgent: Load error stack:', error.stack);\n          \n          // Try to get more information about what TensorFlow.js sees\n          try {\n            const savedModels = await tf.io.listModels();\n            console.error('DQNAgent: Available models according to TensorFlow.js:', Object.keys(savedModels));\n          } catch (e) {\n            console.error('DQNAgent: Could not list models:', e);\n          }\n          \n          throw new Error(`Model save() completed but verification load failed: ${error.message}. This indicates the model was not actually saved to IndexedDB.`);\n        }\n        \n        if (!saveResult) {\n          console.warn('DQNAgent: WARNING - save() returned null/undefined');\n        }\n        \n        // After saving, check what databases exist now and debug what was created\n        if (typeof indexedDB.databases === 'function') {\n          // Debug: List all databases and their object stores\n          const { debugListAllIndexedDBDatabases } = await import('./rl-model-storage');\n          await debugListAllIndexedDBDatabases();\n        }\n      } catch (saveErr) {\n        const saveError = saveErr instanceof Error ? saveErr : new Error(String(saveErr));\n        console.error('DQNAgent: Error during model.save():', saveError);\n        console.error('DQNAgent: Error message:', saveError.message);\n        console.error('DQNAgent: Error stack:', saveError.stack);\n        throw saveError;\n      }\n      \n      // Wait longer for IndexedDB to sync (TensorFlow.js might be async)\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      // Verify the model was actually saved\n      const { modelExists, listAvailableModelPaths } = await import('./rl-model-storage');\n      \n      // First, check what's actually in the database\n      await listAvailableModelPaths();\n      \n      // Try verification with retries (IndexedDB can be slow to sync)\n      let exists = false;\n      let retries = 0;\n      while (!exists && retries < 5) {\n        exists = await modelExists(path);\n        if (!exists && retries < 4) {\n          // Re-check available paths in case they changed\n          await listAvailableModelPaths();\n          await new Promise(resolve => setTimeout(resolve, 500));\n        }\n        retries++;\n      }\n      \n      if (!exists) {\n        // Final check of what's available\n        const finalPaths = await listAvailableModelPaths();\n        const errorMsg = `Model save() completed but weights were NOT saved to IndexedDB.\\n` +\n          `Expected path: ${path}\\n` +\n          `Clean path: ${cleanPath}\\n` +\n          `Available paths: ${finalPaths.join(', ') || 'none'}\\n` +\n          `This suggests TensorFlow.js save() failed silently or used a different path format.`;\n        console.error('DQNAgent: CRITICAL ERROR:', errorMsg);\n        throw new Error(errorMsg);\n      }\n    } catch (error) {\n      console.error('DQNAgent: Error saving model:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load model\n   */\n  async load(path: string): Promise<void> {\n    if (typeof window === 'undefined') {\n      throw new Error('Cannot load model: IndexedDB is only available in the browser (not during SSR)');\n    }\n    \n    // Wait for any in-progress training to complete before loading new model\n    if (this.trainingInProgress) {\n      await this.trainingInProgress.catch(() => {\n        // Ignore errors from previous training\n      });\n    }\n    \n    // Verify model exists before attempting to load\n    // Note: Dexie stores metadata, but TensorFlow.js stores the actual model weights in IndexedDB\n    const { modelExists, listAvailableModelPaths, listSavedModels } = await import('./rl-model-storage');\n    \n    // First check if model exists in TensorFlow.js IndexedDB (where the weights are stored)\n    const exists = await modelExists(path);\n    \n    if (!exists) {\n      // Check if model exists in Dexie metadata (to provide better error message)\n      const savedModels = await listSavedModels();\n      const modelInMetadata = savedModels.find(m => m.path === path);\n      \n      const availablePaths = await listAvailableModelPaths();\n      const cleanPath = path.replace('indexeddb://', '');\n      \n      let errorMessage = `Cannot find model weights for '${path}'.\\n\\n`;\n      errorMessage += `Note: Model metadata is stored in Dexie DB, but the actual model weights are stored in TensorFlow.js IndexedDB.\\n\\n`;\n      \n      if (modelInMetadata) {\n        errorMessage += ` Model metadata exists in Dexie, but the model weights are missing from TensorFlow.js IndexedDB.\\n`;\n        errorMessage += `This can happen if:\\n`;\n        errorMessage += ` The model was deleted from IndexedDB but metadata remains\\n`;\n        errorMessage += ` Browser storage was cleared for IndexedDB but not Dexie\\n`;\n        errorMessage += ` There was an error during model save\\n\\n`;\n      }\n      \n      errorMessage += `Looking for TensorFlow.js object store: '${cleanPath}'\\n\\n`;\n      \n      if (availablePaths.length > 0) {\n        errorMessage += `Available models in TensorFlow.js IndexedDB:\\n`;\n        availablePaths.forEach(p => {\n          errorMessage += `  - ${p}\\n`;\n        });\n      } else {\n        errorMessage += `No models found in TensorFlow.js IndexedDB. Make sure you've saved a model first.`;\n      }\n      \n      throw new Error(errorMessage);\n    }\n    \n    try {\n    const newQNetwork = await tf.loadLayersModel(path);\n    \n    // CRITICAL: Models loaded from IndexedDB are NOT compiled.\n    // TensorFlow.js requires models to be compiled before they can be saved.\n    // Compile the loaded model with the same optimizer and loss function.\n    newQNetwork.compile({\n      optimizer: tf.train.adam(this.config.learningRate),\n      loss: 'meanSquaredError',\n    });\n    \n    const newTargetNetwork = this.createNetwork();\n    \n    // Dispose old networks only after new ones are loaded\n    if (this.qNetwork) {\n      this.qNetwork.dispose();\n    }\n    if (this.targetNetwork) {\n      this.targetNetwork.dispose();\n    }\n    \n    this.qNetwork = newQNetwork;\n    this.targetNetwork = newTargetNetwork;\n    this.updateTargetNetwork();\n    } catch (error) {\n      console.error('DQNAgent: Error loading model:', error);\n      \n      // Check for Safari/IndexedDB specific issues\n      const isSafari = typeof window !== 'undefined' && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      \n      let detailedError = `Failed to load model from ${path}: ${errorMessage}`;\n      \n      if (isSafari) {\n        detailedError += '\\n\\nSafari detected. Common issues:\\n';\n        detailedError += ' Private Browsing mode disables IndexedDB - try regular browsing mode\\n';\n        detailedError += ' Safari may require user interaction before accessing IndexedDB\\n';\n        detailedError += ' Check Safari settings: Preferences > Privacy > uncheck \"Prevent cross-site tracking\"';\n      }\n      \n      throw new Error(detailedError);\n    }\n  }\n\n  /**\n   * Load model weights from Supabase JSON format\n   * @param weightsData Array of layer weights in Supabase format: [{weights: number[], biases: number[]}, ...]\n   */\n  async loadWeightsFromJSON(weightsData: Array<{ weights: number[]; biases: number[] }>): Promise<void> {\n    if (typeof window === 'undefined') {\n      throw new Error('Cannot load weights: Only available in browser');\n    }\n\n    // Wait for any in-progress training to complete\n    if (this.trainingInProgress) {\n      await this.trainingInProgress.catch(() => {\n        // Ignore errors from previous training\n      });\n    }\n\n    // Ensure networks are initialized\n    if (!this.qNetwork || !this.targetNetwork) {\n      await this.initialize();\n    }\n\n    if (!this.qNetwork || !this.targetNetwork) {\n      throw new Error('Failed to initialize networks');\n    }\n\n    try {\n      // Convert JSON weights to TensorFlow.js weight format\n      // TensorFlow.js expects: [kernel, bias] for each layer\n      const tfWeights: tf.Tensor[] = [];\n      \n      for (const layer of weightsData) {\n        // Get layer shape from existing network\n        const layerIndex = tfWeights.length / 2; // Each layer has 2 tensors (kernel, bias)\n        const layerConfig = this.qNetwork.layers[layerIndex];\n        \n        if (!layerConfig) {\n          throw new Error(`Layer ${layerIndex} not found in network`);\n        }\n\n        // Get expected shape from layer\n        const kernelShape = layerConfig.getWeights()[0].shape;\n        const biasShape = layerConfig.getWeights()[1].shape;\n\n        // Reshape weights array to match layer shape\n        // Weights are stored as flat array: [inputSize * outputSize]\n        const kernel = tf.tensor2d(\n          layer.weights,\n          kernelShape as [number, number]\n        );\n\n        // Biases are stored as flat array: [outputSize]\n        const bias = tf.tensor1d(layer.biases);\n\n        tfWeights.push(kernel, bias);\n      }\n\n      // Set weights on both networks\n      this.qNetwork.setWeights(tfWeights);\n      this.targetNetwork.setWeights(tfWeights);\n      this.updateTargetNetwork();\n\n      // Dispose temporary tensors\n      tfWeights.forEach(t => t.dispose());\n    } catch (error) {\n      console.error('DQNAgent: Error loading weights from JSON:', error);\n      throw new Error(`Failed to load weights from JSON: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  /**\n   * Dispose resources\n   */\n  dispose(): void {\n    this.isDisposed = true;\n    \n    // Wait for any in-progress training to complete before disposing\n    const disposeNetworks = () => {\n      if (this.qNetwork) {\n        this.qNetwork.dispose();\n      }\n      if (this.targetNetwork) {\n        this.targetNetwork.dispose();\n      }\n    };\n\n    if (this.trainingInProgress) {\n      this.trainingInProgress\n        .then(disposeNetworks)\n        .catch(disposeNetworks); // Dispose even if training fails\n    } else {\n      disposeNetworks();\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5138, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/rl-replay-buffer.ts"],"sourcesContent":["/**\n * Step Replay Buffer\n * \n * Stores steps for training the DQN agent.\n * Uses a circular buffer to maintain a fixed-size memory.\n */\n\nimport type { Step } from './rl-dqn-model';\n\nexport class ReplayBuffer {\n  private buffer: Step[] = [];\n  private maxSize: number;\n  private currentIndex: number = 0;\n\n  constructor(maxSize: number = 10000) {\n    this.maxSize = maxSize;\n  }\n\n  /**\n   * Add step to buffer\n   */\n  add(step: Step): void {\n    if (this.buffer.length < this.maxSize) {\n      this.buffer.push(step);\n    } else {\n      // Overwrite oldest step (circular buffer)\n      this.buffer[this.currentIndex] = step;\n      this.currentIndex = (this.currentIndex + 1) % this.maxSize;\n    }\n  }\n\n  /**\n   * Add multiple steps\n   */\n  addBatch(steps: Step[]): void {\n    for (const step of steps) {\n      this.add(step);\n    }\n  }\n\n  /**\n   * Sample a batch of steps\n   */\n  sample(batchSize: number): Step[] {\n    if (this.buffer.length < batchSize) {\n      // Return all steps if buffer is smaller than batch size\n      return [...this.buffer];\n    }\n\n    // Random sampling\n    const indices: number[] = [];\n    const sampled: Step[] = [];\n\n    while (indices.length < batchSize) {\n      const index = Math.floor(Math.random() * this.buffer.length);\n      if (!indices.includes(index)) {\n        indices.push(index);\n        sampled.push(this.buffer[index]);\n      }\n    }\n\n    return sampled;\n  }\n\n  /**\n   * Get current buffer size\n   */\n  size(): number {\n    return this.buffer.length;\n  }\n\n  /**\n   * Check if buffer has enough samples for training\n   */\n  canSample(batchSize: number): boolean {\n    return this.buffer.length >= batchSize;\n  }\n\n  /**\n   * Clear buffer\n   */\n  clear(): void {\n    this.buffer = [];\n    this.currentIndex = 0;\n  }\n\n  /**\n   * Get all steps (for debugging)\n   */\n  getAll(): Step[] {\n    return [...this.buffer];\n  }\n}\n\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAIM,MAAM;IACH,SAAiB,EAAE,CAAC;IACpB,QAAgB;IAChB,eAAuB,EAAE;IAEjC,YAAY,UAAkB,KAAK,CAAE;QACnC,IAAI,CAAC,OAAO,GAAG;IACjB;IAEA;;GAEC,GACD,IAAI,IAAU,EAAQ;QACpB,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,EAAE;YACrC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;QACnB,OAAO;YACL,0CAA0C;YAC1C,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG;YACjC,IAAI,CAAC,YAAY,GAAG,CAAC,IAAI,CAAC,YAAY,GAAG,CAAC,IAAI,IAAI,CAAC,OAAO;QAC5D;IACF;IAEA;;GAEC,GACD,SAAS,KAAa,EAAQ;QAC5B,KAAK,MAAM,QAAQ,MAAO;YACxB,IAAI,CAAC,GAAG,CAAC;QACX;IACF;IAEA;;GAEC,GACD,OAAO,SAAiB,EAAU;QAChC,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,WAAW;YAClC,wDAAwD;YACxD,OAAO;mBAAI,IAAI,CAAC,MAAM;aAAC;QACzB;QAEA,kBAAkB;QAClB,MAAM,UAAoB,EAAE;QAC5B,MAAM,UAAkB,EAAE;QAE1B,MAAO,QAAQ,MAAM,GAAG,UAAW;YACjC,MAAM,QAAQ,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,IAAI,CAAC,MAAM,CAAC,MAAM;YAC3D,IAAI,CAAC,QAAQ,QAAQ,CAAC,QAAQ;gBAC5B,QAAQ,IAAI,CAAC;gBACb,QAAQ,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM;YACjC;QACF;QAEA,OAAO;IACT;IAEA;;GAEC,GACD,OAAe;QACb,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM;IAC3B;IAEA;;GAEC,GACD,UAAU,SAAiB,EAAW;QACpC,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI;IAC/B;IAEA;;GAEC,GACD,QAAc;QACZ,IAAI,CAAC,MAAM,GAAG,EAAE;QAChB,IAAI,CAAC,YAAY,GAAG;IACtB;IAEA;;GAEC,GACD,SAAiB;QACf,OAAO;eAAI,IAAI,CAAC,MAAM;SAAC;IACzB;AACF"}},
    {"offset": {"line": 5221, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/rl-model-storage.ts"],"sourcesContent":["/**\n * Model Storage Utilities\n * \n * Functions to list, save, and load models using Dexie for metadata\n * and TensorFlow.js IndexedDB for actual model storage.\n * \n * This module provides a clean interface for managing TensorFlow.js models\n * stored in IndexedDB. It uses Dexie to track model metadata independently\n * of TensorFlow.js's internal storage.\n */\n\nimport Dexie, { type Table } from 'dexie';\nimport * as tf from '@tensorflow/tfjs';\n\nexport interface SavedModel {\n  name: string;\n  path: string;\n  createdAt: number;\n  createdAtString: string;\n  evalScore?: number; // Average reward at time of save\n}\n\ninterface ModelMetadata {\n  id?: number;\n  path: string;\n  name: string;\n  createdAt: number;\n  createdAtString: string;\n  evalScore?: number;\n}\n\nclass ModelDatabase extends Dexie {\n  modelMetadata!: Table<ModelMetadata>;\n\n  constructor() {\n    super('tank_ai_models');\n    this.version(1).stores({\n      modelMetadata: '++id, path, createdAt, evalScore',\n    });\n  }\n}\n\n// Initialize database with error handling for Safari compatibility and SSR safety\n// IMPORTANT: This module may be imported during SSR, so we must guard all browser API access\nlet db: ModelDatabase | null = null;\n\n/**\n * Get or initialize the Dexie database instance\n * This function ensures the database is only created in the browser (not during SSR)\n */\nfunction getDatabase(): ModelDatabase | null {\n  // Return existing instance if already initialized\n  if (db !== null) {\n    return db;\n  }\n  \n  // Only initialize in browser environment (not during SSR)\n  if (typeof window === 'undefined') {\n    return null;\n  }\n  \n  try {\n    // Check if IndexedDB is available before creating Dexie instance\n    if (typeof window.indexedDB !== 'undefined') {\n      db = new ModelDatabase();\n      return db;\n    } else {\n      console.warn('IndexedDB not available in this browser');\n      return null;\n    }\n  } catch (error) {\n    // Safari private browsing or other IndexedDB restrictions\n    console.warn('Failed to initialize Dexie database:', error);\n    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    if (isSafari) {\n      console.warn('Safari detected. IndexedDB may be disabled (e.g., Private Browsing mode)');\n    }\n    return null;\n  }\n}\nconst MODEL_NAME_PREFIX = 'tank-ai-';\nconst MAX_MODELS = 8;\n\n/**\n * Check if IndexedDB is available (basic check)\n */\nfunction isIndexedDBAvailable(): boolean {\n  if (typeof window === 'undefined') {\n    return false;\n  }\n  return typeof window.indexedDB !== 'undefined';\n}\n\n/**\n * Get a user-friendly error message for IndexedDB issues\n */\nfunction getIndexedDBErrorMessage(): string {\n  if (typeof window === 'undefined') {\n    return 'IndexedDB is not available (server-side rendering)';\n  }\n  \n  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  \n  if (isSafari) {\n    return 'Safari detected. IndexedDB may be unavailable due to:\\n' +\n           ' Private Browsing mode (disables IndexedDB)\\n' +\n           ' Safari privacy settings blocking storage\\n' +\n           ' Try: Safari > Preferences > Privacy > uncheck \"Prevent cross-site tracking\"\\n' +\n           ' Or use regular browsing mode instead of Private Browsing';\n  }\n  \n  return 'IndexedDB is not available. This may be due to:\\n' +\n         ' Private/Incognito browsing mode\\n' +\n         ' Browser privacy settings blocking storage\\n' +\n         ' Browser does not support IndexedDB';\n}\n\n/**\n * Format date as \"December 3, 2:49 pm\"\n */\nfunction formatDateString(timestamp: number): string {\n  const date = new Date(timestamp);\n  const formatted = date.toLocaleString('en-US', {\n    month: 'long',\n    day: 'numeric',\n    hour: 'numeric',\n    minute: '2-digit',\n    hour12: true,\n  });\n  // Convert AM/PM to lowercase\n  return formatted.replace(/\\s(AM|PM)$/, (match) => match.toLowerCase());\n}\n\n/**\n * Save model metadata to Dexie\n */\nasync function saveMetadata(\n  path: string,\n  name: string,\n  createdAt: number,\n  evalScore?: number\n): Promise<void> {\n  const db = getDatabase();\n  if (!db) {\n    const errorMsg = getIndexedDBErrorMessage();\n    console.warn('Dexie not available:', errorMsg);\n    return;\n  }\n  \n  // Check if IndexedDB is actually available\n  if (!isIndexedDBAvailable()) {\n    const errorMsg = getIndexedDBErrorMessage();\n    throw new Error(`Cannot save model metadata: ${errorMsg}`);\n  }\n\n  try {\n    const metadata = {\n      path,\n      name,\n      createdAt,\n      createdAtString: formatDateString(createdAt),\n      evalScore,\n    };\n    await db.modelMetadata.put(metadata);\n  } catch (error) {\n    console.error('Failed to save model metadata:', error);\n    // Re-throw so we know if metadata save fails\n    throw error;\n  }\n}\n\n/**\n * Get metadata for a model\n */\nasync function getMetadata(path: string): Promise<SavedModel | null> {\n  const db = getDatabase();\n  if (!db) {\n    return null;\n  }\n\n  try {\n    const metadata = await db.modelMetadata.get({ path });\n    if (metadata) {\n      return {\n        name: metadata.name,\n        path: metadata.path,\n        createdAt: metadata.createdAt,\n        createdAtString: metadata.createdAtString,\n        evalScore: metadata.evalScore,\n      };\n    }\n    return null;\n  } catch (error) {\n    console.warn('Failed to get model metadata:', error);\n    return null;\n  }\n}\n\n/**\n * Delete metadata for a model\n */\nasync function deleteMetadata(path: string): Promise<void> {\n  const db = getDatabase();\n  if (!db) {\n    return;\n  }\n\n  try {\n    await db.modelMetadata.delete(path);\n  } catch (error) {\n    console.warn('Failed to delete model metadata:', error);\n    // Don't throw - metadata deletion is optional\n  }\n}\n\n/**\n * Check if a TensorFlow.js model exists in IndexedDB\n * \n * IMPORTANT: Uses TensorFlow.js's official API (tf.io.listModels()) instead of\n * manually inspecting IndexedDB. This ensures we're checking models the way\n * TensorFlow.js expects them to be stored.\n */\nexport async function modelExists(modelPath: string): Promise<boolean> {\n  if (typeof window === 'undefined') {\n    return false;\n  }\n\n  try {\n    // Use TensorFlow.js's official API to check if model exists\n    const savedModels = await tf.io.listModels();\n    const modelKeys = Object.keys(savedModels);\n    \n    const exists = modelKeys.includes(modelPath);\n    \n    if (!exists) {\n    }\n    \n    return exists;\n  } catch (error) {\n    console.warn(`[modelExists] Error checking model existence with TensorFlow.js API:`, error);\n    // Fallback to manual IndexedDB inspection if TensorFlow.js API fails\n    return await modelExistsFallback(modelPath);\n  }\n}\n\n/**\n * Fallback method: manually inspect IndexedDB\n * Only used if TensorFlow.js API is unavailable\n */\nasync function modelExistsFallback(modelPath: string): Promise<boolean> {\n  if (typeof window === 'undefined' || typeof indexedDB === 'undefined') {\n    return false;\n  }\n\n  const cleanPath = modelPath.replace('indexeddb://', '');\n  const dbName = 'tensorflowjs_models';\n  \n  return new Promise((resolve) => {\n    const request = indexedDB.open(dbName);\n    \n    request.onsuccess = () => {\n      const db = request.result;\n      \n      // Check if object store exists\n      if (!db.objectStoreNames.contains(cleanPath)) {\n        db.close();\n        resolve(false);\n        return;\n      }\n      \n      // Check if the object store has any data\n      try {\n        const transaction = db.transaction([cleanPath], 'readonly');\n        const store = transaction.objectStore(cleanPath);\n        const countRequest = store.count();\n        \n        countRequest.onsuccess = () => {\n          const hasData = countRequest.result > 0;\n          db.close();\n          resolve(hasData);\n        };\n        \n        countRequest.onerror = (e) => {\n          console.warn(`[modelExistsFallback] Error counting entries in '${cleanPath}':`, e);\n          db.close();\n          resolve(false);\n        };\n        \n        transaction.onerror = (e) => {\n          console.warn(`[modelExistsFallback] Transaction error for '${cleanPath}':`, e);\n          db.close();\n          resolve(false);\n        };\n      } catch (e) {\n        console.warn(`[modelExistsFallback] Exception checking model existence for '${cleanPath}':`, e);\n        db.close();\n        resolve(false);\n      }\n    };\n    \n    request.onerror = (e) => {\n      console.warn(`[modelExistsFallback] Error opening database '${dbName}':`, e);\n      resolve(false);\n    };\n    \n    request.onupgradeneeded = () => {\n      // Database doesn't exist yet or needs upgrade\n      resolve(false);\n    };\n  });\n}\n\n/**\n * List all available model paths in TensorFlow.js database\n * \n * IMPORTANT: Uses TensorFlow.js's official API (tf.io.listModels()) instead of\n * manually inspecting IndexedDB. TensorFlow.js may store models in a different\n * structure than we expect, so we should use their API.\n */\nexport async function listAvailableModelPaths(): Promise<string[]> {\n  if (typeof window === 'undefined') {\n    return [];\n  }\n\n  try {\n    // Use TensorFlow.js's official API to list models\n    // This is the correct way to get all saved models\n    const savedModels = await tf.io.listModels();\n    const modelKeys = Object.keys(savedModels);\n    \n    \n    // Filter to only IndexedDB models that match our naming pattern\n    const indexedDbModels = modelKeys.filter(key => \n      key.startsWith('indexeddb://') && key.includes(MODEL_NAME_PREFIX)\n    );\n    \n    \n    return indexedDbModels;\n  } catch (error) {\n    console.warn(`[listAvailableModelPaths] Error listing models with TensorFlow.js API:`, error);\n    // Fallback to manual IndexedDB inspection if TensorFlow.js API fails\n    return await listAvailableModelPathsFallback();\n  }\n}\n\n/**\n * Fallback method: manually inspect IndexedDB\n * Only used if TensorFlow.js API is unavailable\n */\nasync function listAvailableModelPathsFallback(): Promise<string[]> {\n  if (typeof window === 'undefined' || typeof indexedDB === 'undefined') {\n    return [];\n  }\n\n  const dbName = 'tensorflowjs_models';\n  \n  return new Promise((resolve) => {\n    const request = indexedDB.open(dbName);\n    \n    request.onsuccess = () => {\n      const db = request.result;\n      const objectStoreNames = Array.from(db.objectStoreNames);\n      \n      const modelPaths = objectStoreNames\n        .filter(name => name.startsWith(MODEL_NAME_PREFIX))\n        .map(name => `indexeddb://${name}`);\n      \n      // Also log all object stores (not just ones starting with MODEL_NAME_PREFIX)\n      if (objectStoreNames.length > 0) {\n      } else {\n      }\n      \n      db.close();\n      resolve(modelPaths);\n    };\n    \n    request.onerror = (e) => {\n      console.warn(`[listAvailableModelPathsFallback] Error opening database '${dbName}':`, e);\n      resolve([]);\n    };\n    \n    request.onupgradeneeded = () => {\n      resolve([]);\n    };\n  });\n}\n\n/**\n * Debug function to list ALL IndexedDB databases and their object stores\n * Useful for understanding what TensorFlow.js actually creates\n */\nexport async function debugListAllIndexedDBDatabases(): Promise<void> {\n  if (typeof window === 'undefined' || typeof indexedDB === 'undefined') {\n    return;\n  }\n  \n  \n  if (indexedDB.databases) {\n    try {\n      const databases = await indexedDB.databases();\n      \n      // Open each database and list object stores\n      for (const dbInfo of databases) {\n        if (!dbInfo.name) continue;\n        try {\n          const request = indexedDB.open(dbInfo.name);\n          request.onsuccess = () => {\n            const db = request.result;\n            const objectStores = Array.from(db.objectStoreNames);\n            db.close();\n          };\n          request.onerror = () => {\n            console.warn(`[debugListAllIndexedDBDatabases] Could not open database '${dbInfo.name}'`);\n          };\n        } catch (e) {\n          console.warn(`[debugListAllIndexedDBDatabases] Error inspecting database '${dbInfo.name}':`, e);\n        }\n      }\n    } catch (e) {\n      console.warn('[debugListAllIndexedDBDatabases] Error getting database list:', e);\n    }\n  } else {\n    console.warn('[debugListAllIndexedDBDatabases] indexedDB.databases() not available in this browser');\n  }\n}\n\n/**\n * List all saved models from Dexie metadata\n */\nexport async function listSavedModels(): Promise<SavedModel[]> {\n  const db = getDatabase();\n  if (!db) {\n    console.warn('Dexie not available (likely SSR or browser not supported)');\n    return [];\n  }\n  \n  try {\n    // Get all metadata from Dexie, sorted by creation date (newest first)\n    // db is guaranteed to be non-null here because we checked above\n    const allModels = await db!.modelMetadata\n      .orderBy('createdAt')\n      .reverse()\n      .toArray();\n    \n    // Filter to only include models that actually exist in TensorFlow.js IndexedDB\n    // This filters out orphaned metadata entries (metadata without corresponding model weights)\n    const validModels: SavedModel[] = [];\n    const orphanedModels: string[] = [];\n    \n    for (const m of allModels) {\n      const exists = await modelExists(m.path);\n      if (exists) {\n        validModels.push({\n          name: m.name,\n          path: m.path,\n          createdAt: m.createdAt,\n          createdAtString: m.createdAtString,\n          evalScore: m.evalScore,\n        });\n      } else {\n        // Model metadata exists but weights are missing - will be cleaned up below\n        orphanedModels.push(m.path);\n      }\n    }\n    \n    \n    // Clean up orphaned metadata entries (models with metadata but no weights)\n    // This can happen if IndexedDB was cleared but Dexie metadata remained, or if a save failed\n    if (orphanedModels.length > 0) {\n      for (const orphanedPath of orphanedModels) {\n        try {\n          await deleteMetadata(orphanedPath);\n        } catch (error) {\n          // Silently handle cleanup errors - not critical\n        }\n      }\n    }\n    \n    return validModels;\n  } catch (error) {\n    console.error('Error listing models:', error);\n    return [];\n  }\n}\n\n/**\n * Delete a model from both TensorFlow.js IndexedDB and Dexie metadata\n * \n * This function deletes both the TensorFlow.js model data and our metadata.\n */\nexport async function deleteModel(modelPath: string): Promise<void> {\n  if (typeof window === 'undefined' || typeof indexedDB === 'undefined') {\n    throw new Error('IndexedDB not available (likely SSR or browser not supported)');\n  }\n  \n  const cleanPath = modelPath.replace('indexeddb://', '');\n  \n  try {\n    // Delete from TensorFlow.js database\n    // TensorFlow.js stores models in object stores. We clear all data from the store.\n    const tfDbName = 'tensorflowjs_models';\n    await new Promise<void>((resolve, reject) => {\n      const request = indexedDB.open(tfDbName);\n      \n      request.onsuccess = () => {\n        const db = request.result;\n        \n        if (db.objectStoreNames.contains(cleanPath)) {\n          // Clear all data from the object store\n          const transaction = db.transaction([cleanPath], 'readwrite');\n          const store = transaction.objectStore(cleanPath);\n          const clearRequest = store.clear();\n          \n          clearRequest.onsuccess = () => {\n            db.close();\n            resolve();\n          };\n          \n          clearRequest.onerror = () => {\n            db.close();\n            reject(new Error('Failed to clear model data'));\n          };\n          \n          transaction.onerror = () => {\n            db.close();\n            reject(new Error('Transaction failed'));\n          };\n        } else {\n          db.close();\n          resolve(); // Model doesn't exist, consider it deleted\n        }\n      };\n      \n      request.onerror = () => {\n        reject(new Error('Failed to open TensorFlow.js database'));\n      };\n    });\n    \n    // Delete metadata from Dexie\n    await deleteMetadata(modelPath);\n    \n  } catch (error) {\n    console.error('Error deleting model:', error);\n    // Still try to delete metadata even if TensorFlow.js deletion failed\n    try {\n      await deleteMetadata(modelPath);\n    } catch (metaError) {\n      console.warn('Failed to delete metadata:', metaError);\n    }\n    throw error;\n  }\n}\n\n/**\n * Get model metadata\n */\nexport async function getModelMetadata(modelPath: string): Promise<SavedModel | null> {\n  // Get from Dexie metadata store\n  const metadata = await getMetadata(modelPath);\n  if (metadata) {\n    return metadata;\n  }\n  \n  // Fallback: extract from path (for backward compatibility)\n  const cleanPath = modelPath.replace('indexeddb://', '');\n  const timestampMatch = cleanPath.match(/tank-ai-(\\d{10,})$/);\n  \n  if (timestampMatch) {\n    const timestamp = parseInt(timestampMatch[1]);\n    return {\n      name: cleanPath,\n      path: modelPath,\n      createdAt: timestamp,\n      createdAtString: formatDateString(timestamp),\n    };\n  }\n  \n  return null;\n}\n\n/**\n * Helper function to save model with metadata\n * Call this after saving a model with TensorFlow.js\n * \n * This function:\n * - Creates a new model (doesn't update existing)\n * - Uses formatted date string for display\n * - Keeps max 8 models (deletes oldest if needed)\n */\nexport async function saveModelWithMetadata(\n  modelPath: string,\n  evalScore?: number,\n  displayName?: string\n): Promise<void> {\n  const db = getDatabase();\n  if (!db) {\n    console.warn('Dexie not available, cannot save metadata');\n    return;\n  }\n\n  const cleanPath = modelPath.replace('indexeddb://', '');\n  \n  // Extract timestamp from path or use current time\n  let timestamp = Date.now();\n  let name = displayName || cleanPath;\n  \n  // Try to extract timestamp from path\n  const timestampMatch = cleanPath.match(/tank-ai-(\\d{10,})$/);\n  if (timestampMatch) {\n    timestamp = parseInt(timestampMatch[1]);\n  }\n  \n  // Use ISO timestamp for display name if not provided\n  if (!displayName) {\n    const isoString = new Date(timestamp).toISOString();\n    name = isoString;\n  }\n  \n  // Save metadata\n  await saveMetadata(modelPath, name, timestamp, evalScore);\n  \n  // Keep only the most recent MAX_MODELS models\n  const allModels = await db!.modelMetadata\n    .orderBy('createdAt')\n    .reverse()\n    .toArray();\n  \n  if (allModels.length > MAX_MODELS) {\n    // Delete oldest models (keep the first MAX_MODELS)\n    const modelsToDelete = allModels.slice(MAX_MODELS);\n    for (const modelToDelete of modelsToDelete) {\n      try {\n        // Use the deleteModel function which properly deletes from both TensorFlow.js IndexedDB and Dexie\n        await deleteModel(modelToDelete.path);\n      } catch (error) {\n        console.warn(`Failed to delete old model ${modelToDelete.path}:`, error);\n      }\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5586, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/rl-training-manager.ts"],"sourcesContent":["/**\n * RL Training Manager\n * \n * Coordinates the training process, managing episodes, step collection,\n * and model updates. Integrates with the game to collect training data.\n */\n\nimport { DQNAgent, type DQNConfig, DEFAULT_DQN_CONFIG } from './rl-dqn-model';\nimport { ReplayBuffer } from './rl-replay-buffer';\nimport { TankTroubleRLEnv, type RLEnvironmentState } from './rl-environment';\nimport { rlModelManager, TensorFlowJSModel, type ExtendedRLModel } from './rl-model';\nimport { saveModelWithMetadata } from './rl-model-storage';\nimport type { AIContext, AIDecision } from './types';\nimport type { Observation } from './rl-observation';\nimport type { Step } from './rl-dqn-model';\nimport { MAX_EPISODE_TIME_MS } from '@/app/games/tank-trouble/constants/game-constants';\n\nexport interface TrainingStats {\n  episode: number;\n  episodeReward: number;\n  episodeLength: number;\n  totalReward: number;\n  averageReward: number;\n  epsilon: number;\n  loss: number;\n}\n\nexport interface TrainingConfig {\n  dqn: Partial<DQNConfig>;\n  episodes: number;\n  trainEvery: number; // Train every N steps\n  saveEvery: number; // Save model every N episodes\n  selfPlay: boolean;\n  // TODO: Implement headless mode later - this will allow faster training by skipping rendering\n  // When implemented, headless mode will run game logic without rendering UI for faster training\n  headless: boolean;\n  maxEpisodeTimeMs: number; // Maximum episode duration in milliseconds before timeout (default: MAX_EPISODE_TIME_MS = 60 seconds)\n  onEpisodeComplete?: (stats: TrainingStats) => void;\n  onTrainingUpdate?: (stats: Partial<TrainingStats>) => void;\n}\n\nexport class RLTrainingManager {\n  private agent: DQNAgent;\n  private replayBuffer: ReplayBuffer;\n  private env: TankTroubleRLEnv;\n  private config: TrainingConfig;\n  private stats: TrainingStats;\n  private isTraining: boolean = false;\n  private currentEpisode: number = 0;\n  private completedEpisodes: number = 0; // Track completed episodes separately for accurate average calculation\n  private stepCount: number = 0;\n  private hasTrainedAtLeastOnce: boolean = false; // Track if training has occurred at least once\n  // Per-game state tracking\n  private gameStates: Map<string, { observation?: Observation; lastAction?: number; reward?: number }> = new Map();\n  private activeGameEpisodes: Set<string> = new Set(); // Track which games have active episodes\n  private gameEpisodeRewards: Map<string, number> = new Map(); // Track episode reward per game\n  private gameEpisodeLengths: Map<string, number> = new Map(); // Track episode length per game\n\n  constructor(config: Partial<TrainingConfig> = {}) {\n    this.config = {\n      dqn: {},\n      episodes: 1000,\n      trainEvery: 4,\n      saveEvery: 100,\n      selfPlay: true,\n      // TODO: Implement headless mode later - this will allow faster training by skipping rendering\n      // When implemented, set headless: true by default, or use config.headless if provided\n      headless: false, // Currently always false - headless mode not yet implemented\n      maxEpisodeTimeMs: MAX_EPISODE_TIME_MS,\n      ...config,\n    };\n\n    this.agent = new DQNAgent({\n      ...DEFAULT_DQN_CONFIG,\n      ...this.config.dqn,\n    });\n\n    this.replayBuffer = new ReplayBuffer(\n      this.config.dqn.replayBufferSize || DEFAULT_DQN_CONFIG.replayBufferSize\n    );\n\n    this.env = new TankTroubleRLEnv(this.config.maxEpisodeTimeMs);\n\n    this.stats = {\n      episode: 0,\n      episodeReward: 0,\n      episodeLength: 0,\n      totalReward: 0,\n      averageReward: 0,\n      epsilon: 1.0,\n      loss: 0,\n    };\n  }\n\n  /**\n   * Initialize training (create networks, etc.)\n   */\n  async initialize(): Promise<void> {\n    await this.agent.initialize();\n    \n    // Set up model for game and connect agent to model manager\n    // This allows the game to use the trained model during training\n    const model = new TensorFlowJSModel({\n      name: 'TankTroubleRL',\n      type: 'discrete',\n      observationSize: DEFAULT_DQN_CONFIG.observationSize,\n      actionSize: DEFAULT_DQN_CONFIG.actionSize,\n    });\n    \n    // Connect agent to model interface for use in game\n    // This allows the game controller to use the trained model during training\n    // Note: RLModel.predict is synchronous, but agent.predict is async\n    // We use a synchronous wrapper that falls back to rule-based for game loop\n    // The actual RL predictions happen in training step (async)\n    const extendedModel: ExtendedRLModel = {\n      isLoaded: () => model.isLoaded(),\n      load: (path: string) => model.load(path),\n      getInfo: () => model.getInfo(),\n      agent: this.agent,\n      // Synchronous predict for game loop compatibility\n      // Actual RL predictions happen in training step\n      predict: (obs: Observation, angle: number): AIDecision => {\n        // For game loop, return rule-based decision\n        // RL predictions are handled separately in training step\n        // This is a design limitation - ideally controller would be async\n        return {\n          angleDelta: 0,\n          moveDirection: 0,\n          shouldShoot: false,\n        };\n      },\n    };\n    \n    // Set model in global model manager so game controller can use it during training\n    rlModelManager.setModel(extendedModel);\n  }\n\n  /**\n   * Run one training step\n   * \n   * This should be called from the game loop after each game tick.\n   * The decision parameter is the action that was actually taken.\n   * \n   * @param gameId - Unique identifier for the game instance (e.g., \"game-0\", \"game-1\")\n   *                 This allows tracking state per game while sharing the model\n   */\n  async step(context: AIContext, decision: AIDecision, actionTaken?: number, gameId?: string): Promise<void> {\n    if (!this.isTraining) {\n      return;\n    }\n\n    // Get current observation\n    const observation = this.env.getObservation(context);\n\n    // Use gameId to track state per game (default to \"default\" if not provided for backward compatibility)\n    const gameKey = gameId || 'default';\n    \n    // Get or initialize state for this specific game\n    let envState = this.gameStates.get(gameKey);\n    \n    // If this is the first step or state is invalid, reset environment for this game\n    if (!envState || !envState.observation) {\n      envState = this.env.reset(context);\n      this.gameStates.set(gameKey, envState);\n      // Mark this game as having an active episode\n      this.activeGameEpisodes.add(gameKey);\n      // Initialize episode reward and length for this game (reset from previous episode)\n      this.gameEpisodeRewards.set(gameKey, 0);\n      this.gameEpisodeLengths.set(gameKey, 0);\n      // Update shared stats to include this newly active game\n      this.updateSharedStats();\n      return;\n    }\n\n    // Use provided action or select new one\n    let action: number = 0; // Default to action 0 (no-op)\n    if (actionTaken !== undefined && actionTaken !== null) {\n      action = actionTaken;\n    } else {\n      // Select action using epsilon-greedy\n      action = await this.agent.selectAction(envState.observation, true);\n    }\n\n    // Execute action and get next state\n    const nextEnvState = this.env.step(action, context, decision);\n\n    // Ensure we have valid state before storing step\n    if (!envState || !envState.observation || !nextEnvState || !nextEnvState.observation) {\n      // Skip step collection if state is invalid, reset for this game\n      this.gameStates.set(gameKey, nextEnvState || this.env.reset(context));\n      return;\n    }\n\n    // Store step from previous state to current state\n    // All games contribute to the SAME shared replay buffer\n    const step: Step = {\n      state: envState.observation.vector,\n      action: action,\n      reward: nextEnvState.reward,\n      nextState: nextEnvState.observation.vector,\n      done: nextEnvState.done,\n    };\n\n    // Add to shared replay buffer (all games contribute here)\n    this.replayBuffer.add(step);\n    \n    // Track reward and length per game (for proper episode tracking)\n    const currentGameReward = this.gameEpisodeRewards.get(gameKey) || 0;\n    const currentGameLength = this.gameEpisodeLengths.get(gameKey) || 0;\n    this.gameEpisodeRewards.set(gameKey, currentGameReward + nextEnvState.reward);\n    this.gameEpisodeLengths.set(gameKey, currentGameLength + 1);\n    \n    // Update shared stats for display (sum of all active games)\n    this.updateSharedStats();\n    \n    // Debug: Log every 100 steps to verify accumulation\n    if (this.stats.episodeLength % 100 === 0) {\n    }\n\n    // Train periodically on shared model\n    // All games' steps are batched together for training\n    this.stepCount++;\n    if (this.stepCount % this.config.trainEvery === 0 && this.replayBuffer.canSample(32)) {\n      const batch = this.replayBuffer.sample(32); // Sample from ALL games' steps\n      const loss = await this.agent.train(batch); // Train shared model\n      this.stats.loss = loss;\n      \n      // Mark that training has occurred (even if loss is 0, training ran)\n      // This ensures we only save models that have actually been trained\n      this.hasTrainedAtLeastOnce = true;\n\n      if (this.config.onTrainingUpdate) {\n        this.config.onTrainingUpdate({\n          loss,\n          epsilon: this.agent.getEpsilon(),\n        });\n      }\n    }\n\n    // Check if episode is done for this specific game\n    if (nextEnvState.done) {\n      await this.onEpisodeComplete(nextEnvState, gameKey);\n      // Reset state for this game only (other games unaffected)\n      this.gameStates.delete(gameKey);\n      // Note: Don't remove from activeGameEpisodes here - it will be re-added when the game restarts\n      // This prevents the brief window where all games might be \"inactive\" causing premature reset\n      // Note: We also don't clear gameEpisodeRewards/gameEpisodeLengths here - they'll be reset\n      // when the game restarts and step() is called with a fresh state\n    } else {\n      // Update state for this specific game\n      this.gameStates.set(gameKey, nextEnvState);\n    }\n  }\n\n  /**\n   * Update shared stats from per-game rewards and lengths\n   * This sums all active game rewards/lengths for display\n   */\n  private updateSharedStats(): void {\n    let totalReward = 0;\n    let totalLength = 0;\n    \n    for (const [gameKey, reward] of this.gameEpisodeRewards.entries()) {\n      if (this.activeGameEpisodes.has(gameKey)) {\n        totalReward += reward;\n      }\n    }\n    \n    for (const [gameKey, length] of this.gameEpisodeLengths.entries()) {\n      if (this.activeGameEpisodes.has(gameKey)) {\n        totalLength += length;\n      }\n    }\n    \n    this.stats.episodeReward = totalReward;\n    this.stats.episodeLength = totalLength;\n  }\n\n  /**\n   * Increment episode count (called when a new game starts)\n   * This is shared across all 4 games running in parallel\n   * Each game that starts increments the shared counter by 1\n   * \n   * Note: The reward from the completed episode should have already been\n   * added to totalReward in onEpisodeComplete(). This just increments the counter.\n   */\n  incrementEpisode(): void {\n    // Increment episode count\n    this.currentEpisode++;\n    this.stats.episode = this.currentEpisode;\n    this.stats.epsilon = this.agent.getEpsilon();\n    \n    // Update average reward using completed episodes (not currentEpisode which includes in-progress games)\n    // This ensures averageReward reflects only completed games\n    if (this.completedEpisodes > 0) {\n      this.stats.averageReward = this.stats.totalReward / this.completedEpisodes;\n    }\n    \n    // Save model periodically\n    if (this.currentEpisode % this.config.saveEvery === 0) {\n      // Save asynchronously without blocking\n      const timestamp = Date.now();\n      const isoString = new Date(timestamp).toISOString();\n      const evalScore = this.stats.averageReward;\n      this.saveModel(`indexeddb://tank-ai-${timestamp}`, evalScore, isoString).catch((error) => {\n        console.error('Error saving model:', error);\n      });\n    }\n    \n    // Callback to notify listeners\n    if (this.config.onEpisodeComplete) {\n      this.config.onEpisodeComplete({ ...this.stats });\n    }\n  }\n\n  /**\n   * Handle episode completion (simplified - no longer increments episode count)\n   * Episode count is now incremented when a new game starts, not when it ends\n   * \n   * This method adds the completed game's reward to totalReward and cleans up\n   * per-game tracking. The episode counter is incremented separately when\n   * the new game starts.\n   */\n  private async onEpisodeComplete(finalState: RLEnvironmentState, gameKey: string): Promise<void> {\n    // Get the base game key (without \"-blue\" suffix) to combine both tanks' rewards\n    const isBlueTank = gameKey.includes('-blue');\n    const baseGameKey = isBlueTank ? gameKey.replace('-blue', '') : gameKey;\n    \n    // Get rewards from both tanks for this game (blue and red)\n    const redReward = this.gameEpisodeRewards.get(baseGameKey) || 0;\n    const blueReward = this.gameEpisodeRewards.get(`${baseGameKey}-blue`) || 0;\n    const totalGameReward = redReward + blueReward;\n    \n    // Get lengths from both tanks\n    const redLength = this.gameEpisodeLengths.get(baseGameKey) || 0;\n    const blueLength = this.gameEpisodeLengths.get(`${baseGameKey}-blue`) || 0;\n    const totalGameLength = redLength + blueLength;\n    \n    // Add this game's total reward to totalReward (only count once per game, not per tank)\n    // In AI vs AI mode, both tanks call this, but we only want to count once\n    if (!isBlueTank) {\n      this.stats.totalReward += totalGameReward;\n      this.completedEpisodes++;\n      \n      // Update average reward immediately when episode completes\n      // Use completedEpisodes for accurate average (not currentEpisode which includes in-progress games)\n      if (this.completedEpisodes > 0) {\n        this.stats.averageReward = this.stats.totalReward / this.completedEpisodes;\n      }\n    }\n    \n    // Clean up per-game tracking for this game when episode completes\n    // We'll reset these when the game restarts and step() is called with fresh state\n    // Note: We mark as inactive so it doesn't contribute to shared stats\n    this.activeGameEpisodes.delete(baseGameKey);\n    this.activeGameEpisodes.delete(`${baseGameKey}-blue`); // Also remove blue variant if it exists\n    \n    // Update shared stats (will exclude this completed game)\n    this.updateSharedStats();\n  }\n\n  /**\n   * Start training\n   */\n  start(): void {\n    if (!this.isTraining) {\n      this.isTraining = true;\n      this.currentEpisode = 0;\n      this.completedEpisodes = 0;\n      this.stepCount = 0;\n      // Reset episode stats when training starts\n      this.stats.episodeReward = 0;\n      this.stats.episodeLength = 0;\n      this.stats.totalReward = 0;\n      this.stats.averageReward = 0;\n      this.activeGameEpisodes.clear();\n      this.gameEpisodeRewards.clear();\n      this.gameEpisodeLengths.clear();\n    }\n  }\n\n  /**\n   * Stop training\n   */\n  stop(): void {\n    this.isTraining = false;\n  }\n\n  /**\n   * Check if training is active\n   */\n  getIsTraining(): boolean {\n    return this.isTraining;\n  }\n\n  /**\n   * Get current training statistics\n   */\n  getStats(): TrainingStats {\n    return { ...this.stats };\n  }\n\n  /**\n   * Check if model can be saved\n   * Requirements:\n   * 1. Replay buffer has enough steps (32+) for at least one training batch\n   * 2. At least one episode has completed (to have meaningful averageReward)\n   * 3. Training has actually occurred at least once (hasTrainedAtLeastOnce)\n   * \n   * Note: We require hasTrainedAtLeastOnce instead of loss > 0 because:\n   * - Loss might be 0 even after training (if there was an error or loss extraction failed)\n   * - But if training ran, the model weights have been updated, making it worth saving\n   * - This ensures we only save models that have actually been trained, not just initialized\n   */\n  canSaveModel(): boolean {\n    const hasEnoughData = this.replayBuffer.canSample(32);\n    const hasCompletedEpisode = this.currentEpisode > 0; // Need at least one episode for meaningful stats\n    // Require that training has actually occurred (model weights have been updated)\n    return hasEnoughData && hasCompletedEpisode && this.hasTrainedAtLeastOnce;\n  }\n\n  /**\n   * Get replay buffer size\n   */\n  getReplayBufferSize(): number {\n    return this.replayBuffer.size();\n  }\n\n  /**\n   * Save model\n   */\n  async saveModel(path: string, evalScore?: number, displayName?: string): Promise<void> {\n    // Ensure path has indexeddb:// prefix for IndexedDB storage\n    // If path already has the prefix, use it as-is; otherwise add it\n    const fullPath = path.startsWith('indexeddb://') ? path : `indexeddb://${path}`;\n    \n    if (!this.agent) {\n      throw new Error('Agent not initialized. Cannot save model.');\n    }\n    \n    // CRITICAL: Save model weights FIRST and verify they were saved\n    // Only save metadata AFTER we confirm the weights are in IndexedDB\n    // This prevents orphaned metadata entries\n    try {\n      await this.agent.save(fullPath);\n      // agent.save() now includes verification - if it returns, weights are saved\n    } catch (error) {\n      console.error('RLTrainingManager: Model weights save/verification failed:', error);\n      throw new Error(`Failed to save model weights: ${error instanceof Error ? error.message : String(error)}`);\n    }\n    \n    // Only save metadata if weights were successfully saved and verified\n    try {\n      await saveModelWithMetadata(fullPath, evalScore, displayName);\n    } catch (metaError) {\n      // If metadata save fails, log but don't throw - weights are already saved\n      console.warn('RLTrainingManager: Failed to save model metadata (weights are saved):', metaError);\n      // Don't throw - metadata is optional, weights are the important part\n    }\n  }\n\n  /**\n   * Load model\n   */\n  async loadModel(path: string): Promise<void> {\n    await this.agent.load(`indexeddb://${path}`);\n  }\n\n  /**\n   * Reset environment for new episode\n   */\n  resetEpisode(context: AIContext, gameId?: string): void {\n    const gameKey = gameId || 'default';\n    const newState = this.env.reset(context);\n    this.gameStates.set(gameKey, newState);\n  }\n\n  /**\n   * Get max episode time in milliseconds\n   */\n  getMaxEpisodeTimeMs(): number {\n    return this.config.maxEpisodeTimeMs;\n  }\n\n  /**\n   * Dispose resources\n   */\n  dispose(): void {\n    this.stop();\n    this.agent.dispose();\n    this.replayBuffer.clear();\n  }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5993, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/ai-tank/rl-training-hook.ts"],"sourcesContent":["/**\n * React Hook for RL Training\n * \n * Provides a hook interface for training that can be used in React components.\n */\n\nimport { useEffect, useRef, useState } from 'react';\nimport { RLTrainingManager, type TrainingStats, type TrainingConfig } from './rl-training-manager';\nimport type { AIContext } from './types';\nimport type { AIDecision } from './types';\nimport { isKeyOf } from '@/lib/type-guards';\n\nexport function useRLTraining(config: Partial<TrainingConfig> = {}) {\n  const [isTraining, setIsTraining] = useState(false);\n  const [stats, setStats] = useState<TrainingStats | null>(null);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const managerRef = useRef<RLTrainingManager | null>(null);\n  const configRef = useRef(config);\n  \n  // Keep config ref up to date\n  useEffect(() => {\n    configRef.current = config;\n  }, [config]);\n\n  // Memoize callbacks to prevent recreation\n  const onEpisodeCompleteRef = useRef(config.onEpisodeComplete);\n  const onTrainingUpdateRef = useRef(config.onTrainingUpdate);\n  \n  useEffect(() => {\n    onEpisodeCompleteRef.current = config.onEpisodeComplete;\n    onTrainingUpdateRef.current = config.onTrainingUpdate;\n  }, [config.onEpisodeComplete, config.onTrainingUpdate]);\n\n  useEffect(() => {\n    const manager = new RLTrainingManager({\n      ...configRef.current,\n      onEpisodeComplete: (episodeStats) => {\n        setStats((prev) => {\n          // Preserve loss value from previous stats if it exists and is non-zero\n          // This prevents loss from being reset to 0 when episodes complete\n          const preservedLoss = (prev?.loss ?? 0) > 0 ? (prev?.loss ?? 0) : episodeStats.loss;\n          return { ...episodeStats, loss: preservedLoss };\n        });\n        if (onEpisodeCompleteRef.current) {\n          onEpisodeCompleteRef.current(episodeStats);\n        }\n      },\n      onTrainingUpdate: (updateStats) => {\n        setStats((prev) => {\n          // Type guard to check if key is valid TrainingStats key\n          const isValidTrainingStatsKey = (key: string): key is keyof TrainingStats => {\n            const validKeys: readonly (keyof TrainingStats)[] = [\n              'episode',\n              'episodeReward',\n              'episodeLength',\n              'totalReward',\n              'averageReward',\n              'epsilon',\n              'loss',\n            ];\n            return typeof key === 'string' && validKeys.includes(key as keyof TrainingStats);\n          };\n          \n          // Filter out undefined values to prevent overwriting with undefined\n          const definedUpdates: Partial<TrainingStats> = {};\n          for (const [key, value] of Object.entries(updateStats)) {\n            if (value !== undefined && isValidTrainingStatsKey(key)) {\n              definedUpdates[key] = value;\n            }\n          }\n          \n          // If prev is null, initialize with default values and merge defined updates\n          if (!prev) {\n            const defaultStats: TrainingStats = {\n              episode: 0,\n              episodeReward: 0,\n              episodeLength: 0,\n              totalReward: 0,\n              averageReward: 0,\n              epsilon: 1.0,\n              loss: 0,\n            };\n            return { ...defaultStats, ...definedUpdates };\n          }\n          // Only update if values actually changed to prevent infinite loops\n          const hasChanges = Object.keys(definedUpdates).some(\n            (key) => {\n              if (isValidTrainingStatsKey(key)) {\n                return prev[key] !== definedUpdates[key];\n              }\n              return false;\n            }\n          );\n          return hasChanges ? { ...prev, ...definedUpdates } : prev;\n        });\n        if (onTrainingUpdateRef.current) {\n          onTrainingUpdateRef.current(updateStats);\n        }\n      },\n    });\n\n    manager.initialize().then(() => {\n      setIsInitialized(true);\n      managerRef.current = manager;\n      // Initialize stats with current manager stats to ensure all fields are present\n      const initialStats = manager.getStats();\n      setStats(initialStats);\n    });\n\n    return () => {\n      if (managerRef.current) {\n        managerRef.current.dispose();\n      }\n    };\n  }, []);\n\n  const startTraining = () => {\n    if (managerRef.current && isInitialized) {\n      managerRef.current.start();\n      setIsTraining(true);\n    }\n  };\n\n  const stopTraining = () => {\n    if (managerRef.current) {\n      managerRef.current.stop();\n      setIsTraining(false);\n    }\n  };\n\n  const step = async (context: AIContext, decision: AIDecision, actionTaken?: number) => {\n    if (managerRef.current && isTraining) {\n      await managerRef.current.step(context, decision, actionTaken);\n    }\n  };\n\n  const saveModel = async (name: string, evalScore?: number, displayName?: string) => {\n    if (managerRef.current) {\n      await managerRef.current.saveModel(name, evalScore, displayName);\n    }\n  };\n\n  const loadModel = async (name: string) => {\n    if (managerRef.current) {\n      await managerRef.current.loadModel(name);\n    }\n  };\n\n  const resetEpisode = (context: AIContext) => {\n    if (managerRef.current) {\n      managerRef.current.resetEpisode(context);\n    }\n  };\n\n  const incrementEpisode = () => {\n    if (managerRef.current) {\n      managerRef.current.incrementEpisode();\n    }\n  };\n\n  const canSaveModel = () => {\n    return managerRef.current ? managerRef.current.canSaveModel() : false;\n  };\n\n  const getReplayBufferSize = () => {\n    return managerRef.current ? managerRef.current.getReplayBufferSize() : 0;\n  };\n\n  return {\n    isTraining,\n    isInitialized,\n    stats,\n    startTraining,\n    stopTraining,\n    step,\n    saveModel,\n    loadModel,\n    resetEpisode,\n    incrementEpisode,\n    canSaveModel,\n    getReplayBufferSize,\n    get manager() {\n      return managerRef.current;\n    },\n  };\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6177, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/components/UnifiedTrainingView.tsx"],"sourcesContent":["/**\n * Unified Training View\n * \n * Single interface for all training modes: AI vs AI and Person vs AI\n * Supports up to 4 games simultaneously with stats and model summary\n */\n\n'use client';\n\nimport React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';\n\n// Component to update stats reactively (no polling)\nfunction StatsDebouncer({ \n  stats, \n  onUpdate \n}: { \n  stats: { episodeReward: number; episodeLength: number }; \n  onUpdate: (stats: { episodeReward: number; episodeLength: number }) => void;\n}) {\n  const prevStatsRef = useRef<{ episodeReward: number; episodeLength: number } | null>(null);\n  \n  // Update reactively when stats change (no artificial delays)\n  useEffect(() => {\n    const prev = prevStatsRef.current;\n    // Only update if values actually changed\n    if (!prev || prev.episodeReward !== stats.episodeReward || prev.episodeLength !== stats.episodeLength) {\n      prevStatsRef.current = stats;\n      onUpdate(stats);\n    }\n  }, [stats.episodeReward, stats.episodeLength, onUpdate]);\n  \n  return null;\n}\nimport mapDataJson from '@/content/games/tank-trouble-map.json';\nimport type { Tank, Bullet, TankTroubleMapData, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport {\n  isObject,\n  isNumber,\n  isArray,\n  hasPropertyOfType,\n  parseAndValidate,\n  isError,\n} from '@/lib/type-guards';\n\n// Type guard for TankTroubleMapData\nfunction isTankTroubleMapData(data: unknown): data is TankTroubleMapData {\n  if (!isObject(data)) {\n    return false;\n  }\n  \n  return (\n    hasPropertyOfType(data, 'width', isNumber) &&\n    hasPropertyOfType(data, 'height', isNumber) &&\n    hasPropertyOfType(data, 'barriers', (val): val is Barrier[] => isArray(val)) &&\n    hasPropertyOfType(data, 'spawnPoints', (val): val is Array<{ x: number; y: number; angle: number }> => isArray(val)) &&\n    (!('suns' in data) || hasPropertyOfType(data, 'suns', (val): val is Sun[] => isArray(val)))\n  );\n}\n\n// Validate and construct map data without type assertions\nfunction validateMapData(data: unknown): TankTroubleMapData {\n  const parsed = parseAndValidate(\n    data,\n    isTankTroubleMapData,\n    'Invalid map data structure: missing or invalid required properties'\n  );\n  \n  return {\n    width: parsed.width,\n    height: parsed.height,\n    barriers: parsed.barriers,\n    spawnPoints: parsed.spawnPoints,\n    suns: parsed.suns || [],\n  };\n}\n\nconst mapData: TankTroubleMapData = validateMapData(mapDataJson);\nimport { useGameInput } from '@/app/games/tank-trouble/hooks/useGameInput';\nimport { useTankImages } from '@/app/games/tank-trouble/hooks/useTankImages';\nimport { useMultiGameLogic, type GameInstance as GameLogicInstance } from '@/app/games/tank-trouble/components/GameLogic';\nimport { GameCanvas } from '@/app/games/tank-trouble/components/GameCanvas';\nimport { getInitialSpawnPositions } from '@/app/games/tank-trouble/utils/spawn';\nimport { DEFAULT_AI_CONFIG, type AIConfig, rlModelManager } from '@/app/games/tank-trouble/ai-tank';\nimport { useRLTraining } from '@/app/games/tank-trouble/ai-tank/rl-training-hook';\nimport { listSavedModels, type SavedModel } from '@/app/games/tank-trouble/ai-tank/rl-model-storage';\nimport { DQNAgent } from '@/app/games/tank-trouble/ai-tank/rl-dqn-model';\nimport { TensorFlowJSModel, type ExtendedRLModel } from '@/app/games/tank-trouble/ai-tank/rl-model';\nimport type { Observation } from '@/app/games/tank-trouble/ai-tank/rl-observation';\nimport type { AIDecision } from '@/app/games/tank-trouble/ai-tank/types';\nimport { MAX_EPISODE_TIME_MS } from '@/app/games/tank-trouble/constants/game-constants';\n// import { TrainingDictionary } from './TrainingDictionary';\n\ninterface GameInstance {\n  id: number;\n  tanks: Tank[];\n  bullets: Bullet[];\n  lastShotTimes: { blue: number; red: number };\n  gameOverWinner: 'blue' | 'red' | null;\n  episodeReward: number;\n  episodeLength: number;\n  episodeStartTime: number;\n  gameType: 'ai-vs-ai' | 'person-vs-ai';\n  episodeNumber: number; // Current episode number for this game instance\n}\n\ninterface GameStats {\n  totalGames: number;\n  aiVsAiGames: number;\n  personVsAiGames: number;\n}\n\n// Speed multiplier for AI vs AI games (1x speed for normal training)\nconst AI_VS_AI_SPEED_MULTIPLIER = 1;\n\n// Configuration: Number of simultaneous games to train\nconst MAX_GAMES = 4;\nconst MAX_GAMES_HEADLESS = 8; // More games in headless mode since we're not rendering\nconst AUTO_SAVE_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes\n\nexport function UnifiedTrainingView() {\n  const typedMapData = mapData;\n  \n  // These are static values from map data, so use constants instead of refs\n  // Refs should only be used for values that change and shouldn't trigger re-renders\n  const barriers = typedMapData.barriers || [];\n  const suns = typedMapData.suns || [];\n  const aiConfig = DEFAULT_AI_CONFIG;\n  \n  // Headless training mode\n  const [isHeadlessMode, setIsHeadlessMode] = useState(false);\n  const [autoSaveCount, setAutoSaveCount] = useState(0);\n  const autoSaveIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  \n  // Use more games in headless mode since we're not rendering\n  const maxGames = isHeadlessMode ? MAX_GAMES_HEADLESS : MAX_GAMES;\n\n  // Game statistics\n  const [gameStats, setGameStats] = useState<GameStats>({\n    totalGames: 0,\n    aiVsAiGames: 0,\n    personVsAiGames: 0,\n  });\n  \n  // Track total games started (including incomplete ones)\n  // Starts at MAX_GAMES because we have MAX_GAMES games running initially\n  const [totalGamesStarted, setTotalGamesStarted] = useState(MAX_GAMES);\n\n  // Model selection\n  const [savedModels, setSavedModels] = useState<SavedModel[]>([]);\n  const [selectedModel, setSelectedModel] = useState<string>('');\n  const [isLoadingModels, setIsLoadingModels] = useState(false);\n  const selectedModelRef = useRef<string>('');\n  \n  // Dictionary visibility (commented out - using separate component)\n  // const [isDictionaryVisible, setIsDictionaryVisible] = useState(true);\n  \n  // Debounced stats for display (update every 5 seconds)\n  const [displayStats, setDisplayStats] = useState<{ reward: number; length: number } | null>(null);\n  \n  // Memoize the update callback to prevent recreation\n  const handleDisplayStatsUpdate = useCallback((stats: { episodeReward: number; episodeLength: number }) => {\n    setDisplayStats((prev) => {\n      // Only update if values actually changed\n      if (!prev || prev.reward !== stats.episodeReward || prev.length !== stats.episodeLength) {\n        return { reward: stats.episodeReward, length: stats.episodeLength };\n      }\n      return prev;\n    });\n  }, []);\n\n  // Track which game the user is playing (only one at a time)\n  const [userPlayingGameId, setUserPlayingGameId] = useState<number | null>(null);\n\n  // Ref to track next episode number atomically (prevents race conditions when multiple games end simultaneously)\n  const nextEpisodeNumberRef = useRef(MAX_GAMES + 1); // Start at MAX_GAMES + 1 (will be updated when headless mode changes)\n\n  // Track current time for duration calculations\n  const [currentTime, setCurrentTime] = useState(Date.now());\n\n  // Update current time every second for duration display\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setCurrentTime(Date.now());\n    }, 1000); // Update every second\n    \n    return () => clearInterval(interval);\n  }, []);\n\n  // Create game instances (start with MAX_GAMES AI vs AI games, will expand to MAX_GAMES_HEADLESS in headless mode)\n  const [gameInstances, setGameInstances] = useState<GameInstance[]>(() => {\n    const instances = Array.from({ length: MAX_GAMES }, (_, i) => {\n      const initialTanks = getInitialSpawnPositions(typedMapData, barriers, suns);\n      \n      return {\n        id: i,\n        tanks: initialTanks,\n        bullets: [],\n        lastShotTimes: { blue: 0, red: 0 },\n        gameOverWinner: null,\n        episodeReward: 0,\n        episodeLength: 0,\n        episodeStartTime: Date.now(),\n        gameType: 'ai-vs-ai' as const,\n        episodeNumber: i + 1, // Start at ID + 1 (Game 1, Game 2, Game 3, Game 4)\n      };\n    });\n    \n    return instances;\n  });\n\n  // Shared training manager\n  const training = useRLTraining({\n    episodes: 1000,\n    trainEvery: 4,\n    saveEvery: 100,\n    selfPlay: true,\n    // TODO: Implement headless mode later - this will allow faster training by skipping rendering\n    // headless: false,\n  });\n\n  // All games are always active (assume all games are always running)\n  const activeGamesCount = gameInstances.length;\n\n  // Sync gameStats.totalGames with training episode count (completed games)\n  useEffect(() => {\n    if (training.stats && training.stats.episode !== undefined) {\n      const completedGames = training.stats.episode;\n      setGameStats((prev) => ({\n        ...prev,\n        totalGames: completedGames,\n      }));\n    }\n  }, [training.stats?.episode]);\n  \n  // Update total games started when a game completes\n  // This includes both completed and incomplete games\n  useEffect(() => {\n    if (training.stats && training.stats.episode !== undefined) {\n      // Total games started = completed games + active games count\n      setTotalGamesStarted(training.stats.episode + activeGamesCount);\n    }\n  }, [training.stats?.episode, activeGamesCount]);\n\n  // Helper function to save model (used by both manual and auto-save)\n  const saveModelHelper = useCallback(async () => {\n    if (!training.manager || !training.canSaveModel()) {\n      return false;\n    }\n\n    try {\n      const episode = training.stats?.episode || 0;\n      const modelVersion = Math.floor(episode / activeGamesCount) + 1;\n      const timestamp = Date.now();\n      const isoString = new Date(timestamp).toISOString();\n      const modelPath = `indexeddb://tank-ai-${timestamp}`;\n      const evalScore = training.stats?.averageReward;\n\n      // COMMENTED OUT: Frontend training disabled - using backend training service instead\n      // await training.saveModel(modelPath, evalScore, isoString);\n      \n      // await new Promise(resolve => setTimeout(resolve, 500));\n      \n      // const models = await listSavedModels();\n      // setSavedModels(models);\n      // setAutoSaveCount(prev => prev + 1);\n      return true;\n    } catch (error) {\n      console.error('Error auto-saving model:', error);\n      return false;\n    }\n  }, [training, activeGamesCount]);\n\n  // Auto-save interval for headless mode\n  useEffect(() => {\n    if (isHeadlessMode && training.isTraining) {\n      // Clear any existing interval\n      if (autoSaveIntervalRef.current) {\n        clearInterval(autoSaveIntervalRef.current);\n      }\n      \n      // Set up auto-save every 5 minutes\n      autoSaveIntervalRef.current = setInterval(() => {\n        saveModelHelper();\n      }, AUTO_SAVE_INTERVAL_MS);\n      \n      return () => {\n        if (autoSaveIntervalRef.current) {\n          clearInterval(autoSaveIntervalRef.current);\n        }\n      };\n    } else {\n      // Clear interval when headless mode is disabled or training stops\n      if (autoSaveIntervalRef.current) {\n        clearInterval(autoSaveIntervalRef.current);\n        autoSaveIntervalRef.current = null;\n      }\n    }\n  }, [isHeadlessMode, training.isTraining, saveModelHelper]);\n\n  // Update game instances when headless mode changes\n  useEffect(() => {\n    const targetCount = isHeadlessMode ? MAX_GAMES_HEADLESS : MAX_GAMES;\n    setGameInstances(prev => {\n      if (prev.length === targetCount) {\n        return prev; // No change needed\n      }\n      \n      if (prev.length < targetCount) {\n        // Add more game instances\n        const newInstances = Array.from({ length: targetCount - prev.length }, (_, i) => {\n          const instanceId = prev.length + i;\n          const initialTanks = getInitialSpawnPositions(typedMapData, barriers, suns);\n          return {\n            id: instanceId,\n            tanks: initialTanks,\n            bullets: [],\n            lastShotTimes: { blue: 0, red: 0 },\n            gameOverWinner: null,\n            episodeReward: 0,\n            episodeLength: 0,\n            episodeStartTime: Date.now(),\n            gameType: 'ai-vs-ai' as const,\n            episodeNumber: nextEpisodeNumberRef.current++,\n          };\n        });\n        return [...prev, ...newInstances];\n      } else {\n        // Remove excess game instances (remove from end, but don't remove if user is playing)\n        const instancesToKeep = prev.slice(0, targetCount);\n        // Make sure we don't remove the game the user is playing\n        const userGameIndex = userPlayingGameId !== null \n          ? instancesToKeep.findIndex(gi => gi.id === userPlayingGameId)\n          : -1;\n        \n        if (userGameIndex === -1 && userPlayingGameId !== null) {\n          // User's game would be removed, keep it and remove a different one\n          const userGame = prev.find(gi => gi.id === userPlayingGameId);\n          if (userGame) {\n            const withoutUserGame = prev.filter(gi => gi.id !== userPlayingGameId);\n            const toKeep = withoutUserGame.slice(0, targetCount - 1);\n            return [...toKeep, userGame];\n          }\n        }\n        \n        return instancesToKeep;\n      }\n    });\n  }, [isHeadlessMode, typedMapData, barriers, suns, userPlayingGameId]);\n\n  const tankImages = useTankImages();\n  \n  // Single keyboard input hook - only one game can be personal at a time\n  const activeGameOver = userPlayingGameId !== null ? gameInstances[userPlayingGameId]?.gameOverWinner !== null : false;\n  const gameInput = useGameInput({ gameOver: activeGameOver });\n\n  // Stable empty keys ref for non-user games (created once, reused)\n  const emptyKeysRef = useRef<Set<string>>(new Set<string>());\n  \n  // Use appropriate keys ref based on game type\n  const getKeysRef = useCallback((gameId: number) => {\n    // Only return the keys ref if this is the game the user is playing\n    if (gameId === userPlayingGameId) {\n      return gameInput.keysRef;\n    }\n    return emptyKeysRef;\n  }, [userPlayingGameId, gameInput.keysRef]);\n\n\n  // Replace AI game with person game (user joins as Blue, AI is Red)\n  // Preserves current game state - user takes control of existing blue tank\n  const replaceWithPersonGame = (gameId: number) => {\n    // If user is already playing another game, convert that one back to AI vs AI first\n    if (userPlayingGameId !== null && userPlayingGameId !== gameId) {\n      replaceWithAIGame(userPlayingGameId);\n    }\n    \n    setUserPlayingGameId(gameId);\n    setGameInstances((prev) =>\n      prev.map((gi) =>\n        gi.id === gameId\n          ? {\n              ...gi,\n              gameType: 'person-vs-ai',\n              // Don't reset game state - preserve current tanks, bullets, and game progress\n              // User simply takes control of the existing blue tank\n            }\n          : gi\n      )\n    );\n  };\n\n  // Replace person game with AI game\n  // Preserves current game state - AI simply takes control of the blue tank\n  const replaceWithAIGame = (gameId: number) => {\n    if (userPlayingGameId === gameId) {\n      setUserPlayingGameId(null);\n    }\n    setGameInstances((prev) =>\n      prev.map((gi) =>\n        gi.id === gameId\n          ? {\n              ...gi,\n              gameType: 'ai-vs-ai',\n              // Don't reset game state - preserve current tanks, bullets, and game progress\n              // AI simply takes control of the existing blue tank\n            }\n          : gi\n      )\n    );\n  };\n\n  // Get max episode time from training manager\n  const maxEpisodeTimeMs = training.manager?.getMaxEpisodeTimeMs() || MAX_EPISODE_TIME_MS;\n\n  // Prepare game instances for multi-game logic hook - memoize to avoid recreating on every render\n  // Note: This will still recreate when gameInstances changes (which is frequent during gameplay),\n  // but prevents recreation on unrelated renders (UI state changes, etc.)\n  const gameLogicInstances: GameLogicInstance[] = useMemo(() => {\n    return gameInstances.map((instance) => ({\n      id: instance.id,\n      tanks: instance.tanks,\n      bullets: instance.bullets,\n      lastShotTimes: instance.lastShotTimes,\n      gameMode: instance.gameType === 'person-vs-ai' ? 'person-vs-ai' : 'ai',\n      gameId: `game-${instance.id}`,\n      isPaused: !training.isTraining || (instance.id === userPlayingGameId && gameInput.isPaused),\n      speedMultiplier: instance.gameType === 'ai-vs-ai' ? AI_VS_AI_SPEED_MULTIPLIER : 1,\n      episodeStartTime: instance.episodeStartTime,\n      keysRef: getKeysRef(instance.id), // getKeysRef returns stable refs, safe to call here\n    }));\n  }, [\n    gameInstances,\n    training.isTraining,\n    userPlayingGameId,\n    gameInput.isPaused,\n    getKeysRef, // Now properly memoized with useCallback\n  ]);\n\n  // Single hook call for all games\n  const gameLogic = useMultiGameLogic({\n    mapData: typedMapData,\n    barriers: barriers,\n    suns: suns,\n    aiConfig,\n    trainingManager: training.manager,\n    maxEpisodeTimeMs,\n    gameInstances: gameLogicInstances,\n    onTanksUpdate: (gameId, tanks) => {\n      setGameInstances((prev) => {\n        const updated = prev.map((gi) => {\n          if (gi.id === gameId) {\n            return { ...gi, tanks };\n          }\n          return gi;\n        });\n        return updated;\n      });\n    },\n    onBulletsUpdate: (gameId, bullets) => {\n      setGameInstances((prev) =>\n        prev.map((gi) => (gi.id === gameId ? { ...gi, bullets } : gi))\n      );\n    },\n    onLastShotTimesUpdate: (gameId, times) => {\n      setGameInstances((prev) =>\n        prev.map((gi) => (gi.id === gameId ? { ...gi, lastShotTimes: times } : gi))\n      );\n    },\n    onGameOver: (gameId, winner) => {\n      const newEpisodeNumber = nextEpisodeNumberRef.current++;\n      training.incrementEpisode();\n\n      // Check the game type before resetting (to preserve user control if it's person-vs-ai)\n      const gameBeforeReset = gameInstances.find(gi => gi.id === gameId);\n      const wasPersonVsAI = gameBeforeReset?.gameType === 'person-vs-ai';\n\n      setGameInstances((prev) =>\n        prev.map((gi) => {\n          if (gi.id === gameId) {\n            setGameStats((stats) => ({\n              ...stats,\n              aiVsAiGames: gi.gameType === 'ai-vs-ai' ? stats.aiVsAiGames + 1 : stats.aiVsAiGames,\n              personVsAiGames: gi.gameType === 'person-vs-ai' ? stats.personVsAiGames + 1 : stats.personVsAiGames,\n            }));\n\n            return {\n              ...gi,\n              tanks: getInitialSpawnPositions(typedMapData, barriers, suns),\n              bullets: [],\n              lastShotTimes: { blue: 0, red: 0 },\n              gameOverWinner: null,\n              episodeReward: 0,\n              episodeLength: 0,\n              episodeStartTime: Date.now(),\n              episodeNumber: newEpisodeNumber,\n              // Preserve gameType so user can continue controlling if it was person-vs-ai\n              // gameType is already preserved in the spread (...gi)\n            };\n          }\n          return gi;\n        })\n      );\n\n      // Only clear userPlayingGameId if the game was NOT person-vs-ai\n      // If it was person-vs-ai, the user should keep control for the new episode\n      if (gameId === userPlayingGameId && !wasPersonVsAI) {\n        setUserPlayingGameId(null);\n      }\n      // If wasPersonVsAI is true, keep userPlayingGameId set so controls continue working\n    },\n  });\n\n  // Games are always active - no need to track isActive state\n\n  // Run all game loops (only if training is active)\n  useEffect(() => {\n    if (!training.isTraining) {\n      return;\n    }\n\n    const animationFrames: number[] = [];\n    let lastFrameTime = performance.now();\n    \n    const gameLoop = (currentTime: number) => {\n      // Tick all games (all games are always active)\n      gameInstances.forEach((instance, idx) => {\n        const isAIVsAI = instance.gameType === 'ai-vs-ai';\n        const speedMultiplier = isAIVsAI ? AI_VS_AI_SPEED_MULTIPLIER : 1;\n        \n        if (isAIVsAI && speedMultiplier > 1) {\n          // For AI vs AI games, run multiple ticks per frame\n          const elapsed = currentTime - lastFrameTime;\n          const targetFrameTime = 1000 / 72; // Target 72 FPS base\n          const ticksToRun = Math.max(1, Math.floor((elapsed / targetFrameTime) * speedMultiplier));\n          \n          for (let i = 0; i < ticksToRun; i++) {\n            gameLogic.gameTick({ skipIntervalCheck: i > 0, gameId: instance.id });\n          }\n        } else {\n          // Normal speed (one tick per frame)\n          gameLogic.gameTick({ gameId: instance.id });\n        }\n        \n        // Update episode length reactively\n        if (instance.episodeStartTime) {\n          const elapsed = (Date.now() - instance.episodeStartTime) / 1000;\n          const newEpisodeLength = Math.floor(elapsed * 72);\n          if (instance.episodeLength !== newEpisodeLength) {\n            setGameInstances((prev) =>\n              prev.map((gi) => (gi.id === instance.id ? { ...gi, episodeLength: newEpisodeLength } : gi))\n            );\n          }\n        }\n      });\n      \n      lastFrameTime = currentTime;\n      const frameId = requestAnimationFrame(gameLoop);\n      animationFrames.push(frameId);\n    };\n    \n    const frameId = requestAnimationFrame(gameLoop);\n    animationFrames.push(frameId);\n\n    return () => {\n      animationFrames.forEach((id) => cancelAnimationFrame(id));\n    };\n  }, [training.isTraining, gameLogic, gameInstances]);\n\n  const loadSavedModels = useCallback(async () => {\n    setIsLoadingModels(true);\n    try {\n      const models = await listSavedModels();\n      setSavedModels(models);\n      // Preserve selectedModel if it still exists in the new list\n      if (selectedModelRef.current && !models.some(m => m.path === selectedModelRef.current)) {\n        // If selected model is no longer in the list, keep it selected anyway\n        // (it might have been renamed or the list refresh happened before save completed)\n        // Don't clear it - let the user decide\n      }\n    } catch (error) {\n      console.error('Failed to load models:', error);\n      \n      // Check for Safari/IndexedDB issues\n      const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n      if (isSafari && typeof window.indexedDB === 'undefined') {\n        console.warn('Safari detected with IndexedDB unavailable. This may be due to Private Browsing mode.');\n      }\n    } finally {\n      setIsLoadingModels(false);\n    }\n  }, []);\n\n  // Load saved models on mount\n  useEffect(() => {\n    loadSavedModels();\n  }, [loadSavedModels]);\n\n  // Start training automatically on mount (only once when manager becomes available)\n  // COMMENTED OUT: Frontend training disabled - using backend training service instead\n  // const hasStartedTrainingRef = useRef(false);\n  // useEffect(() => {\n  //   if (!hasStartedTrainingRef.current && !training.isTraining && training.manager) {\n  //     hasStartedTrainingRef.current = true;\n  //     training.startTraining();\n  //   }\n  // }, [training.isTraining, training.manager]);\n\n  // Refresh models when training saves\n  useEffect(() => {\n    if (training.stats && training.stats.episode > 0 && training.stats.episode % 100 === 0) {\n      // Refresh model list when model is saved (every 100 games)\n      // Preserve current selection using ref to avoid stale closure\n      const currentSelection = selectedModelRef.current;\n      loadSavedModels().then(() => {\n        // Restore selection if it still exists\n        if (currentSelection) {\n          setSelectedModel(currentSelection);\n          selectedModelRef.current = currentSelection;\n        }\n      });\n    }\n  }, [training.stats?.episode, loadSavedModels]);\n\n  const handleModelSelect = async (modelPath: string) => {\n    if (!modelPath) return;\n    \n    try {\n      setSelectedModel(modelPath);\n      selectedModelRef.current = modelPath;\n      \n      // Load the model\n      const agent = new DQNAgent();\n      await agent.load(modelPath);\n      \n      // Wrap in model interface\n      const model = new TensorFlowJSModel({\n        name: 'TankTroubleRL',\n        type: 'discrete',\n        observationSize: 142,\n        actionSize: 14,\n      });\n      \n      // Extend model with agent-specific methods\n      // Note: predict must be synchronous to match RLModel interface\n      // The agent's async predict is used in training, not in game loop\n      const extendedModel: ExtendedRLModel = {\n        isLoaded: () => model.isLoaded(),\n        load: (path: string) => model.load(path),\n        getInfo: () => model.getInfo(),\n        agent,\n        predict: (obs: Observation, angle: number): AIDecision => {\n          // Synchronous wrapper - actual async predictions happen in training\n          // For game loop compatibility, return default decision\n          // RL predictions are handled separately in training step\n          return {\n            angleDelta: 0,\n            moveDirection: 0,\n            shouldShoot: false,\n          };\n        },\n      };\n      \n      // Set as active model for AI controller (for playing against AI)\n      rlModelManager.setModel(extendedModel);\n      \n      // Always load the model into the training manager's agent\n      // This allows training to continue from the selected model\n      if (training.manager) {\n        // Extract path without indexeddb:// prefix for loadModel (it adds the prefix)\n        const cleanPath = modelPath.replace('indexeddb://', '');\n        await training.manager.loadModel(cleanPath);\n      }\n      \n      alert('Model loaded successfully! Training will continue from this model.');\n    } catch (error) {\n      console.error('Failed to load model:', error);\n      \n      // Check for Safari/IndexedDB specific issues\n      const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      \n      let userMessage = 'Failed to load model.\\n\\n';\n      \n      if (isSafari) {\n        userMessage += 'Safari detected. Common issues:\\n';\n        userMessage += ' Private Browsing mode disables IndexedDB - try regular browsing mode\\n';\n        userMessage += ' Safari may require user interaction before accessing IndexedDB\\n';\n        userMessage += ' Check Safari settings: Preferences > Privacy > uncheck \"Prevent cross-site tracking\"\\n\\n';\n      }\n      \n      userMessage += `Error: ${errorMessage}\\n\\n`;\n      userMessage += 'Check the browser console for more details.';\n      \n      alert(userMessage);\n    }\n  };\n\n  // Calculate episode length on-demand (no polling)\n  // Episode length is calculated from episodeStartTime when needed\n  // This is done reactively in the game loop or when rendering\n\n  // Calculate grid layout dynamically based on number of games\n  // Aim for roughly square grid (e.g., 4 games = 2x2, 9 games = 3x3, 10 games = 4x3)\n  const gridCols = Math.ceil(Math.sqrt(MAX_GAMES));\n  const gridRows = Math.ceil(MAX_GAMES / gridCols);\n  // Scale down to fit games in grid\n  // Use 0.45 to ensure proper fit with padding\n  const scale = 0.45;\n  \n  // Speed multiplier for AI vs AI games (3x faster for faster training)\n\n  // Get model info\n  const modelInfo = rlModelManager.getModel().getInfo();\n  const isRLActive = rlModelManager.isRLActive();\n\n  return (\n    <div className=\"flex flex-col gap-4 w-full\">\n      {/* Top Section: Stats/Model Info and Training Controls */}\n      <div className=\"flex gap-4\">\n        {/* Left: RL Training + Model Selector, Stats, and Model Summary */}\n        <div className=\"flex-1 space-y-4\">\n          {/* Model Selector Section (Top) */}\n          <div className=\"p-4 bg-white border border-gray-300 rounded shadow\">\n            <div className=\"flex items-center gap-2\">\n              <label className=\"text-sm font-semibold whitespace-nowrap\">Select Model (Optional):</label>\n              <select\n                value={selectedModel}\n                onChange={(e) => handleModelSelect(e.target.value)}\n                className=\"px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm\"\n                style={{ maxWidth: '200px' }}\n                disabled={isLoadingModels}\n              >\n                <option value=\"\">{isLoadingModels ? 'Loading models...' : '-- Select a model --'}</option>\n                {savedModels.length === 0 && !isLoadingModels && (\n                  <option value=\"\" disabled>No saved models found</option>\n                )}\n                {savedModels.map((model) => (\n                  <option key={model.path} value={model.path}>\n                    {model.createdAtString}{model.evalScore !== undefined ? ` (Eval: ${model.evalScore.toFixed(2)})` : ''}\n                  </option>\n                ))}\n              </select>\n              <button\n                onClick={loadSavedModels}\n                style={{ backgroundColor: '#e5e7eb' }}\n                className=\"px-3 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 disabled:bg-gray-200 disabled:opacity-50 text-sm font-medium whitespace-nowrap flex-shrink-0\"\n                disabled={isLoadingModels}\n              >\n                {isLoadingModels ? 'Loading...' : 'Refresh'}\n              </button>\n              <button\n                onClick={async () => {\n                  try {\n                    setIsLoadingModels(true);\n                    const response = await fetch('/api/backend/models/latest');\n                    if (!response.ok) {\n                      throw new Error(`Failed to fetch model: ${response.statusText}`);\n                    }\n                    const modelData = await response.json();\n                    \n                    // Convert backend model format to TensorFlow.js format\n                    // The backend returns { layers, metadata }\n                    // We need to load this into the DQN agent\n                    const agent = new DQNAgent();\n                    \n                    // TODO: Convert backend model weights to TensorFlow.js format\n                    // For now, we'll need to implement a conversion function\n                    // This is a placeholder - full implementation would convert the weights\n                    alert('Model fetched from backend! (Conversion to TensorFlow.js format pending)');\n                    \n                    // After conversion, load the model similar to handleModelSelect\n                    // await agent.load(convertedModelPath);\n                    // ... rest of loading logic\n                  } catch (error) {\n                    console.error('Error fetching model from backend:', error);\n                    alert(`Failed to fetch model from backend: ${error instanceof Error ? error.message : String(error)}`);\n                  } finally {\n                    setIsLoadingModels(false);\n                  }\n                }}\n                style={{ backgroundColor: '#dbeafe' }}\n                className=\"px-3 py-2 bg-blue-100 text-blue-700 rounded hover:bg-blue-200 disabled:bg-gray-200 disabled:opacity-50 text-sm font-medium whitespace-nowrap flex-shrink-0\"\n                disabled={isLoadingModels}\n              >\n                {isLoadingModels ? 'Loading...' : 'Fetch from Backend'}\n              </button>\n            </div>\n            <div className=\"mt-2 text-xs text-gray-500 italic\">\n              Models are saved in your browser's local storage (Dexie DB). Maximum 8 models kept.\n            </div>\n          </div>\n\n          {/* Training Controls Section (Bottom) */}\n          <div className=\"p-4 bg-white border border-gray-300 rounded shadow\">\n            <div className=\"flex items-center gap-4 flex-wrap\">\n              {/* Training Controls */}\n              <div className=\"flex items-center gap-2 flex-wrap\">\n                <button\n                  onClick={async () => {\n                    try {\n                      // Check if training manager is initialized\n                      if (!training.manager) {\n                        alert('Training manager not initialized. Please wait for initialization.');\n                        return;\n                      }\n                      \n                      // Check if model can be saved\n                      if (!training.canSaveModel()) {\n                        const bufferSize = training.getReplayBufferSize();\n                        const hasEpisodes = (training.stats?.episode ?? 0) > 0;\n                        \n                        let message = 'Cannot save model yet. Requirements:\\n';\n                        if (bufferSize < 32) {\n                          message += `- Need at least 32 steps in replay buffer (current: ${bufferSize})\\n`;\n                        }\n                        if (!hasEpisodes) {\n                          message += '- Need at least one completed episode\\n';\n                        }\n                        if (bufferSize >= 32 && hasEpisodes) {\n                          message += '- Need to wait for training to occur (training happens every 4 steps when buffer has 32+ steps)\\n';\n                        }\n                        alert(message);\n                        return;\n                      }\n                      \n                      // Get model version from Game Status (vX where X = Math.floor(episode / activeGamesCount) + 1)\n                      const episode = training.stats?.episode || 0;\n                      const modelVersion = Math.floor(episode / activeGamesCount) + 1;\n                      \n                      // Use ISO timestamp for model name\n                      const timestamp = Date.now();\n                      const isoString = new Date(timestamp).toISOString();\n                      const modelPath = `indexeddb://tank-ai-${timestamp}`;\n                      \n                      // Get eval score (average reward)\n                      const evalScore = training.stats?.averageReward;\n                      \n                      // COMMENTED OUT: Frontend training disabled - using backend training service instead\n                      // await training.saveModel(modelPath, evalScore, isoString);\n                      \n                      // // Wait a bit for IndexedDB to fully sync (TensorFlow.js save is async)\n                      // await new Promise(resolve => setTimeout(resolve, 500));\n                      \n                      // // Preserve current selection before refreshing\n                      // const currentSelection = selectedModelRef.current;\n                      \n                      // // Try loading models with retry logic in case of timing issues\n                      // let models = await listSavedModels();\n                      // let retries = 0;\n                      // while (models.length === 0 && retries < 3) {\n                      //   await new Promise(resolve => setTimeout(resolve, 500));\n                      //   models = await listSavedModels();\n                      //   retries++;\n                      // }\n                      \n                      // setSavedModels(models);\n                      \n                      // // If we had a selection and it still exists, restore it\n                      // // Otherwise, the newly saved model will be available but not auto-selected\n                      // if (currentSelection && models.some(m => m.path === currentSelection)) {\n                      //   setSelectedModel(currentSelection);\n                      //   selectedModelRef.current = currentSelection;\n                      // }\n                      \n                      // if (models.some(m => m.path === modelPath)) {\n                      //   alert(`Model v${modelVersion} saved successfully! It should now appear in the dropdown.`);\n                      // } else {\n                      //   console.warn('Model saved but not found in list. This may be a timing issue. Try refreshing the model list manually.');\n                      //   alert(`Model v${modelVersion} saved, but it's not showing in the dropdown yet. Try clicking \"Refresh\" to reload the model list.`);\n                      // }\n                      alert('Frontend training is disabled. Models are saved automatically by the backend training service every 5 minutes.');\n                    } catch (error) {\n                      console.error('Error saving model:', error);\n                      const errorMessage = isError(error) ? error.message : String(error);\n                      alert(`Failed to save model: ${errorMessage}\\n\\nCheck the browser console for details.`);\n                    }\n                  }}\n                  disabled={!training.manager || !training.canSaveModel()}\n                  style={{ \n                    backgroundColor: (!training.manager || !training.canSaveModel()) ? '#d1d5db' : '#bfdbfe',\n                    opacity: (!training.manager || !training.canSaveModel()) ? 0.6 : 1,\n                    cursor: (!training.manager || !training.canSaveModel()) ? 'not-allowed' : 'pointer',\n                  }}\n                  className={`px-4 py-2 rounded font-medium ${\n                    (!training.manager || !training.canSaveModel())\n                      ? 'bg-gray-300 text-gray-500'\n                      : 'bg-blue-200 text-blue-700 hover:bg-blue-300'\n                  }`}\n                  title={(!training.manager || !training.canSaveModel()) \n                    ? `Requirements: 32+ steps in replay buffer, at least 1 episode completed, and training must have occurred at least once`\n                    : 'Save current model (creates new model, does not overwrite)'}\n                >\n                  Save Model\n                </button>\n                \n                {/* Headless Mode Checkbox */}\n                <div className=\"flex items-center gap-2\">\n                  <input\n                    type=\"checkbox\"\n                    id=\"headless-mode\"\n                    checked={isHeadlessMode}\n                    onChange={(e) => setIsHeadlessMode(e.target.checked)}\n                    className=\"w-4 h-4\"\n                  />\n                  <label htmlFor=\"headless-mode\" className=\"text-sm font-medium cursor-pointer\">\n                    Headless Training (8 games, auto-save every 5 min)\n                  </label>\n                  {isHeadlessMode && autoSaveCount > 0 && (\n                    <span className=\"text-xs text-gray-600\">\n                      (Auto-saved: {autoSaveCount})\n                    </span>\n                  )}\n                </div>\n              </div>\n\n              {/* Training Status */}\n              <div className=\"flex items-center gap-2 text-sm\">\n                <span className={`inline-block w-3 h-3 rounded-full ${training.isTraining ? 'bg-green-500' : 'bg-gray-400'}`} />\n                <span>{training.isTraining ? 'Training Active' : 'Training Stopped'}</span>\n              </div>\n            </div>\n            <div className=\"mt-2 text-xs text-gray-500 italic\">\n              Saving a model requires: 32+ steps in replay buffer, at least 1 episode completed, and training must have occurred at least once\n            </div>\n          </div>\n\n          {/* Stats Header */}\n          <div className=\"p-4 bg-white border border-gray-300 rounded shadow\">\n            <div className=\"grid gap-4\" style={{ gridTemplateColumns: `repeat(${Math.min(activeGamesCount, 8)}, 1fr)` }}>\n              <div>\n                <div className=\"text-sm text-gray-600\">Total Games</div>\n                <div className=\"text-2xl font-bold\">{training.stats?.episode || 0}</div>\n              </div>\n              <div>\n                <div className=\"text-sm text-gray-600\">AI vs AI</div>\n                <div className=\"text-2xl font-bold text-blue-600\">{gameStats.aiVsAiGames}</div>\n              </div>\n              <div>\n                <div className=\"text-sm text-gray-600\">Person vs AI</div>\n                <div className=\"text-2xl font-bold text-green-600\">{gameStats.personVsAiGames}</div>\n              </div>\n              <div>\n                <div className=\"text-sm text-gray-600\">Active Games</div>\n                <div className=\"text-2xl font-bold text-purple-600\">\n                  {activeGamesCount}\n                </div>\n              </div>\n            </div>\n          </div>\n\n          {/* Model Summary */}\n          <div className=\"p-4 bg-white border border-gray-300 rounded shadow\">\n            <h3 className=\"font-semibold mb-2\">Model Summary</h3>\n            <div className=\"grid grid-cols-3 gap-4 text-sm mb-2\">\n              <div>\n                <div>\n                  <span className=\"text-gray-600\">Model Type: </span>\n                  <span className=\"font-semibold\">{isRLActive ? 'RL (Trained)' : 'Rule-Based (Fallback)'}</span>\n                </div>\n                <div className=\"text-xs text-gray-500 italic mt-0.5\">Type of AI model being used</div>\n              </div>\n              <div>\n                <div>\n                  <span className=\"text-gray-600\">Action Space: </span>\n                  <span className=\"font-semibold\">{modelInfo.type === 'discrete' ? 'Discrete (14 actions)' : 'Continuous'}</span>\n                </div>\n                <div className=\"text-xs text-gray-500 italic mt-0.5\">Number of possible actions the AI can take</div>\n              </div>\n              <div>\n                <div>\n                  <span className=\"text-gray-600\">Observation Size: </span>\n                  <span className=\"font-semibold\">{modelInfo.observationSize} features</span>\n                </div>\n                <div className=\"text-xs text-gray-500 italic mt-0.5\">Number of input features the AI observes</div>\n              </div>\n            </div>\n            {training.stats && (\n              <>\n                {/* Debounce stats updates (every 5 seconds) */}\n                <StatsDebouncer\n                  stats={training.stats}\n                  onUpdate={handleDisplayStatsUpdate}\n                />\n                <div className=\"mt-2 pt-2 border-t border-gray-200\">\n                  <h4 className=\"font-semibold mb-2 text-sm\">Training Statistics</h4>\n                <div className=\"grid grid-cols-2 gap-3 text-sm mb-2\">\n                  <div>\n                    <div>\n                      <span className=\"text-gray-600\">Games: </span>\n                      <span className=\"font-semibold\">{training.stats.episode}</span>\n                    </div>\n                    <div className=\"text-xs text-gray-500 italic mt-0.5\">Total games completed (auto-saves every 100 games). Each game = one complete game session.</div>\n                  </div>\n                  <div>\n                    <div>\n                      <span className=\"text-gray-600\">Avg Reward: </span>\n                      <span className=\"font-semibold\">{(training.stats.averageReward ?? 0).toFixed(2)}</span>\n                    </div>\n                    <div className=\"text-xs text-gray-500 italic mt-0.5\">Average reward per game</div>\n                  </div>\n                  <div>\n                    <div>\n                      <span className=\"text-gray-600\">Epsilon: </span>\n                      <span className=\"font-semibold\">{(training.stats.epsilon ?? 0).toFixed(3)}</span>\n                    </div>\n                    <div className=\"text-xs text-gray-500 italic mt-0.5\">Exploration rate (higher = more random)</div>\n                  </div>\n                </div>\n                {/* Active Games Stats - Always visible to prevent layout shifts */}\n                <div className=\"mt-2 pt-2 border-t border-gray-200\">\n                  <h4 className=\"font-semibold mb-2 text-sm\">Active Games Stats</h4>\n                  <div className=\"grid grid-cols-2 gap-3 text-sm\">\n                    <div>\n                      <div>\n                        <span className=\"text-gray-600\">Reward: </span>\n                        <span className=\"font-semibold\">\n                          {displayStats?.reward !== undefined \n                            ? displayStats.reward.toFixed(2) \n                            : training.stats?.episodeReward.toFixed(2) || '0.00'}\n                        </span>\n                      </div>\n                      <div className=\"text-xs text-gray-500 italic mt-0.5\">\n                        Total reward across all {activeGamesCount} active games (positive = good, negative = poor performance, but still valid training data)\n                      </div>\n                    </div>\n                  <div>\n                    <div>\n                      <span className=\"text-gray-600\">Length: </span>\n                      <span className=\"font-semibold\">\n                        {displayStats?.length !== undefined \n                          ? displayStats.length \n                          : training.stats?.episodeLength || 0}\n                      </span>\n                    </div>\n                    <div className=\"text-xs text-gray-500 italic mt-0.5\">\n                      Total steps across all {activeGamesCount} active games (updates every 5 seconds)\n                    </div>\n                  </div>\n                  </div>\n                </div>\n              </div>\n              </>\n            )}\n          </div>\n        </div>\n\n        {/* Right: Dictionary */}\n        {/* <TrainingDictionary /> */}\n      </div>\n\n      {/* Game Status - Horizontal Layout */}\n      <div className=\"w-full\">\n        <div className=\"p-4 bg-white border border-gray-300 rounded shadow\">\n          <h3 className=\"font-semibold mb-3 text-lg\">Game Status</h3>\n          <div className=\"grid gap-4\" style={{ gridTemplateColumns: `repeat(${MAX_GAMES}, 1fr)` }}>\n            {gameInstances.map((instance) => {\n              const blueLives = instance.tanks[0]?.lives || 0;\n              const redLives = instance.tanks[1]?.lives || 0;\n              const isAIVsAI = instance.gameType === 'ai-vs-ai';\n              const isPersonVsAI = instance.gameType === 'person-vs-ai';\n              \n              // Calculate active duration\n              // Show N/A if training hasn't started or game hasn't started yet\n              const hasStarted = training.isTraining && instance.episodeStartTime;\n              let durationSeconds = 0;\n              \n              if (hasStarted) {\n                durationSeconds = Math.floor((currentTime - instance.episodeStartTime) / 1000);\n              }\n              \n              const formatDuration = (seconds: number) => {\n                const mins = Math.floor(seconds / 60);\n                const secs = seconds % 60;\n                return `${mins}:${secs.toString().padStart(2, '0')}`;\n              };\n              \n              return (\n                <div key={instance.id} className=\"border border-gray-200 rounded p-3\">\n                  <div className=\"flex items-center justify-between mb-2\">\n                    <div className=\"font-semibold text-sm\">Game {instance.id + 1}</div>\n                    <div className={`text-xs px-2 py-1 rounded ${\n                      isPersonVsAI \n                        ? 'bg-green-100 text-green-700' \n                        : 'bg-blue-100 text-blue-700'\n                    }`}>\n                      {isPersonVsAI ? 'Person vs AI' : 'AI vs AI'}\n                    </div>\n                  </div>\n                  <div className=\"space-y-1 text-xs\">\n                    <div className=\"flex justify-between\">\n                      <span className=\"text-gray-600\">Status:</span>\n                      <span className={`font-semibold ${training.isTraining ? 'text-green-600' : 'text-gray-400'}`}>\n                        {training.isTraining ? 'Active' : 'Paused'}\n                      </span>\n                    </div>\n                    <div className=\"flex justify-between\">\n                      <span className=\"text-gray-600\">Duration:</span>\n                      <span className=\"font-mono font-semibold text-gray-700\">\n                        {hasStarted ? formatDuration(durationSeconds) : 'N/A'}\n                      </span>\n                    </div>\n                    <div className=\"flex justify-between\">\n                      <span className=\"text-blue-600\">Blue Lives:</span>\n                      <span className=\"font-mono font-semibold\">{blueLives}</span>\n                    </div>\n                    <div className=\"flex justify-between\">\n                      <span className=\"text-red-600\">Red Lives:</span>\n                      <span className=\"font-mono font-semibold\">{redLives}</span>\n                    </div>\n                    {training.stats && (\n                      <div className=\"flex justify-between\">\n                        <span className=\"text-gray-600\">Model:</span>\n                        <span className=\"font-semibold text-blue-600\">v{Math.floor((training.stats.episode || 0) / MAX_GAMES) + 1}</span>\n                      </div>\n                    )}\n                    {instance.gameOverWinner && (\n                      <div className=\"mt-1 pt-1 border-t border-gray-200\">\n                        <span className=\"text-gray-600\">Winner: </span>\n                        <span className={`font-semibold ${instance.gameOverWinner === 'blue' ? 'text-blue-600' : 'text-red-600'}`}>\n                          {instance.gameOverWinner.toUpperCase()}\n                        </span>\n                      </div>\n                    )}\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n        </div>\n      </div>\n\n      {/* Main Content - Games Grid */}\n      {!isHeadlessMode && (\n      <div className=\"w-full\">\n        <div \n          className=\"grid gap-4\" \n          style={{ \n            gridTemplateColumns: `repeat(${gridCols}, 1fr)`,\n          }}\n        >\n          {gameInstances.map((instance) => {\n            const keysRef = getKeysRef(instance.id);\n            const isPersonGame = instance.gameType === 'person-vs-ai';\n            // Calculate scaled canvas size (internal resolution is 2x, then apply scale)\n            const scaledWidth = typedMapData.width * 2 * scale;\n            const scaledHeight = typedMapData.height * 2 * scale;\n            \n            const isUserPlaying = userPlayingGameId === instance.id;\n            \n            return (\n              <div \n                key={instance.id} \n                className={`border rounded p-2 bg-gray-50 relative flex flex-col items-center ${\n                  isUserPlaying ? 'border-blue-600 border-2' : 'border-gray-300'\n                }`}\n                style={{ \n                  height: `${scaledHeight + 60}px`, // Fixed height: Canvas height + padding + header (prevents scroll on game end)\n                  minHeight: `${scaledHeight + 60}px`,\n                  maxHeight: `${scaledHeight + 60}px`,\n                  overflow: 'hidden', // Prevent content from expanding beyond fixed height\n                }}\n              >\n                  <div className=\"flex items-center justify-between mb-1 w-full\" style={{ width: `${scaledWidth}px` }}>\n                    <div className=\"flex items-center gap-2\">\n                      <span className=\"text-xs font-bold text-gray-700\">\n                        ID: {instance.id + 1}\n                      </span>\n                      \n                          <span className=\"text-xs px-2 py-0.5 bg-gray-100 text-gray-700 rounded font-medium\">\n                            Game {instance.episodeNumber} / {(training.stats?.episode || 0) + MAX_GAMES}\n                          </span>\n                     \n                    </div>\n                    {!isPersonGame && (\n                      <div className=\"relative\">\n                        <button\n                          onClick={() => {\n                            // Only allow joining if not already in a different game\n                            if (userPlayingGameId === null || userPlayingGameId === instance.id) {\n                              replaceWithPersonGame(instance.id);\n                            }\n                          }}\n                          className={`text-xs px-2 py-1 rounded font-medium transition-colors ${\n                            !training.isTraining || (userPlayingGameId !== null && userPlayingGameId !== instance.id)\n                              ? 'bg-gray-300 text-gray-500 cursor-not-allowed opacity-60'\n                              : 'bg-green-100 text-green-700 hover:bg-green-200 cursor-pointer'\n                          }`}\n                          disabled={!training.isTraining || (userPlayingGameId !== null && userPlayingGameId !== instance.id)}\n                        >\n                          {userPlayingGameId === instance.id ? 'You are playing' : 'Join Game'}\n                        </button>\n                      </div>\n                    )}\n                    {isPersonGame && (\n                      <button\n                        onClick={() => replaceWithAIGame(instance.id)}\n                        className=\"text-xs px-2 py-1 bg-orange-200 text-orange-700 rounded hover:bg-orange-300 font-medium\"\n                      >\n                        Make AI vs AI\n                      </button>\n                    )}\n                  </div>\n                  {!training.isTraining && (\n                    <div className=\"absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-10 rounded\">\n                      <div className=\"text-white text-sm\">Training paused</div>\n                    </div>\n                  )}\n                  {/* Properly scaled canvas container - fixed size to prevent layout shifts */}\n                  <div \n                    className=\"flex justify-center items-center overflow-hidden\"\n                    style={{\n                      width: `${scaledWidth}px`,\n                      height: `${scaledHeight}px`,\n                    }}\n                  >\n                    <GameCanvas\n                      width={typedMapData.width}\n                      height={typedMapData.height}\n                      tanks={instance.tanks}\n                      bullets={instance.bullets}\n                      barriers={barriers}\n                      suns={suns}\n                      isPaused={!training.isTraining}\n                      tankImages={tankImages}\n                      gameOverWinner={instance.gameOverWinner}\n                      scale={scale}\n                    />\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n      </div>\n      )}\n      {isHeadlessMode && (\n        <div className=\"w-full p-8 bg-gray-100 border border-gray-300 rounded text-center\">\n          <div className=\"text-lg font-semibold text-gray-700 mb-2\">Headless Training Mode Active</div>\n          <div className=\"text-sm text-gray-600 mb-4\">\n            Running {activeGamesCount} games simultaneously (no rendering for better performance)\n          </div>\n          <div className=\"text-sm text-gray-600\">\n            Auto-save: {autoSaveCount > 0 ? `${autoSaveCount} model(s) saved` : 'Waiting for first save...'}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8141, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/components/PlayYourAI.tsx"],"sourcesContent":["'use client';\n\nimport React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\nimport mapDataJson from '@/content/games/tank-trouble-map.json';\nimport type { Tank, Bullet, TankTroubleMapData, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport {\n  isObject,\n  isNumber,\n  isArray,\n  hasPropertyOfType,\n  parseAndValidate,\n} from '@/lib/type-guards';\n\n// Type guard for TankTroubleMapData\nfunction isTankTroubleMapData(data: unknown): data is TankTroubleMapData {\n  if (!isObject(data)) {\n    return false;\n  }\n  \n  return (\n    hasPropertyOfType(data, 'width', isNumber) &&\n    hasPropertyOfType(data, 'height', isNumber) &&\n    hasPropertyOfType(data, 'barriers', (val): val is Barrier[] => isArray(val)) &&\n    hasPropertyOfType(data, 'spawnPoints', (val): val is Array<{ x: number; y: number; angle: number }> => isArray(val)) &&\n    (!('suns' in data) || hasPropertyOfType(data, 'suns', (val): val is Sun[] => isArray(val)))\n  );\n}\n\n// Validate and construct map data without type assertions\nfunction validateMapData(data: unknown): TankTroubleMapData {\n  const parsed = parseAndValidate(\n    data,\n    isTankTroubleMapData,\n    'Invalid map data structure: missing or invalid required properties'\n  );\n  \n  return {\n    width: parsed.width,\n    height: parsed.height,\n    barriers: parsed.barriers,\n    spawnPoints: parsed.spawnPoints,\n    suns: parsed.suns || [],\n  };\n}\n\nconst mapData: TankTroubleMapData = validateMapData(mapDataJson);\n\nimport { useGameInput } from '@/app/games/tank-trouble/hooks/useGameInput';\nimport { useTankImages } from '@/app/games/tank-trouble/hooks/useTankImages';\nimport { useMultiGameLogic, type GameInstance as GameLogicInstance } from '@/app/games/tank-trouble/components/GameLogic';\nimport { GameCanvas } from '@/app/games/tank-trouble/components/GameCanvas';\nimport { getInitialSpawnPositions } from '@/app/games/tank-trouble/utils/spawn';\nimport { DEFAULT_AI_CONFIG, type AIConfig, rlModelManager } from '@/app/games/tank-trouble/ai-tank';\nimport { DQNAgent, DEFAULT_DQN_CONFIG } from '@/app/games/tank-trouble/ai-tank/rl-dqn-model';\nimport { TensorFlowJSModel, type ExtendedRLModel } from '@/app/games/tank-trouble/ai-tank/rl-model';\n// import { listSavedModels, type SavedModel } from '@/app/games/tank-trouble/ai-tank/rl-model-storage'; // Commented out - using Supabase instead\nimport { TICK_INTERVAL } from '@/app/games/tank-trouble/config';\n\ninterface PlayYourAIProps {\n  onBack: () => void;\n}\n\nexport function PlayYourAI({ onBack }: PlayYourAIProps) {\n  const typedMapData = mapData;\n  const barriers = typedMapData.barriers || [];\n  const suns = typedMapData.suns || [];\n  const aiConfig = DEFAULT_AI_CONFIG;\n\n  // Model loading from Supabase\n  const [isLoadingModel, setIsLoadingModel] = useState(false);\n  const [isModelLoaded, setIsModelLoaded] = useState(false);\n  const [modelError, setModelError] = useState<string | null>(null);\n  const [dqnAgent, setDqnAgent] = useState<DQNAgent | null>(null);\n\n  // Game state\n  const [tanks, setTanks] = useState<Tank[]>(() => {\n    const initialTanks = getInitialSpawnPositions(typedMapData, barriers, suns);\n    return initialTanks;\n  });\n  const [bullets, setBullets] = useState<Bullet[]>([]);\n  const [lastShotTimes, setLastShotTimes] = useState<{ blue: number; red: number }>({ blue: 0, red: 0 });\n  const [gameOverWinner, setGameOverWinner] = useState<'blue' | 'red' | null>(null);\n  const [isPaused, setIsPaused] = useState(false);\n\n  const tankImages = useTankImages();\n  const gameInput = useGameInput({ gameOver: gameOverWinner !== null });\n\n  // Load latest model from Supabase\n  const loadLatestModelFromSupabase = useCallback(async () => {\n    setIsLoadingModel(true);\n    setModelError(null);\n    setIsModelLoaded(false);\n\n    try {\n      // Initialize DQN agent if not already done\n      let agentToUse = dqnAgent;\n      if (!agentToUse) {\n        const agent = new DQNAgent(DEFAULT_DQN_CONFIG);\n        await agent.initialize();\n        setDqnAgent(agent);\n        agentToUse = agent;\n        \n        // Set up model for game controller\n        const model = new TensorFlowJSModel({\n          name: 'TankTroubleRL',\n          type: 'discrete',\n          observationSize: DEFAULT_DQN_CONFIG.observationSize,\n          actionSize: DEFAULT_DQN_CONFIG.actionSize,\n        });\n        \n        const extendedModel: ExtendedRLModel = {\n          isLoaded: () => {\n            // Agent is initialized after initialize() is called above\n            return true;\n          },\n          load: async (path: string) => {\n            // This is a placeholder - we load weights directly from Supabase\n            // The path parameter is not used when loading from Supabase\n            if (agentToUse) {\n              await agentToUse.load(path);\n            }\n          },\n          getInfo: () => model.getInfo(),\n          agent: agentToUse,\n          predict: (obs, angle) => {\n            // Synchronous wrapper - actual prediction happens in game loop\n            return {\n              angleDelta: 0,\n              moveDirection: 0,\n              shouldShoot: false,\n            };\n          },\n        };\n        \n        rlModelManager.setModel(extendedModel);\n      }\n\n      // Ensure we have an agent at this point\n      if (!agentToUse) {\n        throw new Error('Failed to initialize DQN agent');\n      }\n\n      // Fetch latest model from API\n      const response = await fetch('/api/backend/models/latest');\n      \n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));\n        throw new Error(errorData.error || `Failed to fetch model: ${response.statusText}`);\n      }\n\n      const modelData = await response.json();\n      \n      // Convert Supabase format to TensorFlow.js format\n      // Supabase format: { layers: [{ weights: number[], biases: number[] }, ...], metadata: {...} }\n      // We need: Array<{ weights: number[], biases: number[] }>\n      const weightsData = modelData.layers.map((layer: any) => ({\n        weights: layer.weights || layer.Weights || [],\n        biases: layer.biases || layer.Biases || [],\n      }));\n\n      // Load weights into the agent\n      await agentToUse.loadWeightsFromJSON(weightsData);\n      \n      setIsModelLoaded(true);\n      console.log('Successfully loaded latest model from Supabase', modelData.metadata);\n    } catch (error) {\n      console.error('Failed to load model from Supabase:', error);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      setModelError(errorMessage);\n      setIsModelLoaded(false);\n    } finally {\n      setIsLoadingModel(false);\n    }\n  }, [dqnAgent]);\n\n  // Auto-load latest model on mount\n  useEffect(() => {\n    loadLatestModelFromSupabase();\n  }, [loadLatestModelFromSupabase]);\n\n  // Reset game\n  const resetGame = useCallback(() => {\n    const initialTanks = getInitialSpawnPositions(typedMapData, barriers, suns);\n    setTanks(initialTanks);\n    setBullets([]);\n    setLastShotTimes({ blue: 0, red: 0 });\n    setGameOverWinner(null);\n    setIsPaused(false);\n  }, [typedMapData, barriers, suns]);\n\n  // Game logic instance\n  const gameLogicInstance: GameLogicInstance = useMemo(() => ({\n    id: 0,\n    tanks,\n    bullets,\n    lastShotTimes,\n    gameMode: 'person-vs-ai',\n    gameId: 'play-ai-game',\n    isPaused,\n    speedMultiplier: 1,\n    episodeStartTime: Date.now(),\n    keysRef: gameInput.keysRef,\n  }), [tanks, bullets, lastShotTimes, isPaused, gameInput.keysRef]);\n\n  // No timeout in PlayYourAI mode - games can run indefinitely since we're not training\n  const maxEpisodeTimeMs = Number.MAX_SAFE_INTEGER;\n\n  const gameLogic = useMultiGameLogic({\n    mapData: typedMapData,\n    barriers,\n    suns,\n    aiConfig,\n    trainingManager: null, // No training in play mode\n    maxEpisodeTimeMs,\n    gameInstances: [gameLogicInstance],\n    onTanksUpdate: (gameId, updatedTanks) => {\n      setTanks(updatedTanks);\n      \n      // Check for game over\n      if (updatedTanks[0]?.lives <= 0 || updatedTanks[1]?.lives <= 0) {\n        const winner = updatedTanks[0]?.lives <= 0 ? 'red' : 'blue';\n        setGameOverWinner(winner);\n      }\n    },\n    onBulletsUpdate: (gameId, updatedBullets) => {\n      setBullets(updatedBullets);\n    },\n    onLastShotTimesUpdate: (gameId, times) => {\n      setLastShotTimes(times);\n    },\n    onGameOver: (gameId, winner) => {\n      setGameOverWinner(winner);\n    },\n  });\n\n  // Game loop\n  useEffect(() => {\n    if (isPaused || !isModelLoaded || gameOverWinner !== null) {\n      return;\n    }\n\n    let lastTickTime = Date.now();\n    const gameLoop = () => {\n      const now = Date.now();\n      if (now - lastTickTime >= TICK_INTERVAL) {\n        gameLogic.gameTick({ skipIntervalCheck: false });\n        lastTickTime = now;\n      }\n      requestAnimationFrame(gameLoop);\n    };\n\n    const frameId = requestAnimationFrame(gameLoop);\n    return () => cancelAnimationFrame(frameId);\n  }, [isPaused, isModelLoaded, gameOverWinner, gameLogic]);\n\n  // Handle pause\n  useEffect(() => {\n    const handleKeyPress = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        setIsPaused(prev => !prev);\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyPress);\n    return () => window.removeEventListener('keydown', handleKeyPress);\n  }, []);\n\n  const scale = 1.0; // Full size for play mode\n\n  return (\n    <div className=\"flex flex-col items-center gap-4 w-full p-4\">\n      {/* Header */}\n      <div className=\"w-full max-w-4xl flex items-center justify-between\">\n        <h1 className=\"text-2xl font-bold\">Play Your AI</h1>\n        <button\n          onClick={onBack}\n          className=\"px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300\"\n        >\n          Back to Training\n        </button>\n      </div>\n\n      {/* Model Loading Status */}\n      <div className=\"w-full max-w-4xl p-4 bg-white border border-gray-300 rounded shadow\">\n        <div className=\"flex items-center gap-4\">\n          <label className=\"text-sm font-semibold\">AI Model:</label>\n          {isLoadingModel ? (\n            <span className=\"text-sm text-gray-600\">Loading latest model from Supabase...</span>\n          ) : isModelLoaded ? (\n            <span className=\"text-sm text-green-600\"> Latest model loaded from Supabase</span>\n          ) : modelError ? (\n            <div className=\"flex flex-col gap-1\">\n              <span className=\"text-sm text-red-600\"> Failed to load model</span>\n              <span className=\"text-xs text-gray-500\">{modelError}</span>\n              <button\n                onClick={loadLatestModelFromSupabase}\n                className=\"mt-2 px-3 py-1 text-xs bg-blue-500 text-white rounded hover:bg-blue-600\"\n              >\n                Retry\n              </button>\n            </div>\n          ) : (\n            <span className=\"text-sm text-gray-600\">Ready to load</span>\n          )}\n        </div>\n        {/* Commented out: IndexedDB model selection\n        <div className=\"flex items-center gap-4\">\n          <label className=\"text-sm font-semibold\">Select AI Model:</label>\n          <select\n            value={selectedModel}\n            onChange={(e) => setSelectedModel(e.target.value)}\n            className=\"px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500\"\n            disabled={isLoadingModels}\n          >\n            <option value=\"\">{isLoadingModels ? 'Loading models...' : '-- Select a model --'}</option>\n            {savedModels.map((model) => (\n              <option key={model.path} value={model.path}>\n                {model.createdAtString}{model.evalScore !== undefined ? ` (Eval: ${model.evalScore.toFixed(2)})` : ''}\n              </option>\n            ))}\n          </select>\n          {isModelLoaded && (\n            <span className=\"text-sm text-green-600\"> Model loaded</span>\n          )}\n        </div>\n        */}\n      </div>\n\n      {/* Game Info */}\n      <div className=\"w-full max-w-4xl p-4 bg-white border border-gray-300 rounded shadow\">\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex gap-6\">\n            <div>\n              <span className=\"text-sm text-gray-600\">You (Blue): </span>\n              <span className=\"font-semibold text-blue-600\">{tanks[0]?.lives ?? 0} lives</span>\n            </div>\n            <div>\n              <span className=\"text-sm text-gray-600\">AI (Red): </span>\n              <span className=\"font-semibold text-red-600\">{tanks[1]?.lives ?? 0} lives</span>\n            </div>\n          </div>\n          {isPaused && (\n            <div className=\"text-lg font-semibold text-gray-600\">PAUSED (Press ESC to resume)</div>\n          )}\n          {gameOverWinner && (\n            <div className=\"text-lg font-semibold\">\n              {gameOverWinner === 'blue' ? (\n                <span className=\"text-blue-600\">You Win!</span>\n              ) : (\n                <span className=\"text-red-600\">AI Wins!</span>\n              )}\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Game Canvas */}\n      {isModelLoaded ? (\n        <div className=\"flex justify-center\">\n          <GameCanvas\n            width={typedMapData.width}\n            height={typedMapData.height}\n            tanks={tanks}\n            bullets={bullets}\n            barriers={barriers}\n            suns={suns}\n            isPaused={isPaused}\n            tankImages={tankImages}\n            gameOverWinner={gameOverWinner}\n            scale={scale}\n          />\n        </div>\n      ) : (\n        <div className=\"w-full max-w-4xl p-8 bg-gray-100 border border-gray-300 rounded text-center\">\n          <div className=\"text-lg text-gray-600\">\n            {isLoadingModel ? 'Loading model from Supabase...' : 'Waiting for AI model to load from Supabase'}\n          </div>\n        </div>\n      )}\n\n      {/* Controls */}\n      <div className=\"w-full max-w-4xl p-4 bg-white border border-gray-300 rounded shadow\">\n        <div className=\"text-sm text-gray-600\">\n          <div className=\"font-semibold mb-2\">Controls:</div>\n          <div>Player 1 (Blue - You): Arrow keys to move, Space to shoot</div>\n          <div>Press ESC to pause/resume</div>\n          {gameOverWinner && (\n            <button\n              onClick={resetGame}\n              className=\"mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\"\n            >\n              Play Again\n            </button>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 8717, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/tank-trouble/page.tsx"],"sourcesContent":["'use client';\n\nimport { UnifiedTrainingView } from '@/app/games/tank-trouble/components/UnifiedTrainingView';\nimport { PlayYourAI } from '@/app/games/tank-trouble/components/PlayYourAI';\n\ninterface TankTroublePageProps {\n  view: 'training' | 'play';\n  onViewChange: (view: 'training' | 'play') => void;\n}\n\nexport default function TankTroublePage({ view, onViewChange }: TankTroublePageProps) {\n  if (view === 'play') {\n    return <PlayYourAI onBack={() => onViewChange('training')} />;\n  }\n\n  return <UnifiedTrainingView />;\n}\n\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAHA;;;;AAUe,SAAS,gBAAgB,EAAE,IAAI,EAAE,YAAY,EAAwB;IAClF,IAAI,SAAS,QAAQ;QACnB,qBAAO,+YAAC,qLAAU;YAAC,QAAQ,IAAM,aAAa;;;;;;IAChD;IAEA,qBAAO,+YAAC,uMAAmB;;;;;AAC7B"}},
    {"offset": {"line": 8748, "column": 0}, "map": {"version":3,"sources":["file:///Users/nishant/Documents/software/blog/website/app/games/page.tsx"],"sourcesContent":["'use client';\n\nimport { useEffect, useState } from 'react';\nimport { useRouter } from 'next/navigation';\nimport Sidebar from '@/components/Sidebar';\nimport TankTroublePage from '@/app/games/tank-trouble/page';\n\nexport default function GamesPage() {\n  const router = useRouter();\n  const [tankTroubleView, setTankTroubleView] = useState<'training' | 'play'>('training');\n\n  useEffect(() => {\n    // Check if we're on mobile (width < 768px)\n    const checkMobile = () => {\n      if (window.innerWidth < 768) {\n        router.push('/');\n      }\n    };\n\n    checkMobile();\n    window.addEventListener('resize', checkMobile);\n\n    return () => window.removeEventListener('resize', checkMobile);\n  }, [router]);\n\n  return (\n    <div className=\"min-h-screen bg-[#F7FAFC]\">\n      <div className=\"flex flex-col md:flex-row pt-[60px] md:pt-0\">\n        <Sidebar />\n        \n        {/* Main Content */}\n        <main className=\"flex-1 max-w-6xl mx-auto px-4 md:px-8 py-8 w-full\">\n          <header className=\"mb-8 flex justify-end\">\n            <div className=\"text-right\">\n              <div className=\"text-base text-[#4A5568]\">Nishant Iyengar</div>\n              <div className=\"text-sm text-[#718096] mt-1\">iyengar.nish@gmail.com</div>\n            </div>\n          </header>\n          \n          <div className=\"space-y-8\">\n            <h1 className=\"text-3xl font-bold text-[#4A5568]\">Games</h1>\n            \n            <div className=\"space-y-6\">\n              <div>\n                <div className=\"flex items-center gap-4 mb-4\">\n                  <h2 className=\"text-xl font-semibold text-[#4A5568]\">Tank Trouble</h2>\n                  {tankTroubleView === 'training' && (\n                    <button\n                      onClick={() => setTankTroubleView('play')}\n                      className=\"px-4 py-2 bg-green-200 text-white rounded hover:bg-green-300 font-medium shadow-lg\"\n                    >\n                      Play your AI\n                    </button>\n                  )}\n                </div>\n                <TankTroublePage view={tankTroubleView} onViewChange={setTankTroubleView} />\n              </div>\n            </div>\n          </div>\n        </main>\n      </div>\n    </div>\n  );\n}\n\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AALA;;;;;;AAOe,SAAS;IACtB,MAAM,SAAS,IAAA,gTAAS;IACxB,MAAM,CAAC,iBAAiB,mBAAmB,GAAG,IAAA,kXAAQ,EAAsB;IAE5E,IAAA,mXAAS,EAAC;QACR,2CAA2C;QAC3C,MAAM,cAAc;YAClB,IAAI,OAAO,UAAU,GAAG,KAAK;gBAC3B,OAAO,IAAI,CAAC;YACd;QACF;QAEA;QACA,OAAO,gBAAgB,CAAC,UAAU;QAElC,OAAO,IAAM,OAAO,mBAAmB,CAAC,UAAU;IACpD,GAAG;QAAC;KAAO;IAEX,qBACE,+YAAC;QAAI,WAAU;kBACb,cAAA,+YAAC;YAAI,WAAU;;8BACb,+YAAC,4IAAO;;;;;8BAGR,+YAAC;oBAAK,WAAU;;sCACd,+YAAC;4BAAO,WAAU;sCAChB,cAAA,+YAAC;gCAAI,WAAU;;kDACb,+YAAC;wCAAI,WAAU;kDAA2B;;;;;;kDAC1C,+YAAC;wCAAI,WAAU;kDAA8B;;;;;;;;;;;;;;;;;sCAIjD,+YAAC;4BAAI,WAAU;;8CACb,+YAAC;oCAAG,WAAU;8CAAoC;;;;;;8CAElD,+YAAC;oCAAI,WAAU;8CACb,cAAA,+YAAC;;0DACC,+YAAC;gDAAI,WAAU;;kEACb,+YAAC;wDAAG,WAAU;kEAAuC;;;;;;oDACpD,oBAAoB,4BACnB,+YAAC;wDACC,SAAS,IAAM,mBAAmB;wDAClC,WAAU;kEACX;;;;;;;;;;;;0DAKL,+YAAC,8JAAe;gDAAC,MAAM;gDAAiB,cAAc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQtE"}}]
}