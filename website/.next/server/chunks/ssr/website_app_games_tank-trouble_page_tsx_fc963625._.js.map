{"version":3,"sources":["../../../../../website/app/games/tank-trouble/components/UnifiedTrainingView.tsx","../../../../../website/lib/type-guards.ts","../../../../../website/app/games/tank-trouble/hooks/useGameInput.ts","../../../../../website/app/games/tank-trouble/hooks/useTankImages.ts","../../../../../website/app/games/tank-trouble/config.ts","../../../../../website/lib/physics.ts","../../../../../website/app/games/tank-trouble/constants/game-constants.ts","../../../../../website/app/games/tank-trouble/utils/collision.ts","../../../../../website/app/games/tank-trouble/utils/math.ts","../../../../../website/app/games/tank-trouble/utils/bullet-creation.ts","../../../../../website/app/games/tank-trouble/utils/tank-utils.ts","../../../../../website/app/games/tank-trouble/utils/bullet-optimization.ts","../../../../../website/app/games/tank-trouble/utils/tank.ts","../../../../../website/app/games/tank-trouble/utils/bullet.ts","../../../../../website/app/games/tank-trouble/utils/spawn.ts","../../../../../website/app/games/tank-trouble/ai-tank/prediction.ts","../../../../../website/app/games/tank-trouble/ai-tank/threat-assessment.ts","../../../../../website/app/games/tank-trouble/ai-tank/sun-calculations.ts","../../../../../website/app/games/tank-trouble/ai-tank/navigation.ts","../../../../../website/app/games/tank-trouble/ai-tank/rl-action-config.ts","../../../../../website/app/games/tank-trouble/ai-tank/rl-actions.ts","../../../../../website/app/games/tank-trouble/ai-tank/rl-observation.ts","../../../../../website/app/games/tank-trouble/ai-tank/rl-model.ts","../../../../../website/app/games/tank-trouble/ai-tank/controller.ts","../../../../../website/app/games/tank-trouble/ai-tank/config.ts","../../../../../website/app/games/tank-trouble/ai-tank/rl-reward-config.ts","../../../../../website/app/games/tank-trouble/ai-tank/rl-reward.ts","../../../../../website/app/games/tank-trouble/ai-tank/rl-environment.ts","../../../../../website/app/games/tank-trouble/ai-tank/rl-training-example.ts","../../../../../website/app/games/tank-trouble/ai-tank/index.ts","../../../../../website/app/games/tank-trouble/components/GameLogic.tsx","../../../../../website/app/games/tank-trouble/components/GameCanvas.tsx","../../../../../website/app/games/tank-trouble/ai-tank/rl-dqn-model.ts","../../../../../website/app/games/tank-trouble/ai-tank/rl-replay-buffer.ts","../../../../../website/app/games/tank-trouble/ai-tank/rl-training-manager.ts","../../../../../website/app/games/tank-trouble/ai-tank/rl-training-hook.ts","../../../../../website/app/games/tank-trouble/components/PlayYourAI.tsx","../../../../../website/app/games/tank-trouble/page.tsx"],"sourcesContent":["/**\n * Unified Training View\n * \n * Single interface for all training modes: AI vs AI and Person vs AI\n * Supports up to 4 games simultaneously with stats and model summary\n */\n\n'use client';\n\nimport React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';\n\n// Component to update stats reactively (no polling)\nfunction StatsDebouncer({ \n  stats, \n  onUpdate \n}: { \n  stats: { episodeReward: number; episodeLength: number }; \n  onUpdate: (stats: { episodeReward: number; episodeLength: number }) => void;\n}) {\n  const prevStatsRef = useRef<{ episodeReward: number; episodeLength: number } | null>(null);\n  \n  // Update reactively when stats change (no artificial delays)\n  useEffect(() => {\n    const prev = prevStatsRef.current;\n    // Only update if values actually changed\n    if (!prev || prev.episodeReward !== stats.episodeReward || prev.episodeLength !== stats.episodeLength) {\n      prevStatsRef.current = stats;\n      onUpdate(stats);\n    }\n  }, [stats.episodeReward, stats.episodeLength, onUpdate]);\n  \n  return null;\n}\nimport mapDataJson from '@/shared/content/games/tank-trouble-map.json';\nimport type { Tank, Bullet, TankTroubleMapData, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport {\n  isObject,\n  isNumber,\n  isArray,\n  hasPropertyOfType,\n  parseAndValidate,\n  isError,\n} from '@/lib/type-guards';\n\n// Type guard for TankTroubleMapData\nfunction isTankTroubleMapData(data: unknown): data is TankTroubleMapData {\n  if (!isObject(data)) {\n    return false;\n  }\n  \n  return (\n    hasPropertyOfType(data, 'width', isNumber) &&\n    hasPropertyOfType(data, 'height', isNumber) &&\n    hasPropertyOfType(data, 'barriers', (val): val is Barrier[] => isArray(val)) &&\n    hasPropertyOfType(data, 'spawnPoints', (val): val is Array<{ x: number; y: number; angle: number }> => isArray(val)) &&\n    (!('suns' in data) || hasPropertyOfType(data, 'suns', (val): val is Sun[] => isArray(val)))\n  );\n}\n\n// Validate and construct map data without type assertions\nfunction validateMapData(data: unknown): TankTroubleMapData {\n  const parsed = parseAndValidate(\n    data,\n    isTankTroubleMapData,\n    'Invalid map data structure: missing or invalid required properties'\n  );\n  \n  return {\n    width: parsed.width,\n    height: parsed.height,\n    barriers: parsed.barriers,\n    spawnPoints: parsed.spawnPoints,\n    suns: parsed.suns || [],\n  };\n}\n\nconst mapData: TankTroubleMapData = validateMapData(mapDataJson);\nimport { useGameInput } from '@/app/games/tank-trouble/hooks/useGameInput';\nimport { useTankImages } from '@/app/games/tank-trouble/hooks/useTankImages';\nimport { useMultiGameLogic, type GameInstance as GameLogicInstance } from '@/app/games/tank-trouble/components/GameLogic';\nimport { GameCanvas } from '@/app/games/tank-trouble/components/GameCanvas';\nimport { getInitialSpawnPositions } from '@/app/games/tank-trouble/utils/spawn';\nimport { DEFAULT_AI_CONFIG, type AIConfig, rlModelManager } from '@/app/games/tank-trouble/ai-tank';\nimport { useRLTraining } from '@/app/games/tank-trouble/ai-tank/rl-training-hook';\nimport { listSavedModels, type SavedModel } from '@/app/games/tank-trouble/ai-tank/rl-model-storage';\nimport { DQNAgent } from '@/app/games/tank-trouble/ai-tank/rl-dqn-model';\nimport { TensorFlowJSModel, type ExtendedRLModel } from '@/app/games/tank-trouble/ai-tank/rl-model';\nimport type { Observation } from '@/app/games/tank-trouble/ai-tank/rl-observation';\nimport type { AIDecision } from '@/app/games/tank-trouble/ai-tank/types';\nimport { MAX_EPISODE_TIME_MS } from '@/app/games/tank-trouble/constants/game-constants';\n// import { TrainingDictionary } from './TrainingDictionary';\n\ninterface GameInstance {\n  id: number;\n  tanks: Tank[];\n  bullets: Bullet[];\n  lastShotTimes: { blue: number; red: number };\n  gameOverWinner: 'blue' | 'red' | null;\n  episodeReward: number;\n  episodeLength: number;\n  episodeStartTime: number;\n  gameType: 'ai-vs-ai' | 'person-vs-ai';\n  episodeNumber: number; // Current episode number for this game instance\n}\n\ninterface GameStats {\n  totalGames: number;\n  aiVsAiGames: number;\n  personVsAiGames: number;\n}\n\n// Speed multiplier for AI vs AI games (1x speed for normal training)\nconst AI_VS_AI_SPEED_MULTIPLIER = 1;\n\n// Configuration: Number of simultaneous games to train\nconst MAX_GAMES = 4;\nconst MAX_GAMES_HEADLESS = 8; // More games in headless mode since we're not rendering\nconst AUTO_SAVE_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes\n\nexport function UnifiedTrainingView() {\n  const typedMapData = mapData;\n  \n  // These are static values from map data, so use constants instead of refs\n  // Refs should only be used for values that change and shouldn't trigger re-renders\n  const barriers = typedMapData.barriers || [];\n  const suns: Sun[] = []; // Suns removed from map - always use empty array\n  const aiConfig = DEFAULT_AI_CONFIG;\n  \n  // Headless training mode\n  const [isHeadlessMode, setIsHeadlessMode] = useState(false);\n  const [autoSaveCount, setAutoSaveCount] = useState(0);\n  const autoSaveIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  \n  // Use more games in headless mode since we're not rendering\n  const maxGames = isHeadlessMode ? MAX_GAMES_HEADLESS : MAX_GAMES;\n\n  // Game statistics\n  const [gameStats, setGameStats] = useState<GameStats>({\n    totalGames: 0,\n    aiVsAiGames: 0,\n    personVsAiGames: 0,\n  });\n  \n  // Track total games started (including incomplete ones)\n  // Starts at MAX_GAMES because we have MAX_GAMES games running initially\n  const [totalGamesStarted, setTotalGamesStarted] = useState(MAX_GAMES);\n\n  // Model selection\n  const [savedModels, setSavedModels] = useState<SavedModel[]>([]);\n  const [selectedModel, setSelectedModel] = useState<string>('');\n  const [isLoadingModels, setIsLoadingModels] = useState(false);\n  const selectedModelRef = useRef<string>('');\n  \n  // Dictionary visibility (commented out - using separate component)\n  // const [isDictionaryVisible, setIsDictionaryVisible] = useState(true);\n  \n  // Debounced stats for display (update every 5 seconds)\n  const [displayStats, setDisplayStats] = useState<{ reward: number; length: number } | null>(null);\n  \n  // Memoize the update callback to prevent recreation\n  const handleDisplayStatsUpdate = useCallback((stats: { episodeReward: number; episodeLength: number }) => {\n    setDisplayStats((prev) => {\n      // Only update if values actually changed\n      if (!prev || prev.reward !== stats.episodeReward || prev.length !== stats.episodeLength) {\n        return { reward: stats.episodeReward, length: stats.episodeLength };\n      }\n      return prev;\n    });\n  }, []);\n\n  // Track which game the user is playing (only one at a time)\n  const [userPlayingGameId, setUserPlayingGameId] = useState<number | null>(null);\n\n  // Ref to track next episode number atomically (prevents race conditions when multiple games end simultaneously)\n  const nextEpisodeNumberRef = useRef(MAX_GAMES + 1); // Start at MAX_GAMES + 1 (will be updated when headless mode changes)\n\n  // Track current time for duration calculations\n  const [currentTime, setCurrentTime] = useState(Date.now());\n\n  // Update current time every second for duration display\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setCurrentTime(Date.now());\n    }, 1000); // Update every second\n    \n    return () => clearInterval(interval);\n  }, []);\n\n  // Create game instances (start with MAX_GAMES AI vs AI games, will expand to MAX_GAMES_HEADLESS in headless mode)\n  const [gameInstances, setGameInstances] = useState<GameInstance[]>(() => {\n    const instances = Array.from({ length: MAX_GAMES }, (_, i) => {\n      const initialTanks = getInitialSpawnPositions(typedMapData, barriers, suns);\n      \n      return {\n        id: i,\n        tanks: initialTanks,\n        bullets: [],\n        lastShotTimes: { blue: 0, red: 0 },\n        gameOverWinner: null,\n        episodeReward: 0,\n        episodeLength: 0,\n        episodeStartTime: Date.now(),\n        gameType: 'ai-vs-ai' as const,\n        episodeNumber: i + 1, // Start at ID + 1 (Game 1, Game 2, Game 3, Game 4)\n      };\n    });\n    \n    return instances;\n  });\n\n  // Shared training manager\n  const training = useRLTraining({\n    episodes: 1000,\n    trainEvery: 4,\n    saveEvery: 100,\n    selfPlay: true,\n    // TODO: Implement headless mode later - this will allow faster training by skipping rendering\n    // headless: false,\n  });\n\n  // All games are always active (assume all games are always running)\n  const activeGamesCount = gameInstances.length;\n\n  // Sync gameStats.totalGames with training episode count (completed games)\n  useEffect(() => {\n    if (training.stats && training.stats.episode !== undefined) {\n      const completedGames = training.stats.episode;\n      setGameStats((prev) => ({\n        ...prev,\n        totalGames: completedGames,\n      }));\n    }\n  }, [training.stats?.episode]);\n  \n  // Update total games started when a game completes\n  // This includes both completed and incomplete games\n  useEffect(() => {\n    if (training.stats && training.stats.episode !== undefined) {\n      // Total games started = completed games + active games count\n      setTotalGamesStarted(training.stats.episode + activeGamesCount);\n    }\n  }, [training.stats?.episode, activeGamesCount]);\n\n  // Helper function to save model (used by both manual and auto-save)\n  const saveModelHelper = useCallback(async () => {\n    if (!training.manager || !training.canSaveModel()) {\n      return false;\n    }\n\n    try {\n      const episode = training.stats?.episode || 0;\n      const modelVersion = Math.floor(episode / activeGamesCount) + 1;\n      const timestamp = Date.now();\n      const isoString = new Date(timestamp).toISOString();\n      const modelPath = `indexeddb://tank-ai-${timestamp}`;\n      const evalScore = training.stats?.averageReward;\n\n      // COMMENTED OUT: Frontend training disabled - using backend training service instead\n      // await training.saveModel(modelPath, evalScore, isoString);\n      \n      // await new Promise(resolve => setTimeout(resolve, 500));\n      \n      // const models = await listSavedModels();\n      // setSavedModels(models);\n      // setAutoSaveCount(prev => prev + 1);\n      return true;\n    } catch (error) {\n      console.error('Error auto-saving model:', error);\n      return false;\n    }\n  }, [training, activeGamesCount]);\n\n  // Auto-save interval for headless mode\n  useEffect(() => {\n    if (isHeadlessMode && training.isTraining) {\n      // Clear any existing interval\n      if (autoSaveIntervalRef.current) {\n        clearInterval(autoSaveIntervalRef.current);\n      }\n      \n      // Set up auto-save every 5 minutes\n      autoSaveIntervalRef.current = setInterval(() => {\n        saveModelHelper();\n      }, AUTO_SAVE_INTERVAL_MS);\n      \n      return () => {\n        if (autoSaveIntervalRef.current) {\n          clearInterval(autoSaveIntervalRef.current);\n        }\n      };\n    } else {\n      // Clear interval when headless mode is disabled or training stops\n      if (autoSaveIntervalRef.current) {\n        clearInterval(autoSaveIntervalRef.current);\n        autoSaveIntervalRef.current = null;\n      }\n    }\n  }, [isHeadlessMode, training.isTraining, saveModelHelper]);\n\n  // Update game instances when headless mode changes\n  useEffect(() => {\n    const targetCount = isHeadlessMode ? MAX_GAMES_HEADLESS : MAX_GAMES;\n    setGameInstances(prev => {\n      if (prev.length === targetCount) {\n        return prev; // No change needed\n      }\n      \n      if (prev.length < targetCount) {\n        // Add more game instances\n        const newInstances = Array.from({ length: targetCount - prev.length }, (_, i) => {\n          const instanceId = prev.length + i;\n          const initialTanks = getInitialSpawnPositions(typedMapData, barriers, suns);\n          return {\n            id: instanceId,\n            tanks: initialTanks,\n            bullets: [],\n            lastShotTimes: { blue: 0, red: 0 },\n            gameOverWinner: null,\n            episodeReward: 0,\n            episodeLength: 0,\n            episodeStartTime: Date.now(),\n            gameType: 'ai-vs-ai' as const,\n            episodeNumber: nextEpisodeNumberRef.current++,\n          };\n        });\n        return [...prev, ...newInstances];\n      } else {\n        // Remove excess game instances (remove from end, but don't remove if user is playing)\n        const instancesToKeep = prev.slice(0, targetCount);\n        // Make sure we don't remove the game the user is playing\n        const userGameIndex = userPlayingGameId !== null \n          ? instancesToKeep.findIndex(gi => gi.id === userPlayingGameId)\n          : -1;\n        \n        if (userGameIndex === -1 && userPlayingGameId !== null) {\n          // User's game would be removed, keep it and remove a different one\n          const userGame = prev.find(gi => gi.id === userPlayingGameId);\n          if (userGame) {\n            const withoutUserGame = prev.filter(gi => gi.id !== userPlayingGameId);\n            const toKeep = withoutUserGame.slice(0, targetCount - 1);\n            return [...toKeep, userGame];\n          }\n        }\n        \n        return instancesToKeep;\n      }\n    });\n  }, [isHeadlessMode, typedMapData, barriers, suns, userPlayingGameId]);\n\n  const tankImages = useTankImages();\n  \n  // Single keyboard input hook - only one game can be personal at a time\n  const activeGameOver = userPlayingGameId !== null ? gameInstances[userPlayingGameId]?.gameOverWinner !== null : false;\n  const gameInput = useGameInput({ gameOver: activeGameOver });\n\n  // Stable empty keys ref for non-user games (created once, reused)\n  const emptyKeysRef = useRef<Set<string>>(new Set<string>());\n  \n  // Use appropriate keys ref based on game type\n  const getKeysRef = useCallback((gameId: number) => {\n    // Only return the keys ref if this is the game the user is playing\n    if (gameId === userPlayingGameId) {\n      return gameInput.keysRef;\n    }\n    return emptyKeysRef;\n  }, [userPlayingGameId, gameInput.keysRef]);\n\n\n  // Replace AI game with person game (user joins as Blue, AI is Red)\n  // Preserves current game state - user takes control of existing blue tank\n  const replaceWithPersonGame = (gameId: number) => {\n    // If user is already playing another game, convert that one back to AI vs AI first\n    if (userPlayingGameId !== null && userPlayingGameId !== gameId) {\n      replaceWithAIGame(userPlayingGameId);\n    }\n    \n    setUserPlayingGameId(gameId);\n    setGameInstances((prev) =>\n      prev.map((gi) =>\n        gi.id === gameId\n          ? {\n              ...gi,\n              gameType: 'person-vs-ai',\n              // Don't reset game state - preserve current tanks, bullets, and game progress\n              // User simply takes control of the existing blue tank\n            }\n          : gi\n      )\n    );\n  };\n\n  // Replace person game with AI game\n  // Preserves current game state - AI simply takes control of the blue tank\n  const replaceWithAIGame = (gameId: number) => {\n    if (userPlayingGameId === gameId) {\n      setUserPlayingGameId(null);\n    }\n    setGameInstances((prev) =>\n      prev.map((gi) =>\n        gi.id === gameId\n          ? {\n              ...gi,\n              gameType: 'ai-vs-ai',\n              // Don't reset game state - preserve current tanks, bullets, and game progress\n              // AI simply takes control of the existing blue tank\n            }\n          : gi\n      )\n    );\n  };\n\n  // Get max episode time from training manager\n  const maxEpisodeTimeMs = training.manager?.getMaxEpisodeTimeMs() || MAX_EPISODE_TIME_MS;\n\n  // Prepare game instances for multi-game logic hook - memoize to avoid recreating on every render\n  // Note: This will still recreate when gameInstances changes (which is frequent during gameplay),\n  // but prevents recreation on unrelated renders (UI state changes, etc.)\n  const gameLogicInstances: GameLogicInstance[] = useMemo(() => {\n    return gameInstances.map((instance) => ({\n      id: instance.id,\n      tanks: instance.tanks,\n      bullets: instance.bullets,\n      lastShotTimes: instance.lastShotTimes,\n      gameMode: instance.gameType === 'person-vs-ai' ? 'person-vs-ai' : 'ai',\n      gameId: `game-${instance.id}`,\n      isPaused: !training.isTraining || (instance.id === userPlayingGameId && gameInput.isPaused),\n      speedMultiplier: instance.gameType === 'ai-vs-ai' ? AI_VS_AI_SPEED_MULTIPLIER : 1,\n      episodeStartTime: instance.episodeStartTime,\n      keysRef: getKeysRef(instance.id), // getKeysRef returns stable refs, safe to call here\n    }));\n  }, [\n    gameInstances,\n    training.isTraining,\n    userPlayingGameId,\n    gameInput.isPaused,\n    getKeysRef, // Now properly memoized with useCallback\n  ]);\n\n  // Single hook call for all games\n  const gameLogic = useMultiGameLogic({\n    mapData: typedMapData,\n    barriers: barriers,\n    suns: suns,\n    aiConfig,\n    trainingManager: training.manager,\n    maxEpisodeTimeMs,\n    gameInstances: gameLogicInstances,\n    onTanksUpdate: (gameId, tanks) => {\n      setGameInstances((prev) => {\n        const updated = prev.map((gi) => {\n          if (gi.id === gameId) {\n            return { ...gi, tanks };\n          }\n          return gi;\n        });\n        return updated;\n      });\n    },\n    onBulletsUpdate: (gameId, bullets) => {\n      setGameInstances((prev) =>\n        prev.map((gi) => (gi.id === gameId ? { ...gi, bullets } : gi))\n      );\n    },\n    onLastShotTimesUpdate: (gameId, times) => {\n      setGameInstances((prev) =>\n        prev.map((gi) => (gi.id === gameId ? { ...gi, lastShotTimes: times } : gi))\n      );\n    },\n    onGameOver: (gameId, winner) => {\n      const newEpisodeNumber = nextEpisodeNumberRef.current++;\n      training.incrementEpisode();\n\n      // Check the game type before resetting (to preserve user control if it's person-vs-ai)\n      const gameBeforeReset = gameInstances.find(gi => gi.id === gameId);\n      const wasPersonVsAI = gameBeforeReset?.gameType === 'person-vs-ai';\n\n      setGameInstances((prev) =>\n        prev.map((gi) => {\n          if (gi.id === gameId) {\n            setGameStats((stats) => ({\n              ...stats,\n              aiVsAiGames: gi.gameType === 'ai-vs-ai' ? stats.aiVsAiGames + 1 : stats.aiVsAiGames,\n              personVsAiGames: gi.gameType === 'person-vs-ai' ? stats.personVsAiGames + 1 : stats.personVsAiGames,\n            }));\n\n            return {\n              ...gi,\n              tanks: getInitialSpawnPositions(typedMapData, barriers, suns),\n              bullets: [],\n              lastShotTimes: { blue: 0, red: 0 },\n              gameOverWinner: null,\n              episodeReward: 0,\n              episodeLength: 0,\n              episodeStartTime: Date.now(),\n              episodeNumber: newEpisodeNumber,\n              // Preserve gameType so user can continue controlling if it was person-vs-ai\n              // gameType is already preserved in the spread (...gi)\n            };\n          }\n          return gi;\n        })\n      );\n\n      // Only clear userPlayingGameId if the game was NOT person-vs-ai\n      // If it was person-vs-ai, the user should keep control for the new episode\n      if (gameId === userPlayingGameId && !wasPersonVsAI) {\n        setUserPlayingGameId(null);\n      }\n      // If wasPersonVsAI is true, keep userPlayingGameId set so controls continue working\n    },\n  });\n\n  // Games are always active - no need to track isActive state\n\n  // Run all game loops (only if training is active)\n  useEffect(() => {\n    if (!training.isTraining) {\n      return;\n    }\n\n    const animationFrames: number[] = [];\n    let lastFrameTime = performance.now();\n    \n    const gameLoop = async (currentTime: number) => {\n      // Tick all games (all games are always active)\n      // Use for...of to support async/await\n      for (const instance of gameInstances) {\n        const isAIVsAI = instance.gameType === 'ai-vs-ai';\n        const speedMultiplier = isAIVsAI ? AI_VS_AI_SPEED_MULTIPLIER : 1;\n        \n        if (isAIVsAI && speedMultiplier > 1) {\n          // For AI vs AI games, run multiple ticks per frame\n          const elapsed = currentTime - lastFrameTime;\n          const targetFrameTime = 1000 / 72; // Target 72 FPS base\n          const ticksToRun = Math.max(1, Math.floor((elapsed / targetFrameTime) * speedMultiplier));\n          \n          for (let i = 0; i < ticksToRun; i++) {\n            await gameLogic.gameTick({ skipIntervalCheck: i > 0, gameId: instance.id });\n          }\n        } else {\n          // Normal speed (one tick per frame)\n          await gameLogic.gameTick({ gameId: instance.id });\n        }\n        \n        // Update episode length reactively\n        if (instance.episodeStartTime) {\n          const elapsed = (Date.now() - instance.episodeStartTime) / 1000;\n          const newEpisodeLength = Math.floor(elapsed * 72);\n          if (instance.episodeLength !== newEpisodeLength) {\n            setGameInstances((prev) =>\n              prev.map((gi) => (gi.id === instance.id ? { ...gi, episodeLength: newEpisodeLength } : gi))\n            );\n          }\n        }\n      }\n      \n      lastFrameTime = currentTime;\n      const frameId = requestAnimationFrame(gameLoop);\n      animationFrames.push(frameId);\n    };\n    \n    const frameId = requestAnimationFrame(gameLoop);\n    animationFrames.push(frameId);\n\n    return () => {\n      animationFrames.forEach((id) => cancelAnimationFrame(id));\n    };\n  }, [training.isTraining, gameLogic, gameInstances]);\n\n  const loadSavedModels = useCallback(async () => {\n    setIsLoadingModels(true);\n    try {\n      const models = await listSavedModels();\n      setSavedModels(models);\n      // Preserve selectedModel if it still exists in the new list\n      if (selectedModelRef.current && !models.some(m => m.path === selectedModelRef.current)) {\n        // If selected model is no longer in the list, keep it selected anyway\n        // (it might have been renamed or the list refresh happened before save completed)\n        // Don't clear it - let the user decide\n      }\n    } catch (error) {\n      console.error('Failed to load models:', error);\n      \n      // Check for Safari/IndexedDB issues\n      const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n      if (isSafari && typeof window.indexedDB === 'undefined') {\n        console.warn('Safari detected with IndexedDB unavailable. This may be due to Private Browsing mode.');\n      }\n    } finally {\n      setIsLoadingModels(false);\n    }\n  }, []);\n\n  // Load saved models on mount\n  useEffect(() => {\n    loadSavedModels();\n  }, [loadSavedModels]);\n\n  // Start training automatically on mount (only once when manager becomes available)\n  // COMMENTED OUT: Frontend training disabled - using backend training service instead\n  // const hasStartedTrainingRef = useRef(false);\n  // useEffect(() => {\n  //   if (!hasStartedTrainingRef.current && !training.isTraining && training.manager) {\n  //     hasStartedTrainingRef.current = true;\n  //     training.startTraining();\n  //   }\n  // }, [training.isTraining, training.manager]);\n\n  // Refresh models when training saves\n  useEffect(() => {\n    if (training.stats && training.stats.episode > 0 && training.stats.episode % 100 === 0) {\n      // Refresh model list when model is saved (every 100 games)\n      // Preserve current selection using ref to avoid stale closure\n      const currentSelection = selectedModelRef.current;\n      loadSavedModels().then(() => {\n        // Restore selection if it still exists\n        if (currentSelection) {\n          setSelectedModel(currentSelection);\n          selectedModelRef.current = currentSelection;\n        }\n      });\n    }\n  }, [training.stats?.episode, loadSavedModels]);\n\n  const handleModelSelect = async (modelPath: string) => {\n    if (!modelPath) return;\n    \n    try {\n      setSelectedModel(modelPath);\n      selectedModelRef.current = modelPath;\n      \n      // Load the model\n      const agent = new DQNAgent();\n      await agent.load(modelPath);\n      \n      // Wrap in model interface\n      const model = new TensorFlowJSModel({\n        name: 'TankTroubleRL',\n        type: 'discrete',\n        observationSize: 142,\n        actionSize: 14,\n      });\n      \n      // Extend model with agent-specific methods\n      // Note: predict must be synchronous to match RLModel interface\n      // The agent's async predict is used in training, not in game loop\n      const extendedModel: ExtendedRLModel = {\n        isLoaded: () => model.isLoaded(),\n        load: (path: string) => model.load(path),\n        getInfo: () => model.getInfo(),\n        agent,\n        predict: (obs: Observation, angle: number): AIDecision => {\n          // Synchronous wrapper - actual async predictions happen in training\n          // For game loop compatibility, return default decision\n          // RL predictions are handled separately in training step\n          return {\n            angleDelta: 0,\n            moveDirection: 0,\n            shouldShoot: false,\n          };\n        },\n      };\n      \n      // Set as active model for AI controller (for playing against AI)\n      rlModelManager.setModel(extendedModel);\n      \n      // Always load the model into the training manager's agent\n      // This allows training to continue from the selected model\n      if (training.manager) {\n        // Extract path without indexeddb:// prefix for loadModel (it adds the prefix)\n        const cleanPath = modelPath.replace('indexeddb://', '');\n        await training.manager.loadModel(cleanPath);\n      }\n      \n      alert('Model loaded successfully! Training will continue from this model.');\n    } catch (error) {\n      console.error('Failed to load model:', error);\n      \n      // Check for Safari/IndexedDB specific issues\n      const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      \n      let userMessage = 'Failed to load model.\\n\\n';\n      \n      if (isSafari) {\n        userMessage += 'Safari detected. Common issues:\\n';\n        userMessage += '• Private Browsing mode disables IndexedDB - try regular browsing mode\\n';\n        userMessage += '• Safari may require user interaction before accessing IndexedDB\\n';\n        userMessage += '• Check Safari settings: Preferences > Privacy > uncheck \"Prevent cross-site tracking\"\\n\\n';\n      }\n      \n      userMessage += `Error: ${errorMessage}\\n\\n`;\n      userMessage += 'Check the browser console for more details.';\n      \n      alert(userMessage);\n    }\n  };\n\n  // Calculate episode length on-demand (no polling)\n  // Episode length is calculated from episodeStartTime when needed\n  // This is done reactively in the game loop or when rendering\n\n  // Calculate grid layout dynamically based on number of games\n  // Aim for roughly square grid (e.g., 4 games = 2x2, 9 games = 3x3, 10 games = 4x3)\n  const gridCols = Math.ceil(Math.sqrt(MAX_GAMES));\n  const gridRows = Math.ceil(MAX_GAMES / gridCols);\n  // Scale down to fit games in grid\n  // Use 0.45 to ensure proper fit with padding\n  const scale = 0.45;\n  \n  // Speed multiplier for AI vs AI games (3x faster for faster training)\n\n  // Get model info\n  const modelInfo = rlModelManager.getModel().getInfo();\n  const isRLActive = rlModelManager.isRLActive();\n\n  return (\n    <div className=\"flex flex-col gap-4 w-full\">\n      {/* Top Section: Stats/Model Info and Training Controls */}\n      <div className=\"flex gap-4\">\n        {/* Left: RL Training + Model Selector, Stats, and Model Summary */}\n        <div className=\"flex-1 space-y-4\">\n          {/* Model Selector Section (Top) */}\n          <div className=\"p-4 bg-white border border-gray-300 rounded shadow\">\n            <div className=\"flex items-center gap-2\">\n              <label className=\"text-sm font-semibold whitespace-nowrap\">Select Model (Optional):</label>\n              <select\n                value={selectedModel}\n                onChange={(e) => handleModelSelect(e.target.value)}\n                className=\"px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm\"\n                style={{ maxWidth: '200px' }}\n                disabled={isLoadingModels}\n              >\n                <option value=\"\">{isLoadingModels ? 'Loading models...' : '-- Select a model --'}</option>\n                {savedModels.length === 0 && !isLoadingModels && (\n                  <option value=\"\" disabled>No saved models found</option>\n                )}\n                {savedModels.map((model) => (\n                  <option key={model.path} value={model.path}>\n                    {model.createdAtString}{model.evalScore !== undefined ? ` (Eval: ${model.evalScore.toFixed(2)})` : ''}\n                  </option>\n                ))}\n              </select>\n              <button\n                onClick={loadSavedModels}\n                style={{ backgroundColor: '#e5e7eb' }}\n                className=\"px-3 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 disabled:bg-gray-200 disabled:opacity-50 text-sm font-medium whitespace-nowrap flex-shrink-0\"\n                disabled={isLoadingModels}\n              >\n                {isLoadingModels ? 'Loading...' : 'Refresh'}\n              </button>\n              <button\n                onClick={async () => {\n                  try {\n                    setIsLoadingModels(true);\n                    const response = await fetch('/api/backend/models/latest');\n                    if (!response.ok) {\n                      throw new Error(`Failed to fetch model: ${response.statusText}`);\n                    }\n                    const modelData = await response.json();\n                    \n                    // Convert backend model format to TensorFlow.js format\n                    // The backend returns { layers, metadata }\n                    // We need to load this into the DQN agent\n                    const agent = new DQNAgent();\n                    \n                    // TODO: Convert backend model weights to TensorFlow.js format\n                    // For now, we'll need to implement a conversion function\n                    // This is a placeholder - full implementation would convert the weights\n                    alert('Model fetched from backend! (Conversion to TensorFlow.js format pending)');\n                    \n                    // After conversion, load the model similar to handleModelSelect\n                    // await agent.load(convertedModelPath);\n                    // ... rest of loading logic\n                  } catch (error) {\n                    console.error('Error fetching model from backend:', error);\n                    alert(`Failed to fetch model from backend: ${error instanceof Error ? error.message : String(error)}`);\n                  } finally {\n                    setIsLoadingModels(false);\n                  }\n                }}\n                style={{ backgroundColor: '#dbeafe' }}\n                className=\"px-3 py-2 bg-blue-100 text-blue-700 rounded hover:bg-blue-200 disabled:bg-gray-200 disabled:opacity-50 text-sm font-medium whitespace-nowrap flex-shrink-0\"\n                disabled={isLoadingModels}\n              >\n                {isLoadingModels ? 'Loading...' : 'Fetch from Backend'}\n              </button>\n            </div>\n            <div className=\"mt-2 text-xs text-gray-500 italic\">\n              Models are saved in your browser's local storage (Dexie DB). Maximum 8 models kept.\n            </div>\n          </div>\n\n          {/* Training Controls Section (Bottom) */}\n          <div className=\"p-4 bg-white border border-gray-300 rounded shadow\">\n            <div className=\"flex items-center gap-4 flex-wrap\">\n              {/* Training Controls */}\n              <div className=\"flex items-center gap-2 flex-wrap\">\n                <button\n                  onClick={async () => {\n                    try {\n                      // Check if training manager is initialized\n                      if (!training.manager) {\n                        alert('Training manager not initialized. Please wait for initialization.');\n                        return;\n                      }\n                      \n                      // Check if model can be saved\n                      if (!training.canSaveModel()) {\n                        const bufferSize = training.getReplayBufferSize();\n                        const hasEpisodes = (training.stats?.episode ?? 0) > 0;\n                        \n                        let message = 'Cannot save model yet. Requirements:\\n';\n                        if (bufferSize < 32) {\n                          message += `- Need at least 32 steps in replay buffer (current: ${bufferSize})\\n`;\n                        }\n                        if (!hasEpisodes) {\n                          message += '- Need at least one completed episode\\n';\n                        }\n                        if (bufferSize >= 32 && hasEpisodes) {\n                          message += '- Need to wait for training to occur (training happens every 4 steps when buffer has 32+ steps)\\n';\n                        }\n                        alert(message);\n                        return;\n                      }\n                      \n                      // Get model version from Game Status (vX where X = Math.floor(episode / activeGamesCount) + 1)\n                      const episode = training.stats?.episode || 0;\n                      const modelVersion = Math.floor(episode / activeGamesCount) + 1;\n                      \n                      // Use ISO timestamp for model name\n                      const timestamp = Date.now();\n                      const isoString = new Date(timestamp).toISOString();\n                      const modelPath = `indexeddb://tank-ai-${timestamp}`;\n                      \n                      // Get eval score (average reward)\n                      const evalScore = training.stats?.averageReward;\n                      \n                      // COMMENTED OUT: Frontend training disabled - using backend training service instead\n                      // await training.saveModel(modelPath, evalScore, isoString);\n                      \n                      // // Wait a bit for IndexedDB to fully sync (TensorFlow.js save is async)\n                      // await new Promise(resolve => setTimeout(resolve, 500));\n                      \n                      // // Preserve current selection before refreshing\n                      // const currentSelection = selectedModelRef.current;\n                      \n                      // // Try loading models with retry logic in case of timing issues\n                      // let models = await listSavedModels();\n                      // let retries = 0;\n                      // while (models.length === 0 && retries < 3) {\n                      //   await new Promise(resolve => setTimeout(resolve, 500));\n                      //   models = await listSavedModels();\n                      //   retries++;\n                      // }\n                      \n                      // setSavedModels(models);\n                      \n                      // // If we had a selection and it still exists, restore it\n                      // // Otherwise, the newly saved model will be available but not auto-selected\n                      // if (currentSelection && models.some(m => m.path === currentSelection)) {\n                      //   setSelectedModel(currentSelection);\n                      //   selectedModelRef.current = currentSelection;\n                      // }\n                      \n                      // if (models.some(m => m.path === modelPath)) {\n                      //   alert(`Model v${modelVersion} saved successfully! It should now appear in the dropdown.`);\n                      // } else {\n                      //   console.warn('Model saved but not found in list. This may be a timing issue. Try refreshing the model list manually.');\n                      //   alert(`Model v${modelVersion} saved, but it's not showing in the dropdown yet. Try clicking \"Refresh\" to reload the model list.`);\n                      // }\n                      alert('Frontend training is disabled. Models are saved automatically by the backend training service every 5 minutes.');\n                    } catch (error) {\n                      console.error('Error saving model:', error);\n                      const errorMessage = isError(error) ? error.message : String(error);\n                      alert(`Failed to save model: ${errorMessage}\\n\\nCheck the browser console for details.`);\n                    }\n                  }}\n                  disabled={!training.manager || !training.canSaveModel()}\n                  style={{ \n                    backgroundColor: (!training.manager || !training.canSaveModel()) ? '#d1d5db' : '#bfdbfe',\n                    opacity: (!training.manager || !training.canSaveModel()) ? 0.6 : 1,\n                    cursor: (!training.manager || !training.canSaveModel()) ? 'not-allowed' : 'pointer',\n                  }}\n                  className={`px-4 py-2 rounded font-medium ${\n                    (!training.manager || !training.canSaveModel())\n                      ? 'bg-gray-300 text-gray-500'\n                      : 'bg-blue-200 text-blue-700 hover:bg-blue-300'\n                  }`}\n                  title={(!training.manager || !training.canSaveModel()) \n                    ? `Requirements: 32+ steps in replay buffer, at least 1 episode completed, and training must have occurred at least once`\n                    : 'Save current model (creates new model, does not overwrite)'}\n                >\n                  Save Model\n                </button>\n                \n                {/* Headless Mode Checkbox */}\n                <div className=\"flex items-center gap-2\">\n                  <input\n                    type=\"checkbox\"\n                    id=\"headless-mode\"\n                    checked={isHeadlessMode}\n                    onChange={(e) => setIsHeadlessMode(e.target.checked)}\n                    className=\"w-4 h-4\"\n                  />\n                  <label htmlFor=\"headless-mode\" className=\"text-sm font-medium cursor-pointer\">\n                    Headless Training (8 games, auto-save every 5 min)\n                  </label>\n                  {isHeadlessMode && autoSaveCount > 0 && (\n                    <span className=\"text-xs text-gray-600\">\n                      (Auto-saved: {autoSaveCount})\n                    </span>\n                  )}\n                </div>\n              </div>\n\n              {/* Training Status */}\n              <div className=\"flex items-center gap-2 text-sm\">\n                <span className={`inline-block w-3 h-3 rounded-full ${training.isTraining ? 'bg-green-500' : 'bg-gray-400'}`} />\n                <span>{training.isTraining ? 'Training Active' : 'Training Stopped'}</span>\n              </div>\n            </div>\n            <div className=\"mt-2 text-xs text-gray-500 italic\">\n              Saving a model requires: 32+ steps in replay buffer, at least 1 episode completed, and training must have occurred at least once\n            </div>\n          </div>\n\n          {/* Stats Header */}\n          <div className=\"p-4 bg-white border border-gray-300 rounded shadow\">\n            <div className=\"grid gap-4\" style={{ gridTemplateColumns: `repeat(${Math.min(activeGamesCount, 8)}, 1fr)` }}>\n              <div>\n                <div className=\"text-sm text-gray-600\">Total Games</div>\n                <div className=\"text-2xl font-bold\">{training.stats?.episode || 0}</div>\n              </div>\n              <div>\n                <div className=\"text-sm text-gray-600\">AI vs AI</div>\n                <div className=\"text-2xl font-bold text-blue-600\">{gameStats.aiVsAiGames}</div>\n              </div>\n              <div>\n                <div className=\"text-sm text-gray-600\">Person vs AI</div>\n                <div className=\"text-2xl font-bold text-green-600\">{gameStats.personVsAiGames}</div>\n              </div>\n              <div>\n                <div className=\"text-sm text-gray-600\">Active Games</div>\n                <div className=\"text-2xl font-bold text-purple-600\">\n                  {activeGamesCount}\n                </div>\n              </div>\n            </div>\n          </div>\n\n          {/* Model Summary */}\n          <div className=\"p-4 bg-white border border-gray-300 rounded shadow\">\n            <h3 className=\"font-semibold mb-2\">Model Summary</h3>\n            <div className=\"grid grid-cols-3 gap-4 text-sm mb-2\">\n              <div>\n                <div>\n                  <span className=\"text-gray-600\">Model Type: </span>\n                  <span className=\"font-semibold\">{isRLActive ? 'RL (Trained)' : 'Rule-Based (Fallback)'}</span>\n                </div>\n                <div className=\"text-xs text-gray-500 italic mt-0.5\">Type of AI model being used</div>\n              </div>\n              <div>\n                <div>\n                  <span className=\"text-gray-600\">Action Space: </span>\n                  <span className=\"font-semibold\">{modelInfo.type === 'discrete' ? 'Discrete (14 actions)' : 'Continuous'}</span>\n                </div>\n                <div className=\"text-xs text-gray-500 italic mt-0.5\">Number of possible actions the AI can take</div>\n              </div>\n              <div>\n                <div>\n                  <span className=\"text-gray-600\">Observation Size: </span>\n                  <span className=\"font-semibold\">{modelInfo.observationSize} features</span>\n                </div>\n                <div className=\"text-xs text-gray-500 italic mt-0.5\">Number of input features the AI observes</div>\n              </div>\n            </div>\n            {training.stats && (\n              <>\n                {/* Debounce stats updates (every 5 seconds) */}\n                <StatsDebouncer\n                  stats={training.stats}\n                  onUpdate={handleDisplayStatsUpdate}\n                />\n                <div className=\"mt-2 pt-2 border-t border-gray-200\">\n                  <h4 className=\"font-semibold mb-2 text-sm\">Training Statistics</h4>\n                <div className=\"grid grid-cols-2 gap-3 text-sm mb-2\">\n                  <div>\n                    <div>\n                      <span className=\"text-gray-600\">Games: </span>\n                      <span className=\"font-semibold\">{training.stats.episode}</span>\n                    </div>\n                    <div className=\"text-xs text-gray-500 italic mt-0.5\">Total games completed (auto-saves every 100 games). Each game = one complete game session.</div>\n                  </div>\n                  <div>\n                    <div>\n                      <span className=\"text-gray-600\">Avg Reward: </span>\n                      <span className=\"font-semibold\">{(training.stats.averageReward ?? 0).toFixed(2)}</span>\n                    </div>\n                    <div className=\"text-xs text-gray-500 italic mt-0.5\">Average reward per game</div>\n                  </div>\n                  <div>\n                    <div>\n                      <span className=\"text-gray-600\">Epsilon: </span>\n                      <span className=\"font-semibold\">{(training.stats.epsilon ?? 0).toFixed(3)}</span>\n                    </div>\n                    <div className=\"text-xs text-gray-500 italic mt-0.5\">Exploration rate (higher = more random)</div>\n                  </div>\n                </div>\n                {/* Active Games Stats - Always visible to prevent layout shifts */}\n                <div className=\"mt-2 pt-2 border-t border-gray-200\">\n                  <h4 className=\"font-semibold mb-2 text-sm\">Active Games Stats</h4>\n                  <div className=\"grid grid-cols-2 gap-3 text-sm\">\n                    <div>\n                      <div>\n                        <span className=\"text-gray-600\">Reward: </span>\n                        <span className=\"font-semibold\">\n                          {displayStats?.reward !== undefined \n                            ? displayStats.reward.toFixed(2) \n                            : training.stats?.episodeReward.toFixed(2) || '0.00'}\n                        </span>\n                      </div>\n                      <div className=\"text-xs text-gray-500 italic mt-0.5\">\n                        Total reward across all {activeGamesCount} active games (positive = good, negative = poor performance, but still valid training data)\n                      </div>\n                    </div>\n                  <div>\n                    <div>\n                      <span className=\"text-gray-600\">Length: </span>\n                      <span className=\"font-semibold\">\n                        {displayStats?.length !== undefined \n                          ? displayStats.length \n                          : training.stats?.episodeLength || 0}\n                      </span>\n                    </div>\n                    <div className=\"text-xs text-gray-500 italic mt-0.5\">\n                      Total steps across all {activeGamesCount} active games (updates every 5 seconds)\n                    </div>\n                  </div>\n                  </div>\n                </div>\n              </div>\n              </>\n            )}\n          </div>\n        </div>\n\n        {/* Right: Dictionary */}\n        {/* <TrainingDictionary /> */}\n      </div>\n\n      {/* Game Status - Horizontal Layout */}\n      <div className=\"w-full\">\n        <div className=\"p-4 bg-white border border-gray-300 rounded shadow\">\n          <h3 className=\"font-semibold mb-3 text-lg\">Game Status</h3>\n          <div className=\"grid gap-4\" style={{ gridTemplateColumns: `repeat(${MAX_GAMES}, 1fr)` }}>\n            {gameInstances.map((instance) => {\n              const blueLives = instance.tanks[0]?.lives || 0;\n              const redLives = instance.tanks[1]?.lives || 0;\n              const isAIVsAI = instance.gameType === 'ai-vs-ai';\n              const isPersonVsAI = instance.gameType === 'person-vs-ai';\n              \n              // Calculate active duration\n              // Show N/A if training hasn't started or game hasn't started yet\n              const hasStarted = training.isTraining && instance.episodeStartTime;\n              let durationSeconds = 0;\n              \n              if (hasStarted) {\n                durationSeconds = Math.floor((currentTime - instance.episodeStartTime) / 1000);\n              }\n              \n              const formatDuration = (seconds: number) => {\n                const mins = Math.floor(seconds / 60);\n                const secs = seconds % 60;\n                return `${mins}:${secs.toString().padStart(2, '0')}`;\n              };\n              \n              return (\n                <div key={instance.id} className=\"border border-gray-200 rounded p-3\">\n                  <div className=\"flex items-center justify-between mb-2\">\n                    <div className=\"font-semibold text-sm\">Game {instance.id + 1}</div>\n                    <div className={`text-xs px-2 py-1 rounded ${\n                      isPersonVsAI \n                        ? 'bg-green-100 text-green-700' \n                        : 'bg-blue-100 text-blue-700'\n                    }`}>\n                      {isPersonVsAI ? 'Person vs AI' : 'AI vs AI'}\n                    </div>\n                  </div>\n                  <div className=\"space-y-1 text-xs\">\n                    <div className=\"flex justify-between\">\n                      <span className=\"text-gray-600\">Status:</span>\n                      <span className={`font-semibold ${training.isTraining ? 'text-green-600' : 'text-gray-400'}`}>\n                        {training.isTraining ? 'Active' : 'Paused'}\n                      </span>\n                    </div>\n                    <div className=\"flex justify-between\">\n                      <span className=\"text-gray-600\">Duration:</span>\n                      <span className=\"font-mono font-semibold text-gray-700\">\n                        {hasStarted ? formatDuration(durationSeconds) : 'N/A'}\n                      </span>\n                    </div>\n                    <div className=\"flex justify-between\">\n                      <span className=\"text-blue-600\">Blue Lives:</span>\n                      <span className=\"font-mono font-semibold\">{blueLives}</span>\n                    </div>\n                    <div className=\"flex justify-between\">\n                      <span className=\"text-red-600\">Red Lives:</span>\n                      <span className=\"font-mono font-semibold\">{redLives}</span>\n                    </div>\n                    {training.stats && (\n                      <div className=\"flex justify-between\">\n                        <span className=\"text-gray-600\">Model:</span>\n                        <span className=\"font-semibold text-blue-600\">v{Math.floor((training.stats.episode || 0) / MAX_GAMES) + 1}</span>\n                      </div>\n                    )}\n                    {instance.gameOverWinner && (\n                      <div className=\"mt-1 pt-1 border-t border-gray-200\">\n                        <span className=\"text-gray-600\">Winner: </span>\n                        <span className={`font-semibold ${instance.gameOverWinner === 'blue' ? 'text-blue-600' : 'text-red-600'}`}>\n                          {instance.gameOverWinner.toUpperCase()}\n                        </span>\n                      </div>\n                    )}\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n        </div>\n      </div>\n\n      {/* Main Content - Games Grid */}\n      {!isHeadlessMode && (\n      <div className=\"w-full\">\n        <div \n          className=\"grid gap-4\" \n          style={{ \n            gridTemplateColumns: `repeat(${gridCols}, 1fr)`,\n          }}\n        >\n          {gameInstances.map((instance) => {\n            const keysRef = getKeysRef(instance.id);\n            const isPersonGame = instance.gameType === 'person-vs-ai';\n            // Calculate scaled canvas size (internal resolution is 2x, then apply scale)\n            const scaledWidth = typedMapData.width * 2 * scale;\n            const scaledHeight = typedMapData.height * 2 * scale;\n            \n            const isUserPlaying = userPlayingGameId === instance.id;\n            \n            return (\n              <div \n                key={instance.id} \n                className={`border rounded p-2 bg-gray-50 relative flex flex-col items-center ${\n                  isUserPlaying ? 'border-blue-600 border-2' : 'border-gray-300'\n                }`}\n                style={{ \n                  height: `${scaledHeight + 60}px`, // Fixed height: Canvas height + padding + header (prevents scroll on game end)\n                  minHeight: `${scaledHeight + 60}px`,\n                  maxHeight: `${scaledHeight + 60}px`,\n                  overflow: 'hidden', // Prevent content from expanding beyond fixed height\n                }}\n              >\n                  <div className=\"flex items-center justify-between mb-1 w-full\" style={{ width: `${scaledWidth}px` }}>\n                    <div className=\"flex items-center gap-2\">\n                      <span className=\"text-xs font-bold text-gray-700\">\n                        ID: {instance.id + 1}\n                      </span>\n                      \n                          <span className=\"text-xs px-2 py-0.5 bg-gray-100 text-gray-700 rounded font-medium\">\n                            Game {instance.episodeNumber} / {(training.stats?.episode || 0) + MAX_GAMES}\n                          </span>\n                     \n                    </div>\n                    {!isPersonGame && (\n                      <div className=\"relative\">\n                        <button\n                          onClick={() => {\n                            // Only allow joining if not already in a different game\n                            if (userPlayingGameId === null || userPlayingGameId === instance.id) {\n                              replaceWithPersonGame(instance.id);\n                            }\n                          }}\n                          className={`text-xs px-2 py-1 rounded font-medium transition-colors ${\n                            !training.isTraining || (userPlayingGameId !== null && userPlayingGameId !== instance.id)\n                              ? 'bg-gray-300 text-gray-500 cursor-not-allowed opacity-60'\n                              : 'bg-green-100 text-green-700 hover:bg-green-200 cursor-pointer'\n                          }`}\n                          disabled={!training.isTraining || (userPlayingGameId !== null && userPlayingGameId !== instance.id)}\n                        >\n                          {userPlayingGameId === instance.id ? 'You are playing' : 'Join Game'}\n                        </button>\n                      </div>\n                    )}\n                    {isPersonGame && (\n                      <button\n                        onClick={() => replaceWithAIGame(instance.id)}\n                        className=\"text-xs px-2 py-1 bg-orange-200 text-orange-700 rounded hover:bg-orange-300 font-medium\"\n                      >\n                        Make AI vs AI\n                      </button>\n                    )}\n                  </div>\n                  {!training.isTraining && (\n                    <div className=\"absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-10 rounded\">\n                      <div className=\"text-white text-sm\">Training paused</div>\n                    </div>\n                  )}\n                  {/* Properly scaled canvas container - fixed size to prevent layout shifts */}\n                  <div \n                    className=\"flex justify-center items-center overflow-hidden\"\n                    style={{\n                      width: `${scaledWidth}px`,\n                      height: `${scaledHeight}px`,\n                    }}\n                  >\n                    <GameCanvas\n                      width={typedMapData.width}\n                      height={typedMapData.height}\n                      tanks={instance.tanks}\n                      bullets={instance.bullets}\n                      barriers={barriers}\n                      suns={suns}\n                      isPaused={!training.isTraining}\n                      tankImages={tankImages}\n                      gameOverWinner={instance.gameOverWinner}\n                      scale={scale}\n                    />\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n      </div>\n      )}\n      {isHeadlessMode && (\n        <div className=\"w-full p-8 bg-gray-100 border border-gray-300 rounded text-center\">\n          <div className=\"text-lg font-semibold text-gray-700 mb-2\">Headless Training Mode Active</div>\n          <div className=\"text-sm text-gray-600 mb-4\">\n            Running {activeGamesCount} games simultaneously (no rendering for better performance)\n          </div>\n          <div className=\"text-sm text-gray-600\">\n            Auto-save: {autoSaveCount > 0 ? `${autoSaveCount} model(s) saved` : 'Waiting for first save...'}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n\n","/**\n * Type Guard Utilities\n * \n * Generic type guard functions to reduce duplicate validation logic\n * and provide consistent error handling throughout the codebase.\n */\n\n/**\n * Generic type guard function that validates a value and throws an error if invalid\n * \n * @param value - The value to validate\n * @param guard - A type guard function that returns true if value is valid\n * @param errorMessage - Error message to throw if validation fails\n * @returns The validated value with proper type\n * \n * @example\n * const num = assertType(unknownValue, (v): v is number => typeof v === 'number', 'Expected number');\n */\nexport function assertType<T>(\n  value: unknown,\n  guard: (val: unknown) => val is T,\n  errorMessage: string\n): T {\n  if (!guard(value)) {\n    throw new Error(errorMessage);\n  }\n  return value;\n}\n\n/**\n * Validates that a value is not null or undefined\n */\nexport function isNotNull<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n\n/**\n * Validates that a value is an object (not null, not array, not primitive)\n */\nexport function isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\n/**\n * Validates that a value is a number\n */\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number' && !isNaN(value);\n}\n\n/**\n * Validates that a value is a string\n */\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\n/**\n * Validates that a value is an array\n */\nexport function isArray<T>(value: unknown, elementGuard?: (val: unknown) => val is T): value is T[] {\n  if (!Array.isArray(value)) {\n    return false;\n  }\n  if (elementGuard) {\n    return value.every(elementGuard);\n  }\n  return true;\n}\n\n/**\n * Validates that a value is an array of numbers\n */\nexport function isNumberArray(value: unknown): value is number[] {\n  return Array.isArray(value) && value.every((item) => typeof item === 'number' && !isNaN(item));\n}\n\n/**\n * Validates that a value is a 2D array of numbers\n */\nexport function is2DNumberArray(value: unknown): value is number[][] {\n  return (\n    Array.isArray(value) &&\n    value.length > 0 &&\n    value.every((row) => Array.isArray(row) && row.every((item) => typeof item === 'number' && !isNaN(item)))\n  );\n}\n\n/**\n * Validates that a value is an instance of a specific class\n */\nexport function isInstanceOf<T>(\n  value: unknown,\n  constructor: new (...args: unknown[]) => T\n): value is T {\n  return value instanceof constructor;\n}\n\n/**\n * Validates that a value is an Error instance\n */\nexport function isError(value: unknown): value is Error {\n  return value instanceof Error;\n}\n\n/**\n * Validates that a value has a specific property\n */\nexport function hasProperty<K extends string>(\n  value: unknown,\n  key: K\n): value is Record<K, unknown> {\n  return isObject(value) && key in value;\n}\n\n/**\n * Validates that a value has all specified properties\n */\nexport function hasProperties<K extends string>(\n  value: unknown,\n  keys: readonly K[]\n): value is Record<K, unknown> {\n  if (!isObject(value)) {\n    return false;\n  }\n  return keys.every((key) => key in value);\n}\n\n/**\n * Validates that a property exists and matches a type guard\n */\nexport function hasPropertyOfType<T, K extends string>(\n  value: unknown,\n  key: K,\n  guard: (val: unknown) => val is T\n): value is Record<K, T> {\n  if (!hasProperty(value, key)) {\n    return false;\n  }\n  return guard(value[key]);\n}\n\n/**\n * Validates a value using multiple type guards (all must pass)\n */\nexport function satisfiesAll<T>(\n  value: unknown,\n  ...guards: Array<(val: unknown) => val is T>\n): value is T {\n  return guards.every((guard) => guard(value));\n}\n\n/**\n * Validates a value using multiple type guards (at least one must pass)\n */\nexport function satisfiesAny<T>(\n  value: unknown,\n  ...guards: Array<(val: unknown) => val is T>\n): value is T {\n  return guards.some((guard) => guard(value));\n}\n\n/**\n * Validates that a number is within a range\n */\nexport function isInRange(value: number, min: number, max: number): boolean {\n  return value >= min && value <= max;\n}\n\n/**\n * Validates that a value is a valid enum value\n */\nexport function isEnumValue<T extends string>(\n  value: unknown,\n  enumObject: Record<string, T>\n): value is T {\n  return typeof value === 'string' && Object.values(enumObject).includes(value as T);\n}\n\n/**\n * Validates that a key is a valid key of an object type\n */\nexport function isKeyOf<T extends Record<string, unknown>>(\n  key: unknown,\n  validKeys: readonly (keyof T)[]\n): key is keyof T {\n  return typeof key === 'string' && validKeys.includes(key as keyof T);\n}\n\n/**\n * Validates and parses JSON, then validates the result with a type guard\n */\nexport function parseAndValidate<T>(\n  json: unknown,\n  guard: (val: unknown) => val is T,\n  errorMessage: string\n): T {\n  let parsed: unknown;\n  \n  if (typeof json === 'string') {\n    try {\n      parsed = JSON.parse(json);\n    } catch {\n      throw new Error(`Invalid JSON: ${errorMessage}`);\n    }\n  } else {\n    // If already an object, use JSON round-trip to create clean copy\n    try {\n      const jsonString = JSON.stringify(json);\n      parsed = JSON.parse(jsonString);\n    } catch {\n      throw new Error(`Failed to serialize: ${errorMessage}`);\n    }\n  }\n  \n  return assertType(parsed, guard, errorMessage);\n}\n\n/**\n * Validates that a value is a valid array length (non-negative integer)\n */\nexport function isValidArrayLength(value: unknown): value is number {\n  return typeof value === 'number' && Number.isInteger(value) && value >= 0;\n}\n\n/**\n * Validates that a value is a positive number\n */\nexport function isPositiveNumber(value: unknown): value is number {\n  return isNumber(value) && value > 0;\n}\n\n/**\n * Validates that a value is a non-negative number\n */\nexport function isNonNegativeNumber(value: unknown): value is number {\n  return isNumber(value) && value >= 0;\n}\n\n","import { useEffect, useRef, useState } from 'react';\n\ninterface UseGameInputOptions {\n  gameOver?: boolean;\n}\n\n// Pre-compute game keys as Set for O(1) lookup instead of O(n) array.includes()\nconst GAME_KEYS_SET = new Set(['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' ', 'w', 'a', 's', 'd', 'q', 'p']);\n\nexport function useGameInput(options?: UseGameInputOptions) {\n  const keysRef = useRef<Set<string>>(new Set());\n  const [isPaused, setIsPaused] = useState(false);\n  const gameOverRef = useRef(options?.gameOver ?? false);\n\n  useEffect(() => {\n    gameOverRef.current = options?.gameOver ?? false;\n  }, [options?.gameOver]);\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Skip processing if game is over\n      if (gameOverRef.current) {\n        return;\n      }\n      // Normalize key to lowercase, handle special cases\n      let key: string;\n      \n      // Handle space key\n      if (e.key === ' ' || e.code === 'Space') {\n        key = ' ';\n      }\n      // Handle arrow keys - they come as \"ArrowUp\", \"ArrowDown\", etc.\n      else if (e.key.startsWith('Arrow') || e.code.startsWith('Arrow')) {\n        const arrowDir = e.key.replace('Arrow', '').toLowerCase() || e.code.replace('Arrow', '').toLowerCase();\n        key = `arrow${arrowDir}`;\n      }\n      // Regular letter keys - use code for more reliable detection\n      else {\n        // e.code gives \"KeyP\", \"KeyW\", etc. - remove \"Key\" prefix\n        if (e.code.startsWith('Key')) {\n          key = e.code.replace('Key', '').toLowerCase(); // 'KeyW' -> 'w', 'KeyP' -> 'p', etc.\n        } else {\n          key = e.key.toLowerCase();\n        }\n      }\n      \n      // Use Set for O(1) lookup instead of O(n) array.includes()\n      if (GAME_KEYS_SET.has(key)) {\n        e.preventDefault(); // Prevent default browser behavior (scrolling, etc.) - prevents the \"ding\" sound\n        e.stopPropagation(); // Stop event from bubbling\n        \n        // Handle pause toggle\n        if (key === 'p') {\n          setIsPaused((prev) => !prev);\n          return; // Don't add 'p' to keys set\n        }\n        \n        keysRef.current.add(key);\n      }\n    };\n\n    const handleKeyUp = (e: KeyboardEvent) => {\n      // Skip processing if game is over\n      if (gameOverRef.current) {\n        return;\n      }\n      \n      // Normalize key to lowercase, handle special cases\n      let key: string;\n      \n      // Handle space key\n      if (e.key === ' ' || e.code === 'Space') {\n        key = ' ';\n      }\n      // Handle arrow keys\n      else if (e.key.startsWith('Arrow') || e.code.startsWith('Arrow')) {\n        const arrowDir = e.key.replace('Arrow', '').toLowerCase() || e.code.replace('Arrow', '').toLowerCase();\n        key = `arrow${arrowDir}`;\n      }\n      // Regular letter keys\n      else {\n        // e.code gives \"KeyP\", \"KeyW\", etc. - remove \"Key\" prefix\n        if (e.code.startsWith('Key')) {\n          key = e.code.replace('Key', '').toLowerCase(); // 'KeyW' -> 'w', 'KeyP' -> 'p', etc.\n        } else {\n          key = e.key.toLowerCase();\n        }\n      }\n      \n      // Use Set for O(1) lookup instead of O(n) array.includes()\n      if (GAME_KEYS_SET.has(key)) {\n        e.preventDefault(); // Prevent default browser behavior\n        e.stopPropagation(); // Stop event from bubbling\n        \n        // Don't remove 'p' from keys set since we never added it\n        if (key !== 'p') {\n          keysRef.current.delete(key);\n        }\n      }\n    };\n\n    // Use capture phase to catch events early and prevent default behavior\n    window.addEventListener('keydown', handleKeyDown, true);\n    window.addEventListener('keyup', handleKeyUp, true);\n\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown, true);\n      window.removeEventListener('keyup', handleKeyUp, true);\n    };\n  }, []);\n\n  return { keysRef, isPaused };\n}\n\n","import { useEffect, useState } from 'react';\n\nexport function useTankImages() {\n  const [tankImages, setTankImages] = useState<{ blue: HTMLImageElement | null; red: HTMLImageElement | null }>({\n    blue: null,\n    red: null,\n  });\n\n  useEffect(() => {\n    const blueImg = new Image();\n    blueImg.src = '/games/tank-blue.svg';\n    blueImg.onload = () => {\n      setTankImages((prev) => ({ ...prev, blue: blueImg }));\n    };\n\n    const redImg = new Image();\n    redImg.src = '/games/tank-red.svg';\n    redImg.onload = () => {\n      setTankImages((prev) => ({ ...prev, red: redImg }));\n    };\n  }, []);\n\n  return tankImages;\n}\n\n","// Game Configuration - Modify these values to adjust game rules\nexport const GAME_CONFIG = {\n  // Tank settings (40% bigger)\n  tank: {\n    size: 24, // 17 * 1.4 = 23.8, rounded to 24\n    collisionSize: 10, // 7 * 1.4 = 9.8, rounded to 10\n    speed: 1.4, // 1.12 * 1.25 = 1.4 (25% faster)\n    rotationSpeed: 5, // degrees per tick (keep same)\n    lives: 3,\n    spawnOffset: 2, // 4 * 0.5 = 2\n  },\n  \n  // Bullet settings (60% slower - 40% of current speed)\n  bullet: {\n    speedMultiplier: 1.8 , // Bullet speed = tank speed * this multiplier (60% slower: 2.4 * 0.4 = 0.96)\n    maxPerTank: 5,\n    maxAge: 7000, // Maximum lifetime in milliseconds (7 seconds)\n    fadeDuration: 500, // Fade duration in milliseconds\n    radius: 2, // Twice as big: 1 * 2 = 2\n    collisionSize: 3, // 5 * 0.5 = 2.5, rounded to 3 \n  },\n  \n  // Game timing\n  game: {\n    tickRate: 72, // FPS (20% increase: 60 * 1.2 = 72)\n    shootingCooldown: 150, // Milliseconds between shots (reduced for rapid fire)\n  },\n  \n  // Sun physics (50% weaker - 50% of current strength)\n  sun: {\n    gravitationalConstant: 0.25 , // G - Gravitational constant for suns (50% weaker: 0.18 * 0.5 = 0.09)\n    mass: 120.0, // Mass of the sun (2x original)\n    influenceRadius: 60, // 120 * 0.5 = 60\n    minDistance: 2, // 4 * 0.5 = 2\n  },\n  \n  // Visual settings (scaled down by 50% - 50% of current)\n  visual: {\n    livesIndicatorRadius: 2, // 3 * 0.5 = 1.5, rounded to 2\n    livesIndicatorSpacing: 3, // Reduced spacing for closer life indicators (was 4)\n    livesIndicatorOffsetX: 3, // 6 * 0.5 = 3\n    livesIndicatorOffsetY: -3, // -6 * 0.5 = -3\n    uiTextSize: 7, // 13 * 0.5 = 6.5, rounded to 7\n    uiTextOffsetX: 4, // 8 * 0.5 = 4\n    uiTextOffsetY: 10, // 20 * 0.5 = 10\n  },\n  \n  // Debug flags\n  debug: {\n    disableSunGravity: true, // When true, disables sun gravity and hides suns (for performance testing)\n  },\n} as const;\n\n// Derived constants (calculated from config)\nexport const TANK_SIZE = GAME_CONFIG.tank.size;\nexport const TANK_COLLISION_SIZE = GAME_CONFIG.tank.collisionSize;\nexport const TANK_HALF_SIZE = TANK_SIZE / 2; // Commonly used value, compute once\nexport const TANK_SPEED = GAME_CONFIG.tank.speed;\nexport const BULLET_SPEED = TANK_SPEED * GAME_CONFIG.bullet.speedMultiplier;\nexport const ROTATION_SPEED = GAME_CONFIG.tank.rotationSpeed;\nexport const TICK_RATE = GAME_CONFIG.game.tickRate;\nexport const TICK_INTERVAL = 1000 / TICK_RATE;\nexport const MAX_BULLETS_PER_TANK = GAME_CONFIG.bullet.maxPerTank;\nexport const BULLET_MAX_AGE = GAME_CONFIG.bullet.maxAge;\nexport const G = GAME_CONFIG.sun.gravitationalConstant;\nexport const mSun = GAME_CONFIG.sun.mass;\nexport const SUN_INFLUENCE_RADIUS = GAME_CONFIG.sun.influenceRadius;\n\n","/**\n * Physics utilities for game mechanics\n * Shared between BouncingBall and TankTrouble components\n */\n\nexport interface Vector2D {\n  x: number;\n  y: number;\n}\n\nexport interface Rectangle {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nexport interface BounceResult {\n  newPosition: Vector2D;\n  newVelocity: Vector2D;\n  bounced: boolean;\n}\n\n/**\n * Check collision between two rectangles\n */\nexport function checkRectCollision(\n  x1: number,\n  y1: number,\n  w1: number,\n  h1: number,\n  x2: number,\n  y2: number,\n  w2: number,\n  h2: number\n): boolean {\n  return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;\n}\n\n/**\n * Bounce off rectangular boundaries\n * Returns new position and velocity after bounce\n * Position is the center of the object, size is the collision size\n * Handles corners properly by detecting when both boundaries are hit\n */\nexport function bounceOffBoundaries(\n  position: Vector2D,\n  velocity: Vector2D,\n  size: number,\n  boundaries: {\n    left: number;\n    right: number;\n    top: number;\n    bottom: number;\n  }\n): BounceResult {\n  let newX = position.x;\n  let newY = position.y;\n  let newVx = velocity.x;\n  let newVy = velocity.y;\n  let bounced = false;\n  // No padding - objects can navigate right up to walls with no gap\n  const padding = 0;\n\n  // Check which boundaries are being hit\n  const hitLeft = newX - padding < boundaries.left;\n  const hitRight = newX + padding > boundaries.right;\n  const hitTop = newY - padding < boundaries.top;\n  const hitBottom = newY + padding > boundaries.bottom;\n\n  // Handle corner collisions (when two boundaries are hit)\n  if ((hitLeft || hitRight) && (hitTop || hitBottom)) {\n    // Corner collision - bounce both velocities\n    if (hitLeft) {\n      newX = boundaries.left + padding;\n      newVx = -newVx;\n    } else if (hitRight) {\n      newX = boundaries.right - padding;\n      newVx = -newVx;\n    }\n\n    if (hitTop) {\n      newY = boundaries.top + padding;\n      newVy = -newVy;\n    } else if (hitBottom) {\n      newY = boundaries.bottom - padding;\n      newVy = -newVy;\n    }\n    bounced = true;\n  } else {\n    // Handle edge collisions (single boundary)\n    if (hitLeft) {\n      newX = boundaries.left + padding;\n      newVx = -newVx;\n      bounced = true;\n    } else if (hitRight) {\n      newX = boundaries.right - padding;\n      newVx = -newVx;\n      bounced = true;\n    }\n\n    if (hitTop) {\n      newY = boundaries.top + padding;\n      newVy = -newVy;\n      bounced = true;\n    } else if (hitBottom) {\n      newY = boundaries.bottom - padding;\n      newVy = -newVy;\n      bounced = true;\n    }\n  }\n\n  return {\n    newPosition: { x: newX, y: newY },\n    newVelocity: { x: newVx, y: newVy },\n    bounced,\n  };\n}\n\n/**\n * Bounce off a rectangle barrier\n * Returns new position and velocity after bounce\n * Uses the bullet's previous position to determine collision side more accurately\n */\nexport function bounceOffRectangle(\n  position: Vector2D,\n  velocity: Vector2D,\n  size: number,\n  barrier: Rectangle,\n  previousPosition?: Vector2D\n): BounceResult {\n  const halfSize = size / 2;\n  const bulletLeft = position.x - halfSize;\n  const bulletRight = position.x + halfSize;\n  const bulletTop = position.y - halfSize;\n  const bulletBottom = position.y + halfSize;\n  \n  let newVx = velocity.x;\n  let newVy = velocity.y;\n  let bounced = false;\n\n  // Check if colliding with barrier\n  if (\n    bulletLeft < barrier.x + barrier.width &&\n    bulletRight > barrier.x &&\n    bulletTop < barrier.y + barrier.height &&\n    bulletBottom > barrier.y\n  ) {\n    // Determine which side of the barrier was hit\n    // Use previous position if available for more accurate detection\n    const refX = previousPosition?.x ?? position.x;\n    const refY = previousPosition?.y ?? position.y;\n    \n    // Calculate distances from bullet center to each barrier edge\n    const distToLeft = Math.abs(refX - barrier.x);\n    const distToRight = Math.abs(refX - (barrier.x + barrier.width));\n    const distToTop = Math.abs(refY - barrier.y);\n    const distToBottom = Math.abs(refY - (barrier.y + barrier.height));\n    \n    // Find the closest edge\n    const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);\n    \n    let newX = position.x;\n    let newY = position.y;\n    \n    if (minDist === distToLeft) {\n      // Hit left edge - bounce x velocity and position to left of barrier\n      newVx = -newVx;\n      newX = barrier.x - halfSize;\n      bounced = true;\n    } else if (minDist === distToRight) {\n      // Hit right edge - bounce x velocity and position to right of barrier\n      newVx = -newVx;\n      newX = barrier.x + barrier.width + halfSize;\n      bounced = true;\n    } else if (minDist === distToTop) {\n      // Hit top edge - bounce y velocity and position above barrier\n      newVy = -newVy;\n      newY = barrier.y - halfSize;\n      bounced = true;\n    } else if (minDist === distToBottom) {\n      // Hit bottom edge - bounce y velocity and position below barrier\n      newVy = -newVy;\n      newY = barrier.y + barrier.height + halfSize;\n      bounced = true;\n    }\n\n    return {\n      newPosition: { x: newX, y: newY },\n      newVelocity: { x: newVx, y: newVy },\n      bounced,\n    };\n  }\n\n  return {\n    newPosition: { x: position.x, y: position.y },\n    newVelocity: { x: newVx, y: newVy },\n    bounced: false,\n  };\n}\n\n/**\n * Calculate gravitational acceleration from a point source\n */\nexport function calculateGravity(\n  position: Vector2D,\n  source: Vector2D,\n  config: {\n    gravitationalConstant: number;\n    sourceMass: number;\n    influenceRadius: number;\n    minDistance: number;\n    maxAcceleration?: number;\n  }\n): Vector2D {\n  const dx = source.x - position.x;\n  const dy = source.y - position.y;\n  const distanceSquared = dx * dx + dy * dy;\n\n  // Early exit: check squared distance first (avoid sqrt if outside influence)\n  const influenceRadiusSquared = config.influenceRadius * config.influenceRadius;\n  if (distanceSquared >= influenceRadiusSquared || distanceSquared === 0) {\n    return { x: 0, y: 0 };\n  }\n\n  // Only calculate sqrt when we know we're within influence radius\n  const distance = Math.sqrt(distanceSquared);\n  const effectiveDistance = Math.max(distance, config.minDistance);\n  const effectiveDistanceSquared = effectiveDistance * effectiveDistance;\n\n  // Calculate gravitational acceleration\n  let gravitationalAcceleration = (config.gravitationalConstant * config.sourceMass) / effectiveDistanceSquared;\n\n  // Cap maximum acceleration if specified\n  if (config.maxAcceleration !== undefined) {\n    gravitationalAcceleration = Math.min(gravitationalAcceleration, config.maxAcceleration);\n  }\n\n  // Normalize direction vector\n  const directionX = dx / distance;\n  const directionY = dy / distance;\n\n  return {\n    x: directionX * gravitationalAcceleration,\n    y: directionY * gravitationalAcceleration,\n  };\n}\n\n/**\n * Apply gravity from multiple sources\n * Optimized: early exit if no sources are within influence radius\n */\nexport function applyGravityFromSources(\n  position: Vector2D,\n  sources: Vector2D[],\n  config: {\n    gravitationalConstant: number;\n    sourceMass: number;\n    influenceRadius: number;\n    minDistance: number;\n    maxAcceleration?: number;\n  }\n): Vector2D {\n  let totalAccelerationX = 0;\n  let totalAccelerationY = 0;\n  \n  // Pre-compute squared influence radius for faster distance comparison\n  const influenceRadiusSquared = config.influenceRadius * config.influenceRadius;\n\n  for (const source of sources) {\n    // Quick squared distance check before calling calculateGravity\n    const dx = source.x - position.x;\n    const dy = source.y - position.y;\n    const distanceSquared = dx * dx + dy * dy;\n    \n    // Skip this source if it's outside influence radius (calculateGravity also checks, but this avoids function call overhead)\n    if (distanceSquared >= influenceRadiusSquared || distanceSquared === 0) {\n      continue;\n    }\n    \n    const gravity = calculateGravity(position, source, config);\n    totalAccelerationX += gravity.x;\n    totalAccelerationY += gravity.y;\n  }\n\n  return {\n    x: totalAccelerationX,\n    y: totalAccelerationY,\n  };\n}\n\n/**\n * Ensure minimum velocity to prevent objects from getting stuck\n */\nexport function ensureMinimumVelocity(\n  velocity: Vector2D,\n  minSpeed: number\n): Vector2D {\n  const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n  \n  if (currentSpeed < minSpeed && currentSpeed > 0) {\n    // Normalize and scale to minimum velocity\n    const scale = minSpeed / currentSpeed;\n    return {\n      x: velocity.x * scale,\n      y: velocity.y * scale,\n    };\n  }\n\n  return velocity;\n}\n\n/**\n * Clamp velocity to maximum speed\n */\nexport function clampVelocity(velocity: Vector2D, maxSpeed: number): Vector2D {\n  const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);\n  \n  if (currentSpeed > maxSpeed) {\n    const scale = maxSpeed / currentSpeed;\n    return {\n      x: velocity.x * scale,\n      y: velocity.y * scale,\n    };\n  }\n\n  return velocity;\n}\n\n","/**\n * Game Constants\n * \n * Central location for all magic numbers and configuration values\n * used throughout the game logic.\n */\n\n// Spawn Constants\nexport const SPAWN_PADDING = 8; // Minimum distance from edges\nexport const MAX_SPAWN_ATTEMPTS = 100;\nexport const MIN_SPAWN_DISTANCE = 50; // Minimum distance between spawns\n\n// Bullet Constants\nexport const BULLET_MIN_VELOCITY = 0.5;\n\n// Collision Constants\nexport const COLLISION_EPSILON = 0.001; // Floating point precision tolerance\n\n// AI Controller Constants\nexport const URGENT_THREAT_THRESHOLD = 0.85; // Threat level to trigger dodge\nexport const ENEMY_PREDICTION_TIME_MS = 500; // Time to predict enemy position ahead\nexport const MOVE_FORWARD_ANGLE_TOLERANCE = 60; // Degrees tolerance for forward movement\nexport const MOVE_BACKWARD_ANGLE_TOLERANCE = 120; // Degrees tolerance for backward movement\n\n// Navigation Constants\nexport const MIN_DISTANCE_TO_ENEMY = 50; // Minimum ideal distance to enemy\nexport const TOO_CLOSE_DISTANCE = 30; // Distance considered too close\nexport const DISTANCE_REDUCTION_FACTOR = 0.8; // Factor for reducing distance to enemy\nexport const PATH_CHECK_STEPS = 20; // Steps for path clearance checking\n\n// Threat Assessment Constants\nexport const COLLISION_SIZE_BUFFER = 5; // Buffer pixels for collision detection\nexport const HIGH_THREAT_DISTANCE_MULTIPLIER = 3; // Multiplier for high threat distance\n\n// RL Reward Constants\nexport const TIMEOUT_PENALTY = -100;\nexport const MAX_EPISODE_TIME_MS = 60000; // 60 seconds - maximum episode duration before timeout\nexport const SURVIVAL_REWARD_PER_TICK = 0.01;\nexport const HIT_ENEMY_REWARD = 100;\nexport const GOT_HIT_PENALTY = -100;\nexport const OPTIMAL_DISTANCE_TO_ENEMY = 120; // Optimal distance for engagement\nexport const INACTIVITY_THRESHOLD_MS = 1500; // Time before inactivity penalty\nexport const SIGNIFICANT_MOVEMENT_THRESHOLD = 5; // Pixels - minimum movement to count\nexport const AGGRESSION_CHECK_INTERVAL_MS = 2000; // Time window for aggression check\nexport const DODGE_REWARD_PER_BULLET = 10;\n\n// Canvas Rendering Constants\nexport const CANVAS_SCALE_FACTOR = 2; // Internal resolution multiplier\nexport const GRAVITY_ARROW_GRID_SPACING = 30;\nexport const GRAVITY_ARROW_LENGTH = 8;\nexport const GRAVITY_ARROW_HEAD_SIZE = 3;\nexport const BULLET_DRAW_LENGTH = 6;\nexport const BULLET_DRAW_WIDTH = 3;\nexport const BULLET_DRAW_RADIUS = 1;\nexport const UI_TEXT_SPACING = 12; // Vertical spacing between UI text lines\n\n// Training View Constants\nexport const AI_VS_AI_SPEED_MULTIPLIER = 1;\nexport const MAX_GAMES = 4;\nexport const GAME_DISPLAY_SCALE = 0.45; // Scale factor for game display\n\n// Math Constants\nexport const DEGREES_TO_RADIANS = Math.PI / 180;\nexport const RADIANS_TO_DEGREES = 180 / Math.PI;\n\n","import { checkRectCollision } from '@/lib/physics';\nimport type { Barrier, Tank, Sun } from '@/app/games/tank-trouble/types';\nimport { TANK_SIZE, TANK_COLLISION_SIZE } from '@/app/games/tank-trouble/config';\nimport { COLLISION_EPSILON } from '@/app/games/tank-trouble/constants/game-constants';\n\n/**\n * Check if a tank position is valid (not colliding with barriers or out of bounds)\n * Note: Tanks can overlap each other - no tank-to-tank collision check\n */\nexport function isValidTankPosition(\n  x: number,\n  y: number,\n  mapWidth: number,\n  mapHeight: number,\n  barriers: Barrier[],\n  tanks: Tank[],\n  suns: Sun[],\n  excludeTankIndex?: number\n): boolean {\n  // Calculate collision box position (centered on tank)\n  const collisionOffset = (TANK_SIZE - TANK_COLLISION_SIZE) / 2;\n  const collisionX = x + collisionOffset;\n  const collisionY = y + collisionOffset;\n  \n  // Check boundaries - allow tanks to be exactly at walls (with small epsilon for floating point precision)\n  if (collisionX < -COLLISION_EPSILON || collisionY < -COLLISION_EPSILON || \n      collisionX + TANK_COLLISION_SIZE > mapWidth + COLLISION_EPSILON || \n      collisionY + TANK_COLLISION_SIZE > mapHeight + COLLISION_EPSILON) {\n    return false;\n  }\n\n  // Check barriers using collision size\n  for (const barrier of barriers) {\n    if (checkRectCollision(collisionX, collisionY, TANK_COLLISION_SIZE, TANK_COLLISION_SIZE, \n                           barrier.x, barrier.y, barrier.width, barrier.height)) {\n      return false;\n    }\n  }\n\n  // Check suns - tanks cannot overlap with suns\n  for (const sun of suns) {\n    const sunLeft = sun.x - sun.size;\n    const sunRight = sun.x + sun.size;\n    const sunTop = sun.y - sun.size;\n    const sunBottom = sun.y + sun.size;\n    \n    if (checkRectCollision(collisionX, collisionY, TANK_COLLISION_SIZE, TANK_COLLISION_SIZE,\n                           sunLeft, sunTop, sunRight - sunLeft, sunBottom - sunTop)) {\n      return false;\n    }\n  }\n\n  // Tanks can now overlap each other - no tank-to-tank collision check\n\n  return true;\n}\n\n/**\n * Check if tank can move to a position (checks barriers, boundaries, and suns)\n * Note: Tanks can overlap each other but not with suns\n */\nexport function canMoveTo(\n  x: number,\n  y: number,\n  mapWidth: number,\n  mapHeight: number,\n  barriers: Barrier[],\n  tanks: Tank[],\n  suns: Sun[],\n  excludeTankIndex?: number\n): boolean {\n  return isValidTankPosition(x, y, mapWidth, mapHeight, barriers, tanks, suns, excludeTankIndex);\n}\n\n","/**\n * Math Utilities\n * \n * Common mathematical operations used throughout the game.\n */\n\nimport { DEGREES_TO_RADIANS, RADIANS_TO_DEGREES } from '../constants/game-constants';\n\n/**\n * Calculate Euclidean distance between two points\n */\nexport function distance(x1: number, y1: number, x2: number, y2: number): number {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n/**\n * Calculate Euclidean distance between two point objects\n */\nexport function distancePoints(\n  p1: { x: number; y: number },\n  p2: { x: number; y: number }\n): number {\n  return distance(p1.x, p1.y, p2.x, p2.y);\n}\n\n/**\n * Convert degrees to radians\n */\nexport function degToRad(degrees: number): number {\n  return degrees * DEGREES_TO_RADIANS;\n}\n\n/**\n * Convert radians to degrees\n */\nexport function radToDeg(radians: number): number {\n  return radians * RADIANS_TO_DEGREES;\n}\n\n/**\n * Normalize angle to 0-360 range\n */\nexport function normalizeAngle(angle: number): number {\n  let normalized = angle % 360;\n  if (normalized < 0) normalized += 360;\n  return normalized;\n}\n\n/**\n * Normalize angle difference to -180 to 180 range\n */\nexport function normalizeAngleDifference(angleDiff: number): number {\n  while (angleDiff > 180) angleDiff -= 360;\n  while (angleDiff < -180) angleDiff += 360;\n  return angleDiff;\n}\n\n/**\n * Calculate angle from one point to another in degrees\n */\nexport function angleToPoint(\n  from: { x: number; y: number },\n  to: { x: number; y: number }\n): number {\n  const dx = to.x - from.x;\n  const dy = to.y - from.y;\n  return radToDeg(Math.atan2(dy, dx));\n}\n\n","/**\n * Bullet Creation Utilities\n * \n * Centralized logic for creating bullet objects.\n */\n\nimport type { Bullet, Tank } from '@/app/games/tank-trouble/types';\nimport { TANK_SIZE, BULLET_SPEED, GAME_CONFIG } from '@/app/games/tank-trouble/config';\nimport { degToRad } from './math';\n\n/**\n * Create a bullet from a tank's position and angle\n */\nexport function createBullet(\n  tank: Tank,\n  angle: number,\n  tickTime: number,\n  owner: 'blue' | 'red'\n): Bullet {\n  const rad = degToRad(angle);\n  const bulletX =\n    tank.x +\n    TANK_SIZE / 2 +\n    Math.cos(rad) * (TANK_SIZE / 2 + GAME_CONFIG.tank.spawnOffset);\n  const bulletY =\n    tank.y +\n    TANK_SIZE / 2 +\n    Math.sin(rad) * (TANK_SIZE / 2 + GAME_CONFIG.tank.spawnOffset);\n\n  return {\n    x: bulletX,\n    y: bulletY,\n    angle: angle,\n    speed: BULLET_SPEED,\n    owner: owner,\n    createdAt: tickTime,\n    vx: Math.cos(rad) * BULLET_SPEED,\n    vy: Math.sin(rad) * BULLET_SPEED,\n  };\n}\n\n","/**\n * Tank Utilities\n * \n * Common operations for tank manipulation.\n */\n\nimport type { Tank } from '@/app/games/tank-trouble/types';\nimport { TANK_SIZE, TANK_COLLISION_SIZE, TANK_HALF_SIZE } from '@/app/games/tank-trouble/config';\n\n/**\n * Get the center point of a tank\n */\nexport function getTankCenter(tank: Tank): { x: number; y: number } {\n  return {\n    x: tank.x + TANK_HALF_SIZE,\n    y: tank.y + TANK_HALF_SIZE,\n  };\n}\n\n/**\n * Clamp tank position to keep collision box within map bounds\n */\nexport function clampTankPosition(\n  x: number,\n  y: number,\n  mapWidth: number,\n  mapHeight: number\n): { x: number; y: number } {\n  const collisionOffset = (TANK_SIZE - TANK_COLLISION_SIZE) / 2;\n  const clampedX = Math.max(\n    -collisionOffset,\n    Math.min(x, mapWidth - TANK_SIZE + collisionOffset)\n  );\n  const clampedY = Math.max(\n    -collisionOffset,\n    Math.min(y, mapHeight - TANK_SIZE + collisionOffset)\n  );\n  return { x: clampedX, y: clampedY };\n}\n\n","/**\n * Optimized bullet collision utilities\n * \n * Pre-computes bullet groupings to reduce O(n²) operations to O(n)\n */\n\nimport type { Bullet } from '@/app/games/tank-trouble/types';\nimport { distance } from './math';\nimport { GAME_CONFIG } from '../config';\n\n/**\n * Group bullets by owner for faster collision detection\n * Returns a map: owner -> array of bullet indices\n */\nexport function groupBulletsByOwner(bullets: Bullet[]): Map<'blue' | 'red', number[]> {\n  const groups = new Map<'blue' | 'red', number[]>();\n  \n  for (let i = 0; i < bullets.length; i++) {\n    const bullet = bullets[i];\n    if (bullet.exploding) continue;\n    \n    const indices = groups.get(bullet.owner) || [];\n    indices.push(i);\n    groups.set(bullet.owner, indices);\n  }\n  \n  return groups;\n}\n\n/**\n * Count bullets by owner using Map for O(1) lookup\n * More efficient than filtering on every call\n */\nexport function countBulletsByOwner(bullets: Bullet[]): Map<'blue' | 'red', number> {\n  const counts = new Map<'blue' | 'red', number>();\n  \n  for (const bullet of bullets) {\n    if (!bullet.exploding) {\n      counts.set(bullet.owner, (counts.get(bullet.owner) || 0) + 1);\n    }\n  }\n  \n  return counts;\n}\n\n/**\n * Optimized bullet-bullet collision detection\n * Reduces O(n²) to O(n) by only checking bullets from different owners\n */\nexport function detectBulletCollisions(\n  bullets: Bullet[],\n  bulletGroups: Map<'blue' | 'red', number[]>\n): Set<number> {\n  const collisions = new Set<number>();\n  const checked = new Set<string>();\n  const collisionSize = GAME_CONFIG.bullet.collisionSize;\n  \n  const blueIndices = bulletGroups.get('blue') || [];\n  const redIndices = bulletGroups.get('red') || [];\n  \n  // Only check blue vs red bullets (not same owner)\n  // This reduces from O(n²) to O(blue_count * red_count), which is typically much smaller\n  for (const i of blueIndices) {\n    if (collisions.has(i)) continue;\n    const bullet = bullets[i];\n    if (bullet.exploding) continue;\n    \n    for (const j of redIndices) {\n      if (collisions.has(j)) continue;\n      const otherBullet = bullets[j];\n      if (otherBullet.exploding) continue;\n      \n      // Create unique key to avoid duplicate checks\n      const key = `${Math.min(i, j)}-${Math.max(i, j)}`;\n      if (checked.has(key)) continue;\n      checked.add(key);\n      \n      const dist = distance(bullet.x, bullet.y, otherBullet.x, otherBullet.y);\n      if (dist < collisionSize) {\n        collisions.add(i);\n        collisions.add(j);\n        break; // This bullet collided, no need to check more\n      }\n    }\n  }\n  \n  return collisions;\n}\n\n","import type { Tank, Bullet, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport { TANK_SPEED, ROTATION_SPEED, GAME_CONFIG, MAX_BULLETS_PER_TANK } from '@/app/games/tank-trouble/config';\nimport { canMoveTo } from '@/app/games/tank-trouble/utils/collision';\nimport { createBullet } from '@/app/games/tank-trouble/utils/bullet-creation';\nimport { clampTankPosition } from '@/app/games/tank-trouble/utils/tank-utils';\nimport { degToRad } from '@/app/games/tank-trouble/utils/math';\nimport { countBulletsByOwner } from '@/app/games/tank-trouble/utils/bullet-optimization';\n\nexport interface UpdateTankParams {\n  tank: Tank;\n  tankIndex: number;\n  keys: Set<string>;\n  tickTime: number;\n  lastShotTime: number;\n  bullets: Bullet[];\n  mapWidth: number;\n  mapHeight: number;\n  barriers: Barrier[];\n  suns: Sun[];\n  allTanks: Tank[];\n}\n\nexport interface UpdateTankResult {\n  updatedTank: Tank;\n  newBullets: Bullet[];\n  lastShotTime: number;\n}\n\n/**\n * Player control key mappings\n */\nexport interface PlayerControls {\n  rotateLeft: string;\n  rotateRight: string;\n  moveForward: string;\n  moveBackward: string;\n  shoot: string;\n}\n\n/**\n * Update tank movement and shooting using control mappings\n */\nfunction updatePlayerTank(\n  params: UpdateTankParams,\n  controls: PlayerControls,\n  owner: 'blue' | 'red'\n): UpdateTankResult {\n  const { tank, keys, tickTime, lastShotTime, bullets, mapWidth, mapHeight, barriers, suns, allTanks, tankIndex } = params;\n  \n  let newAngle = tank.angle;\n  let newX = tank.x;\n  let newY = tank.y;\n  const newBullets: Bullet[] = [];\n  let newLastShotTime = lastShotTime;\n\n  // Handle rotation\n  if (keys.has(controls.rotateLeft)) {\n    newAngle -= ROTATION_SPEED;\n  }\n  if (keys.has(controls.rotateRight)) {\n    newAngle += ROTATION_SPEED;\n  }\n\n  // Handle forward movement\n  if (keys.has(controls.moveForward)) {\n    const rad = degToRad(newAngle);\n    const dx = Math.cos(rad) * TANK_SPEED;\n    const dy = Math.sin(rad) * TANK_SPEED;\n    const testX = newX + dx;\n    const testY = newY + dy;\n    if (canMoveTo(testX, testY, mapWidth, mapHeight, barriers, allTanks, suns, tankIndex)) {\n      newX = testX;\n      newY = testY;\n    }\n  }\n\n  // Handle backward movement\n  if (keys.has(controls.moveBackward)) {\n    const rad = degToRad(newAngle);\n    const dx = -Math.cos(rad) * TANK_SPEED;\n    const dy = -Math.sin(rad) * TANK_SPEED;\n    const testX = newX + dx;\n    const testY = newY + dy;\n    if (canMoveTo(testX, testY, mapWidth, mapHeight, barriers, allTanks, suns, tankIndex)) {\n      newX = testX;\n      newY = testY;\n    }\n  }\n\n  // Handle shooting\n  if (keys.has(controls.shoot) && tickTime - lastShotTime > GAME_CONFIG.game.shootingCooldown) {\n    // Use optimized bullet counting instead of filter (O(n) instead of O(n) but cached result)\n    const bulletCounts = countBulletsByOwner(bullets);\n    const bulletCount = bulletCounts.get(owner) || 0;\n    if (bulletCount < MAX_BULLETS_PER_TANK) {\n      const bullet = createBullet(\n        { ...tank, x: newX, y: newY, angle: newAngle },\n        newAngle,\n        tickTime,\n        owner\n      );\n      newBullets.push(bullet);\n      newLastShotTime = tickTime;\n    }\n  }\n\n  // Clamp position to ensure collision box stays within bounds\n  const clamped = clampTankPosition(newX, newY, mapWidth, mapHeight);\n\n  return {\n    updatedTank: { ...tank, x: clamped.x, y: clamped.y, angle: newAngle },\n    newBullets,\n    lastShotTime: newLastShotTime,\n  };\n}\n\n/**\n * Update tank movement and shooting for Player 1 (Blue) - Arrow keys + Space\n */\nexport function updatePlayer1Tank(params: UpdateTankParams): UpdateTankResult {\n  return updatePlayerTank(params, {\n    rotateLeft: 'arrowleft',\n    rotateRight: 'arrowright',\n    moveForward: 'arrowup',\n    moveBackward: 'arrowdown',\n    shoot: ' ',\n  }, 'blue');\n}\n\n/**\n * Update tank movement and shooting for Player 2 (Red) - WASD + Q\n */\nexport function updatePlayer2Tank(params: UpdateTankParams): UpdateTankResult {\n  return updatePlayerTank(params, {\n    rotateLeft: 'a',\n    rotateRight: 'd',\n    moveForward: 'w',\n    moveBackward: 's',\n    shoot: 'q',\n  }, 'red');\n}\n\n","import type { Bullet, Tank, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport {\n  bounceOffBoundaries,\n  bounceOffRectangle,\n  applyGravityFromSources,\n  ensureMinimumVelocity,\n  type Vector2D,\n  type Rectangle,\n} from '@/lib/physics';\nimport {\n  BULLET_MAX_AGE,\n  BULLET_SPEED,\n  G,\n  mSun,\n  SUN_INFLUENCE_RADIUS,\n  GAME_CONFIG,\n  TANK_COLLISION_SIZE,\n  TANK_SIZE,\n} from '@/app/games/tank-trouble/config';\nimport { BULLET_MIN_VELOCITY } from '@/app/games/tank-trouble/constants/game-constants';\nimport { distance, radToDeg } from '@/app/games/tank-trouble/utils/math';\nimport { detectBulletCollisions, groupBulletsByOwner } from '@/app/games/tank-trouble/utils/bullet-optimization';\n\n// Cache for sun sources (suns are static during gameplay)\nlet cachedSunSources: Vector2D[] | null = null;\nlet cachedSunsReference: Sun[] | null = null;\nlet cachedDisableSunGravity: boolean | null = null;\n\n// Cache for gravity config (only maxAcceleration depends on BULLET_SPEED)\nlet cachedGravityConfig: {\n  gravitationalConstant: number;\n  sourceMass: number;\n  influenceRadius: number;\n  minDistance: number;\n  maxAcceleration: number;\n} | null = null;\nlet cachedBulletSpeed: number | null = null;\n\n/**\n * Get or compute sun sources array (cached for performance)\n */\nfunction getSunSources(suns: Sun[]): Vector2D[] {\n  const disableSunGravity = GAME_CONFIG.debug.disableSunGravity;\n  \n  // Check if suns array reference changed, disable flag changed, or cache is invalid\n  if (cachedSunSources === null || \n      cachedSunsReference !== suns || \n      cachedDisableSunGravity !== disableSunGravity) {\n    if (disableSunGravity) {\n      cachedSunSources = [];\n    } else {\n      cachedSunSources = suns.map((sun) => ({\n        x: sun.x,\n        y: sun.y,\n      }));\n    }\n    cachedSunsReference = suns;\n    cachedDisableSunGravity = disableSunGravity;\n  }\n  return cachedSunSources;\n}\n\n/**\n * Get or compute gravity config (cached for performance)\n */\nfunction getGravityConfig(): {\n  gravitationalConstant: number;\n  sourceMass: number;\n  influenceRadius: number;\n  minDistance: number;\n  maxAcceleration: number;\n} {\n  // Check if BULLET_SPEED changed (only maxAcceleration depends on it)\n  if (cachedGravityConfig === null || cachedBulletSpeed !== BULLET_SPEED) {\n    cachedGravityConfig = {\n      gravitationalConstant: G,\n      sourceMass: mSun,\n      influenceRadius: SUN_INFLUENCE_RADIUS,\n      minDistance: GAME_CONFIG.sun.minDistance,\n      maxAcceleration: BULLET_SPEED * 0.3, // Max 30% of bullet speed per frame\n    };\n    cachedBulletSpeed = BULLET_SPEED;\n  }\n  return cachedGravityConfig;\n}\n\ninterface UpdateBulletsParams {\n  bullets: Bullet[];\n  tickTime: number;\n  mapWidth: number;\n  mapHeight: number;\n  barriers: Barrier[];\n  suns: Sun[];\n  tanks: Tank[];\n}\n\ninterface UpdateBulletsResult {\n  updatedBullets: Bullet[];\n  updatedTanks: Tank[];\n}\n\n/**\n * Update all bullets - handle physics, collisions, and tank hits\n */\nexport function updateBullets(params: UpdateBulletsParams): UpdateBulletsResult {\n  const { bullets, tickTime, mapWidth, mapHeight, barriers, suns, tanks } = params;\n  \n  const updatedBullets: Bullet[] = [];\n  const updatedTanks = [...tanks];\n  const bulletCollisionSize = GAME_CONFIG.bullet.collisionSize;\n\n  // First pass: optimized bullet-bullet collision detection\n  // Groups bullets by owner first, reducing O(n²) to O(blue_count * red_count)\n  const bulletGroups = groupBulletsByOwner(bullets);\n  const bulletsToRemove = detectBulletCollisions(bullets, bulletGroups);\n\n  // Get cached sun sources (only recomputed if suns array reference changes)\n  const sunSources = getSunSources(suns);\n\n  // Get cached gravity config (only recomputed if BULLET_SPEED changes)\n  const gravityConfig = getGravityConfig();\n\n  // Second pass: update remaining bullets\n  for (let i = 0; i < bullets.length; i++) {\n    if (bulletsToRemove.has(i)) continue;\n    \n    const bullet = bullets[i];\n    \n    // Remove exploding bullets immediately (no animation)\n    if (bullet.exploding) {\n      continue;\n    }\n\n    // Check bullet age - bullets fade away instead of exploding\n    const age = tickTime - bullet.createdAt;\n    if (age > BULLET_MAX_AGE) {\n      // Remove bullet after fade duration\n      const fadeDuration = GAME_CONFIG.bullet.fadeDuration;\n      if (age > BULLET_MAX_AGE + fadeDuration) {\n        continue; // Bullet has faded completely, remove it\n      }\n      // Keep bullet but mark as fading (will be handled in rendering)\n    }\n\n    // Apply gravitational force from suns (skip if disabled via debug flag)\n    const gravityAcceleration = GAME_CONFIG.debug.disableSunGravity\n      ? { x: 0, y: 0 }\n      : applyGravityFromSources(\n          { x: bullet.x, y: bullet.y },\n          sunSources,\n          gravityConfig\n        );\n\n    // Update velocity with gravitational acceleration\n    let newVx = bullet.vx + gravityAcceleration.x;\n    let newVy = bullet.vy + gravityAcceleration.y;\n\n    // Ensure minimum velocity to prevent bullets from getting stuck (very small minimum to prevent division by zero)\n    const velocity = ensureMinimumVelocity({ x: newVx, y: newVy }, BULLET_MIN_VELOCITY);\n    newVx = velocity.x;\n    newVy = velocity.y;\n\n    // Allow gravity to slow bullets naturally - no minimum speed enforcement\n\n    // Update position using velocity\n    let newX = bullet.x + newVx;\n    let newY = bullet.y + newVy;\n\n    // Bounce off boundaries (walls)\n    const boundaryBounce = bounceOffBoundaries(\n      { x: newX, y: newY },\n      { x: newVx, y: newVy },\n      bulletCollisionSize,\n      {\n        left: 0,\n        right: mapWidth,\n        top: 0,\n        bottom: mapHeight,\n      }\n    );\n    newX = boundaryBounce.newPosition.x;\n    newY = boundaryBounce.newPosition.y;\n    newVx = boundaryBounce.newVelocity.x;\n    newVy = boundaryBounce.newVelocity.y;\n\n    // Check collision with barriers - bounce off barriers\n    // Early exit when collision found - barriers array is typically small so O(n) is acceptable\n    for (const barrier of barriers) {\n      const barrierRect: Rectangle = {\n        x: barrier.x,\n        y: barrier.y,\n        width: barrier.width,\n        height: barrier.height,\n      };\n\n      const barrierBounce = bounceOffRectangle(\n        { x: newX, y: newY },\n        { x: newVx, y: newVy },\n        bulletCollisionSize,\n        barrierRect,\n        { x: bullet.x, y: bullet.y } // Previous position for accurate side detection\n      );\n\n      if (barrierBounce.bounced) {\n        newX = barrierBounce.newPosition.x;\n        newY = barrierBounce.newPosition.y;\n        newVx = barrierBounce.newVelocity.x;\n        newVy = barrierBounce.newVelocity.y;\n        break; // Only one barrier collision per tick\n      }\n    }\n\n    // Check collision with tanks\n    let hitTank = false;\n    for (let j = 0; j < updatedTanks.length; j++) {\n      const tank = updatedTanks[j];\n      if (tank.lives > 0) {\n        // Check if tank is invincible (recently respawned)\n        const isInvincible = tank.invincibleUntil !== undefined && tickTime < tank.invincibleUntil;\n        if (isInvincible) {\n          // Tank is invincible, skip collision check\n          continue;\n        }\n        \n        const bulletLeft = newX - bulletCollisionSize / 2;\n        const bulletTop = newY - bulletCollisionSize / 2;\n        const bulletRight = newX + bulletCollisionSize / 2;\n        const bulletBottom = newY + bulletCollisionSize / 2;\n        \n        // Calculate tank collision box (centered on tank position)\n        const tankCollisionOffset = (TANK_SIZE - TANK_COLLISION_SIZE) / 2;\n        const tankCollisionLeft = tank.x + tankCollisionOffset;\n        const tankCollisionTop = tank.y + tankCollisionOffset;\n        const tankCollisionRight = tankCollisionLeft + TANK_COLLISION_SIZE;\n        const tankCollisionBottom = tankCollisionTop + TANK_COLLISION_SIZE;\n        \n        // Check if bullet rectangle overlaps with tank collision rectangle\n        if (\n          bulletLeft < tankCollisionRight &&\n          bulletRight > tankCollisionLeft &&\n          bulletTop < tankCollisionBottom &&\n          bulletBottom > tankCollisionTop\n        ) {\n          // Tank hit! Decrease lives and respawn immediately\n          const newLives = tank.lives - 1;\n          // Use random spawn (will be handled by game logic)\n          updatedTanks[j] = {\n            ...tank,\n            lives: newLives,\n          };\n          hitTank = true;\n          break;\n        }\n      }\n    }\n    \n    if (hitTank) {\n      // Bullet hits tank - remove immediately (no animation)\n      continue;\n    }\n\n    // Update angle based on new velocity\n    const newAngle = radToDeg(Math.atan2(newVy, newVx));\n    \n    updatedBullets.push({\n      ...bullet,\n      x: newX,\n      y: newY,\n      angle: newAngle,\n      vx: newVx,\n      vy: newVy,\n    });\n  }\n\n  return {\n    updatedBullets,\n    updatedTanks,\n  };\n}\n\n","import type { Tank, SpawnPosition, TankTroubleMapData, Sun } from '@/app/games/tank-trouble/types';\nimport { GAME_CONFIG, TANK_SIZE } from '@/app/games/tank-trouble/config';\nimport { isValidTankPosition } from '@/app/games/tank-trouble/utils/collision';\nimport { MAX_SPAWN_ATTEMPTS, SPAWN_PADDING, MIN_SPAWN_DISTANCE } from '@/app/games/tank-trouble/constants/game-constants';\nimport { distancePoints } from '@/app/games/tank-trouble/utils/math';\n\n/**\n * Generate a random valid spawn position for a tank\n */\nexport function generateRandomSpawnPosition(\n  mapData: TankTroubleMapData,\n  barriers: Array<{ x: number; y: number; width: number; height: number }>,\n  tanks: Tank[],\n  suns: Sun[],\n  excludePosition?: { x: number; y: number }\n): SpawnPosition {\n  if (!mapData || typeof mapData.width !== 'number' || typeof mapData.height !== 'number') {\n    // Fallback to safe defaults - use type guard utility for validation\n    return {\n      x: 90,\n      y: 90,\n      angle: 0,\n    };\n  }\n  \n  const maxAttempts = MAX_SPAWN_ATTEMPTS;\n  const padding = SPAWN_PADDING;\n  \n  // Validate map dimensions\n  const mapWidth = mapData.width;\n  const mapHeight = mapData.height;\n  const availableWidth = mapWidth - TANK_SIZE - padding * 2;\n  const availableHeight = mapHeight - TANK_SIZE - padding * 2;\n  \n  if (isNaN(availableWidth) || isNaN(availableHeight) || availableWidth <= 0 || availableHeight <= 0) {\n    // Fallback to spawn points\n    if (mapData.spawnPoints && mapData.spawnPoints.length > 0) {\n      return {\n        x: mapData.spawnPoints[0].x,\n        y: mapData.spawnPoints[0].y,\n        angle: mapData.spawnPoints[0].angle,\n      };\n    }\n    return {\n      x: padding,\n      y: padding,\n      angle: 0,\n    };\n  }\n  \n  for (let attempt = 0; attempt < maxAttempts; attempt++) {\n    const x = padding + Math.random() * availableWidth;\n    const y = padding + Math.random() * availableHeight;\n    \n    // Check if position is too close to exclude position (if provided)\n    if (excludePosition) {\n      const dist = distancePoints({ x, y }, excludePosition);\n      if (dist < MIN_SPAWN_DISTANCE) {\n        continue;\n      }\n    }\n    \n    // Check if position is valid (no barrier or sun collision)\n    if (isValidTankPosition(x, y, mapData.width, mapData.height, barriers, tanks, suns)) {\n      // Tanks can overlap, so no distance check needed\n      // Random angle between 0 and 360\n      const angle = Math.random() * 360;\n      return { x, y, angle };\n    }\n  }\n  \n  // Fallback to default spawn points if random generation fails\n  const spawnPoints = mapData.spawnPoints;\n  if (!spawnPoints || spawnPoints.length === 0) {\n    // Last resort: return a safe default position if spawn points are missing\n    return {\n      x: padding,\n      y: padding,\n      angle: 0,\n    };\n  }\n  \n  // Try each spawn point until we find a valid one\n  for (const spawnPoint of spawnPoints) {\n    if (isValidTankPosition(spawnPoint.x, spawnPoint.y, mapData.width, mapData.height, barriers, tanks, suns)) {\n      // Check exclude position if provided\n      if (excludePosition) {\n        const dist = distancePoints(spawnPoint, excludePosition);\n        if (dist < MIN_SPAWN_DISTANCE) {\n          continue;\n        }\n      }\n      return {\n        x: spawnPoint.x,\n        y: spawnPoint.y,\n        angle: spawnPoint.angle,\n      };\n    }\n  }\n  \n  // If all spawn points are invalid, use the first one anyway (last resort)\n  return {\n    x: spawnPoints[0].x,\n    y: spawnPoints[0].y,\n    angle: spawnPoints[0].angle,\n  };\n}\n\n/**\n * Generate random initial spawn positions for both tanks\n * Explicitly excludes all death/respawn state to ensure clean tank state\n */\nexport function getInitialSpawnPositions(\n  mapData: TankTroubleMapData,\n  barriers: Array<{ x: number; y: number; width: number; height: number }>,\n  suns: Sun[]\n): Tank[] {\n  \n  const blueSpawn = generateRandomSpawnPosition(mapData, barriers || [], [], suns || []);\n  \n  // Validate blue spawn position\n  if (typeof blueSpawn.x !== 'number' || typeof blueSpawn.y !== 'number' || isNaN(blueSpawn.x) || isNaN(blueSpawn.y)) {\n    // Fallback to safe default\n    blueSpawn.x = 90;\n    blueSpawn.y = 90;\n    blueSpawn.angle = 0;\n  }\n  \n  // Create blue tank object to pass to red spawn generation (for collision checking)\n  const blueTank: Tank = {\n    x: blueSpawn.x,\n    y: blueSpawn.y,\n    angle: blueSpawn.angle,\n    lives: GAME_CONFIG.tank.lives,\n    color: 'blue',\n  };\n  const redSpawn = generateRandomSpawnPosition(mapData, barriers, [blueTank], suns, blueSpawn);\n  \n  // Validate red spawn position\n  if (typeof redSpawn.x !== 'number' || typeof redSpawn.y !== 'number' || isNaN(redSpawn.x) || isNaN(redSpawn.y)) {\n    // Fallback to safe default (different from blue)\n    redSpawn.x = mapData.spawnPoints && mapData.spawnPoints.length > 1 ? mapData.spawnPoints[1].x : 390;\n    redSpawn.y = mapData.spawnPoints && mapData.spawnPoints.length > 1 ? mapData.spawnPoints[1].y : 270;\n    redSpawn.angle = mapData.spawnPoints && mapData.spawnPoints.length > 1 ? mapData.spawnPoints[1].angle : 180;\n  }\n  \n  return [\n    { \n      x: blueSpawn.x, \n      y: blueSpawn.y, \n      angle: blueSpawn.angle, \n      lives: GAME_CONFIG.tank.lives, \n      color: 'blue',\n      // Explicitly exclude death/respawn state\n      exploding: undefined,\n      explosionStartTime: undefined,\n      respawning: undefined,\n      respawnStartTime: undefined,\n      respawnTargetX: undefined,\n      respawnTargetY: undefined,\n      respawnTargetAngle: undefined,\n    },\n    { \n      x: redSpawn.x, \n      y: redSpawn.y, \n      angle: redSpawn.angle, \n      lives: GAME_CONFIG.tank.lives, \n      color: 'red',\n      // Explicitly exclude death/respawn state\n      exploding: undefined,\n      explosionStartTime: undefined,\n      respawning: undefined,\n      respawnStartTime: undefined,\n      respawnTargetX: undefined,\n      respawnTargetY: undefined,\n      respawnTargetAngle: undefined,\n    },\n  ];\n}\n\n","import type { Bullet, Sun, Barrier } from '@/app/games/tank-trouble/types';\nimport type { PredictedBulletPath } from './types';\nimport {\n  applyGravityFromSources,\n  bounceOffBoundaries,\n  bounceOffRectangle,\n  ensureMinimumVelocity,\n  type Vector2D,\n  type Rectangle,\n} from '@/lib/physics';\nimport {\n  BULLET_SPEED,\n  G,\n  mSun,\n  SUN_INFLUENCE_RADIUS,\n  GAME_CONFIG,\n  TICK_INTERVAL,\n} from '@/app/games/tank-trouble/config';\nimport { BULLET_MIN_VELOCITY } from '@/app/games/tank-trouble/constants/game-constants';\n\n/**\n * Predict bullet trajectory accounting for sun gravity and collisions\n */\nexport function predictBulletPath(\n  bullet: Bullet,\n  suns: Sun[],\n  barriers: Barrier[],\n  mapWidth: number,\n  mapHeight: number,\n  maxTime: number,\n  stepSize: number = TICK_INTERVAL\n): PredictedBulletPath {\n  const points: Array<{ x: number; y: number; time: number }> = [];\n  let currentX = bullet.x;\n  let currentY = bullet.y;\n  let currentVx = bullet.vx;\n  let currentVy = bullet.vy;\n  let currentTime = 0;\n  const bulletCollisionSize = GAME_CONFIG.bullet.collisionSize;\n  let isBlocked = false;\n\n  // Convert suns to vector sources (pre-compute once, skip if disabled via debug flag)\n  const sunSources: Vector2D[] = GAME_CONFIG.debug.disableSunGravity\n    ? []\n    : suns.map((sun) => ({\n        x: sun.x,\n        y: sun.y,\n      }));\n\n  // Pre-compute gravity config (avoid recreating object in loop)\n  const gravityConfig = {\n    gravitationalConstant: G,\n    sourceMass: mSun,\n    influenceRadius: SUN_INFLUENCE_RADIUS,\n    minDistance: GAME_CONFIG.sun.minDistance,\n    maxAcceleration: BULLET_SPEED * 0.3,\n  };\n\n  // Store initial point\n  points.push({ x: currentX, y: currentY, time: currentTime });\n\n  while (currentTime < maxTime && !isBlocked) {\n    // Apply gravity (skip if disabled via debug flag)\n    const gravityAcceleration = GAME_CONFIG.debug.disableSunGravity\n      ? { x: 0, y: 0 }\n      : applyGravityFromSources(\n          { x: currentX, y: currentY },\n          sunSources,\n          gravityConfig\n        );\n\n    // Update velocity\n    let newVx = currentVx + gravityAcceleration.x;\n    let newVy = currentVy + gravityAcceleration.y;\n\n    // Ensure minimum velocity\n    const velocity = ensureMinimumVelocity({ x: newVx, y: newVy }, BULLET_MIN_VELOCITY);\n    newVx = velocity.x;\n    newVy = velocity.y;\n\n    // Update position\n    let newX = currentX + newVx;\n    let newY = currentY + newVy;\n\n    // Check boundary collision\n    const boundaryBounce = bounceOffBoundaries(\n      { x: newX, y: newY },\n      { x: newVx, y: newVy },\n      bulletCollisionSize,\n      {\n        left: 0,\n        right: mapWidth,\n        top: 0,\n        bottom: mapHeight,\n      }\n    );\n\n    if (boundaryBounce.bounced) {\n      newX = boundaryBounce.newPosition.x;\n      newY = boundaryBounce.newPosition.y;\n      newVx = boundaryBounce.newVelocity.x;\n      newVy = boundaryBounce.newVelocity.y;\n    }\n\n    // Check barrier collision\n    for (const barrier of barriers) {\n      const barrierRect: Rectangle = {\n        x: barrier.x,\n        y: barrier.y,\n        width: barrier.width,\n        height: barrier.height,\n      };\n\n      const barrierBounce = bounceOffRectangle(\n        { x: newX, y: newY },\n        { x: newVx, y: newVy },\n        bulletCollisionSize,\n        barrierRect,\n        { x: currentX, y: currentY }\n      );\n\n      if (barrierBounce.bounced) {\n        newX = barrierBounce.newPosition.x;\n        newY = barrierBounce.newPosition.y;\n        newVx = barrierBounce.newVelocity.x;\n        newVy = barrierBounce.newVelocity.y;\n        // Continue after bounce\n      }\n    }\n\n    currentX = newX;\n    currentY = newY;\n    currentVx = newVx;\n    currentVy = newVy;\n    currentTime += stepSize;\n\n    // Add point (sample every few steps to reduce memory)\n    if (points.length === 0 || currentTime - points[points.length - 1].time >= stepSize * 5) {\n      points.push({ x: currentX, y: currentY, time: currentTime });\n    }\n\n    // Stop if bullet is moving too slowly (stuck in sun)\n    const speed = Math.sqrt(newVx * newVx + newVy * newVy);\n    if (speed < BULLET_MIN_VELOCITY) {\n      isBlocked = true;\n      break;\n    }\n  }\n\n  return {\n    points,\n    isBlocked,\n    endTime: currentTime,\n  };\n}\n\n/**\n * Predict where a tank will be based on current velocity/position\n * Uses simple linear extrapolation\n */\nexport function predictTankPosition(\n  tank: { x: number; y: number; angle: number },\n  timeAhead: number,\n  tankSpeed: number\n): { x: number; y: number } {\n  const rad = (tank.angle * Math.PI) / 180;\n  const dx = Math.cos(rad) * tankSpeed * (timeAhead / TICK_INTERVAL);\n  const dy = Math.sin(rad) * tankSpeed * (timeAhead / TICK_INTERVAL);\n  return {\n    x: tank.x + dx,\n    y: tank.y + dy,\n  };\n}\n\n\n","import type { Bullet, Tank, Sun, Barrier } from '@/app/games/tank-trouble/types';\nimport type { Threat } from './types';\nimport { predictBulletPath } from './prediction';\nimport { TANK_SIZE, TANK_COLLISION_SIZE } from '@/app/games/tank-trouble/config';\nimport { getTankCenter } from '@/app/games/tank-trouble/utils/tank-utils';\nimport { distance, angleToPoint, radToDeg } from '@/app/games/tank-trouble/utils/math';\nimport { COLLISION_SIZE_BUFFER, HIGH_THREAT_DISTANCE_MULTIPLIER } from '@/app/games/tank-trouble/constants/game-constants';\n\n/**\n * Assess threats from incoming bullets\n */\nexport function assessThreats(\n  tank: Tank,\n  bullets: Bullet[],\n  suns: Sun[],\n  barriers: Barrier[],\n  mapWidth: number,\n  mapHeight: number,\n  maxPredictionTime: number\n): Threat[] {\n  const threats: Threat[] = [];\n\n  for (const bullet of bullets) {\n    // Skip own bullets and exploding bullets\n    if (bullet.owner === tank.color || bullet.exploding) {\n      continue;\n    }\n\n    // Predict bullet path\n    const path = predictBulletPath(\n      bullet,\n      suns,\n      barriers,\n      mapWidth,\n      mapHeight,\n      maxPredictionTime,\n      16 // Use smaller steps for accuracy\n    );\n\n    // Check if path gets close to tank\n    let closestDistance = Infinity;\n    let closestTime = 0;\n    let collisionPoint = { x: bullet.x, y: bullet.y };\n\n    // Calculate tank center once (reused for all points)\n    const tankCenter = getTankCenter(tank);\n    const hitThreshold = TANK_COLLISION_SIZE + COLLISION_SIZE_BUFFER;\n\n    // Early exit optimization: if we find a collision, break immediately\n    for (const point of path.points) {\n      // Distance from bullet to tank center\n      const dist = distance(point.x, point.y, tankCenter.x, tankCenter.y);\n\n      // Check if bullet would hit tank (within collision size)\n      if (dist < hitThreshold) {\n        closestDistance = dist;\n        closestTime = point.time;\n        collisionPoint = { x: point.x, y: point.y };\n        break; // Early exit when collision detected\n      }\n\n      if (dist < closestDistance) {\n        closestDistance = dist;\n        closestTime = point.time;\n        collisionPoint = { x: point.x, y: point.y };\n      }\n    }\n\n    // Calculate threat level based on distance and time\n    const threatDistanceThreshold = TANK_COLLISION_SIZE * HIGH_THREAT_DISTANCE_MULTIPLIER;\n    if (closestDistance < threatDistanceThreshold) {\n      // High threat if very close\n      const timeFactor = Math.max(0, 1 - closestTime / maxPredictionTime);\n      const distanceFactor = Math.max(\n        0,\n        1 - closestDistance / threatDistanceThreshold\n      );\n      const threatLevel = (timeFactor + distanceFactor) / 2;\n\n      threats.push({\n        bullet,\n        timeToCollision: closestTime,\n        closestDistance,\n        collisionPoint,\n        threatLevel: Math.min(1, threatLevel),\n      });\n    }\n  }\n\n  // Sort by threat level (most dangerous first)\n  threats.sort((a, b) => b.threatLevel - a.threatLevel);\n\n  return threats;\n}\n\n/**\n * Check if a position is safe from bullets\n */\nexport function isPositionSafe(\n  x: number,\n  y: number,\n  bullets: Bullet[],\n  suns: Sun[],\n  barriers: Barrier[],\n  mapWidth: number,\n  mapHeight: number,\n  predictionTime: number,\n  safeMargin: number\n): boolean {\n  // Check each bullet\n  for (const bullet of bullets) {\n    if (bullet.exploding) continue;\n\n    const path = predictBulletPath(\n      bullet,\n      suns,\n      barriers,\n      mapWidth,\n      mapHeight,\n      predictionTime,\n      16\n    );\n\n    // Check if any point gets too close (early exit optimization)\n    const safeDistance = TANK_COLLISION_SIZE + safeMargin;\n    for (const point of path.points) {\n      const dist = distance(point.x, point.y, x, y);\n      if (dist < safeDistance) {\n        return false; // Early exit when unsafe position found\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Find escape direction from threats\n */\nexport function findEscapeDirection(\n  tank: Tank,\n  threats: Threat[],\n  barriers: Barrier[],\n  suns: Sun[],\n  mapWidth: number,\n  mapHeight: number\n): { angle: number; urgency: number } {\n  if (threats.length === 0) {\n    return { angle: tank.angle, urgency: 0 };\n  }\n\n  // Find the most urgent threat\n  const urgentThreat = threats[0];\n  if (urgentThreat.threatLevel < 0.5) {\n    return { angle: tank.angle, urgency: urgentThreat.threatLevel };\n  }\n\n  // Calculate direction away from threat\n  const tankCenter = getTankCenter(tank);\n  const dist = distance(tankCenter.x, tankCenter.y, urgentThreat.collisionPoint.x, urgentThreat.collisionPoint.y);\n\n  if (dist < 1) {\n    // Too close, pick random direction\n    return { angle: (tank.angle + 90) % 360, urgency: 1 };\n  }\n\n  const escapeAngle = angleToPoint(urgentThreat.collisionPoint, tankCenter);\n\n  return {\n    angle: escapeAngle,\n    urgency: urgentThreat.threatLevel,\n  };\n}\n\n\n","import type { Sun, Tank, Barrier } from '@/app/games/tank-trouble/types';\nimport type { ShotOpportunity } from './types';\nimport { predictBulletPath } from './prediction';\nimport { BULLET_SPEED, TANK_SIZE, GAME_CONFIG, TICK_INTERVAL } from '@/app/games/tank-trouble/config';\nimport { applyGravityFromSources, type Vector2D } from '@/lib/physics';\nimport { G, mSun, SUN_INFLUENCE_RADIUS } from '@/app/games/tank-trouble/config';\n\n/**\n * Calculate if a shot will curve around a sun to hit the target\n */\nexport function findSunLeveragedShot(\n  shooter: Tank,\n  target: { x: number; y: number },\n  suns: Sun[],\n  barriers: Barrier[],\n  mapWidth: number,\n  mapHeight: number,\n  sunSkill: number\n): ShotOpportunity | null {\n  // Only attempt sun shots if skill is high enough\n  if (sunSkill < 0.3 || suns.length === 0) {\n    return null;\n  }\n\n  let bestShot: ShotOpportunity | null = null;\n  let bestConfidence = 0;\n\n  // Check each sun for potential leverage\n  for (const sun of suns) {\n    // Find angles that will curve around this sun toward target\n    const anglesToTest = 16; // Test multiple angles\n    const angleSpread = 60; // Test ±60 degrees\n\n    for (let i = 0; i < anglesToTest; i++) {\n      const baseAngle = Math.atan2(\n        target.y - (shooter.y + TANK_SIZE / 2),\n        target.x - (shooter.x + TANK_SIZE / 2)\n      );\n      const testAngle =\n        (baseAngle * 180) / Math.PI +\n        (i / (anglesToTest - 1) - 0.5) * angleSpread;\n\n      // Create test bullet\n      const rad = (testAngle * Math.PI) / 180;\n      const bulletX =\n        shooter.x +\n        TANK_SIZE / 2 +\n        Math.cos(rad) * (TANK_SIZE / 2 + GAME_CONFIG.tank.spawnOffset);\n      const bulletY =\n        shooter.y +\n        TANK_SIZE / 2 +\n        Math.sin(rad) * (TANK_SIZE / 2 + GAME_CONFIG.tank.spawnOffset);\n\n      const testBullet = {\n        x: bulletX,\n        y: bulletY,\n        angle: testAngle,\n        speed: BULLET_SPEED,\n        owner: shooter.color,\n        createdAt: 0,\n        vx: Math.cos(rad) * BULLET_SPEED,\n        vy: Math.sin(rad) * BULLET_SPEED,\n      };\n\n      // Predict path\n      const path = predictBulletPath(\n        testBullet,\n        suns,\n        barriers,\n        mapWidth,\n        mapHeight,\n        3000,\n        TICK_INTERVAL\n      );\n\n      // Check if path gets close to target\n      let closestDistance = Infinity;\n      let closestTime = 0;\n\n      for (const point of path.points) {\n        const dx = point.x - target.x;\n        const dy = point.y - target.y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n\n        if (dist < closestDistance) {\n          closestDistance = dist;\n          closestTime = point.time;\n        }\n\n        // Hit if within tank collision size\n        if (dist < 15) {\n          const confidence = sunSkill * (1 - Math.min(closestDistance / 30, 1));\n          if (confidence > bestConfidence) {\n            bestConfidence = confidence;\n            bestShot = {\n              angle: testAngle,\n              confidence,\n              timeToHit: closestTime,\n              usesSun: true,\n            };\n          }\n        }\n      }\n    }\n  }\n\n  return bestShot;\n}\n\n/**\n * Check if a position is shielded by a sun from another position\n */\nexport function isPositionShieldedBySun(\n  position: { x: number; y: number },\n  attackerPosition: { x: number; y: number },\n  suns: Sun[]\n): boolean {\n  for (const sun of suns) {\n    // Check if sun is between position and attacker\n    const dxToSun = sun.x - position.x;\n    const dyToSun = sun.y - position.y;\n    const dxToAttacker = attackerPosition.x - position.x;\n    const dyToAttacker = attackerPosition.y - position.y;\n\n    // Dot product to check if sun is in same direction as attacker\n    const dot = dxToSun * dxToAttacker + dyToSun * dyToAttacker;\n\n    if (dot > 0) {\n      // Sun is in same direction, check distance\n      const distToSun = Math.sqrt(dxToSun * dxToSun + dyToSun * dyToSun);\n      const distToAttacker = Math.sqrt(\n        dxToAttacker * dxToAttacker + dyToAttacker * dyToAttacker\n      );\n\n      // If sun is closer and large enough to block, we're shielded\n      if (distToSun < distToAttacker && distToSun < sun.size * 2) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Find the best angle to shoot at target considering sun gravity\n * Returns direct shot if better, or sun-leveraged shot\n */\nexport function calculateOptimalShotAngle(\n  shooter: Tank,\n  target: { x: number; y: number },\n  suns: Sun[],\n  barriers: Barrier[],\n  mapWidth: number,\n  mapHeight: number,\n  sunSkill: number\n): ShotOpportunity {\n  // First, try direct shot\n  const directAngle =\n    (Math.atan2(\n      target.y - (shooter.y + TANK_SIZE / 2),\n      target.x - (shooter.x + TANK_SIZE / 2)\n    ) *\n      180) /\n    Math.PI;\n\n  const rad = (directAngle * Math.PI) / 180;\n  const bulletX =\n    shooter.x +\n    TANK_SIZE / 2 +\n    Math.cos(rad) * (TANK_SIZE / 2 + GAME_CONFIG.tank.spawnOffset);\n  const bulletY =\n    shooter.y +\n    TANK_SIZE / 2 +\n    Math.sin(rad) * (TANK_SIZE / 2 + GAME_CONFIG.tank.spawnOffset);\n\n  const testBullet = {\n    x: bulletX,\n    y: bulletY,\n    angle: directAngle,\n    speed: BULLET_SPEED,\n    owner: shooter.color,\n    createdAt: 0,\n    vx: Math.cos(rad) * BULLET_SPEED,\n    vy: Math.sin(rad) * BULLET_SPEED,\n  };\n\n  const directPath = predictBulletPath(\n    testBullet,\n    suns,\n    barriers,\n    mapWidth,\n    mapHeight,\n    3000,\n    TICK_INTERVAL\n  );\n\n  let directConfidence = 0;\n  for (const point of directPath.points) {\n    const dx = point.x - target.x;\n    const dy = point.y - target.y;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    if (dist < 15) {\n      directConfidence = 0.8;\n      break;\n    }\n  }\n\n  // Try sun-leveraged shot\n  const sunShot = findSunLeveragedShot(\n    shooter,\n    target,\n    suns,\n    barriers,\n    mapWidth,\n    mapHeight,\n    sunSkill\n  );\n\n  // Return best shot\n  if (sunShot && sunShot.confidence > directConfidence) {\n    return sunShot;\n  }\n\n  return {\n    angle: directAngle,\n    confidence: directConfidence,\n    timeToHit: 1000, // Estimate\n    usesSun: false,\n  };\n}\n\n\n","import type { Tank, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport { canMoveTo } from '@/app/games/tank-trouble/utils/collision';\nimport { TANK_SPEED, ROTATION_SPEED } from '@/app/games/tank-trouble/config';\n\n/**\n * Find optimal position relative to enemy\n */\nexport function calculateOptimalPosition(\n  aiTank: Tank,\n  enemyTank: Tank,\n  aggressiveness: number,\n  barriers: Barrier[],\n  suns: Sun[],\n  mapWidth: number,\n  mapHeight: number\n): { x: number; y: number; angle: number } {\n  const aiCenterX = aiTank.x + 12; // Half of TANK_SIZE\n  const aiCenterY = aiTank.y + 12;\n  const enemyCenterX = enemyTank.x + 12;\n  const enemyCenterY = enemyTank.y + 12;\n\n  // Calculate distance to enemy\n  const dx = enemyCenterX - aiCenterX;\n  const dy = enemyCenterY - aiCenterY;\n  const distance = Math.sqrt(dx * dx + dy * dy);\n\n  // Much more aggressive: always move toward enemy, minimal ideal distance\n  // Reduced ideal distance significantly to encourage close combat\n  const idealDistance = 50 + (1 - aggressiveness) * 50; // Reduced from 100 + (1-aggressiveness)*100\n\n  // Calculate angle toward enemy (always approach, never retreat)\n  const angleToEnemy = (Math.atan2(dy, dx) * 180) / Math.PI;\n\n  // Always try to move closer to enemy (removed retreat logic)\n  // Only stop approaching if already very close (within 30 pixels)\n  let targetX = enemyCenterX;\n  let targetY = enemyCenterY;\n\n  if (distance > 30) {\n    // Always move closer if not extremely close\n    const approachAngle = angleToEnemy;\n    // Move to ideal distance, but if already closer, still move forward (just slower)\n    const targetDistance = Math.min(distance * 0.8, idealDistance); // Always reduce distance by 20% minimum\n    targetX =\n      enemyCenterX - Math.cos((approachAngle * Math.PI) / 180) * targetDistance;\n    targetY =\n      enemyCenterY - Math.sin((approachAngle * Math.PI) / 180) * targetDistance;\n  } else {\n    // Very close - stay at current distance but keep facing enemy\n    targetX = aiCenterX;\n    targetY = aiCenterY;\n  }\n\n  // Clamp to map bounds\n  targetX = Math.max(12, Math.min(targetX, mapWidth - 12));\n  targetY = Math.max(12, Math.min(targetY, mapHeight - 12));\n\n  // Calculate angle toward target\n  const targetDx = targetX - aiCenterX;\n  const targetDy = targetY - aiCenterY;\n  const targetAngle =\n    (Math.atan2(targetDy, targetDx) * 180) / Math.PI;\n\n  return {\n    x: targetX - 12, // Convert center to corner\n    y: targetY - 12,\n    angle: targetAngle,\n  };\n}\n\n/**\n * Check if a path is clear to a position\n */\nexport function isPathClear(\n  from: { x: number; y: number },\n  to: { x: number; y: number },\n  barriers: Barrier[],\n  suns: Sun[],\n  tanks: Tank[],\n  mapWidth: number,\n  mapHeight: number,\n  excludeTankIndex?: number\n): boolean {\n  // Simple line-of-sight check (could be improved with proper pathfinding)\n  const steps = 20;\n  const dx = (to.x - from.x) / steps;\n  const dy = (to.y - from.y) / steps;\n\n  for (let i = 0; i <= steps; i++) {\n    const testX = from.x + dx * i;\n    const testY = from.y + dy * i;\n\n    if (\n      !canMoveTo(\n        testX,\n        testY,\n        mapWidth,\n        mapHeight,\n        barriers,\n        tanks,\n        suns,\n        excludeTankIndex\n      )\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Find a safe nearby position when dodging\n */\nexport function findSafeDodgePosition(\n  tank: Tank,\n  dodgeAngle: number,\n  dodgeDistance: number,\n  barriers: Barrier[],\n  suns: Sun[],\n  allTanks: Tank[],\n  mapWidth: number,\n  mapHeight: number,\n  tankIndex: number\n): { x: number; y: number } | null {\n  const rad = (dodgeAngle * Math.PI) / 180;\n  const targetX = tank.x + Math.cos(rad) * dodgeDistance;\n  const targetY = tank.y + Math.sin(rad) * dodgeDistance;\n\n  // Check if target position is valid\n  if (\n    canMoveTo(\n      targetX,\n      targetY,\n      mapWidth,\n      mapHeight,\n      barriers,\n      allTanks,\n      suns,\n      tankIndex\n    )\n  ) {\n    return { x: targetX, y: targetY };\n  }\n\n  // Try perpendicular directions\n  const perpAngle1 = (dodgeAngle + 90) % 360;\n  const perpAngle2 = (dodgeAngle - 90 + 360) % 360;\n\n  for (const angle of [perpAngle1, perpAngle2]) {\n    const rad = (angle * Math.PI) / 180;\n    const testX = tank.x + Math.cos(rad) * dodgeDistance;\n    const testY = tank.y + Math.sin(rad) * dodgeDistance;\n\n    if (\n      canMoveTo(\n        testX,\n        testY,\n        mapWidth,\n        mapHeight,\n        barriers,\n        allTanks,\n        suns,\n        tankIndex\n      )\n    ) {\n      return { x: testX, y: testY };\n    }\n  }\n\n  // Try smaller distance\n  if (dodgeDistance > 20) {\n    return findSafeDodgePosition(\n      tank,\n      dodgeAngle,\n      dodgeDistance * 0.5,\n      barriers,\n      suns,\n      allTanks,\n      mapWidth,\n      mapHeight,\n      tankIndex\n    );\n  }\n\n  return null;\n}\n\n\n","/**\n * Action Configuration - Shared with Go backend\n * \n * This file reads from the shared game-config.json to ensure\n * action definitions stay in sync between Go and TypeScript\n */\n\nimport gameConfig from '@/shared/config/game-config.json';\n\n// Get NUM_DISCRETE_ACTIONS from shared config\nexport const NUM_DISCRETE_ACTIONS = gameConfig.rl.action.numDiscreteActions;\n\n// Action definitions from shared config\nexport type ActionDefinition = {\n  id: number;\n  name: string;\n  description: string;\n};\n\nexport const ACTION_DEFINITIONS: ActionDefinition[] = gameConfig.rl.action.actions;\n\n// Create a map for quick lookup\nexport const ACTION_BY_ID = new Map<number, ActionDefinition>(\n  ACTION_DEFINITIONS.map(action => [action.id, action])\n);\n\nexport const ACTION_BY_NAME = new Map<string, ActionDefinition>(\n  ACTION_DEFINITIONS.map(action => [action.name, action])\n);\n\n// Action type (0-13)\nexport type DiscreteAction = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13;\n\n// Validate that actions are properly defined\nif (ACTION_DEFINITIONS.length !== NUM_DISCRETE_ACTIONS) {\n  console.warn(\n    `Warning: Action definitions count (${ACTION_DEFINITIONS.length}) doesn't match ` +\n    `NUM_DISCRETE_ACTIONS (${NUM_DISCRETE_ACTIONS}) in config`\n  );\n}\n\n// Validate action IDs are sequential 0..N-1\nfor (let i = 0; i < ACTION_DEFINITIONS.length; i++) {\n  if (ACTION_DEFINITIONS[i].id !== i) {\n    console.warn(\n      `Warning: Action at index ${i} has ID ${ACTION_DEFINITIONS[i].id}, expected ${i}`\n    );\n  }\n}\n\n","/**\n * Action Conversion Utilities\n * \n * Converts between keyboard input and discrete action numbers (0-13)\n * Matching the Go backend's action space\n * \n * Action definitions are standardized in shared/config/game-config.json\n */\n\nimport type { AIDecision } from './types';\nimport { ROTATION_SPEED } from '@/app/games/tank-trouble/config';\nimport { NUM_DISCRETE_ACTIONS, type DiscreteAction, type ActionDefinition, ACTION_DEFINITIONS } from './rl-action-config';\n\nexport { NUM_DISCRETE_ACTIONS, type DiscreteAction, type ActionDefinition };\n\nexport type ContinuousAction = AIDecision;\n\n/**\n * Convert keyboard input to discrete action number\n * \n * Action definitions come from shared/config/game-config.json to ensure\n * consistency with Go backend. See ACTION_DEFINITIONS for the full list.\n * \n * @param keys - Set of currently pressed keys (from useGameInput)\n * @param controls - Player control mappings (defaults to Player 1: Arrow keys + Space)\n * @returns Action number (0-13) matching ACTION_DEFINITIONS\n */\nexport function keysToAction(\n  keys: Set<string>,\n  controls: {\n    rotateLeft: string;\n    rotateRight: string;\n    moveForward: string;\n    moveBackward: string;\n    shoot: string;\n  } = {\n    rotateLeft: 'arrowleft',\n    rotateRight: 'arrowright',\n    moveForward: 'arrowup',\n    moveBackward: 'arrowdown',\n    shoot: ' ',\n  }\n): number {\n  const rotateLeft = keys.has(controls.rotateLeft);\n  const rotateRight = keys.has(controls.rotateRight);\n  const moveForward = keys.has(controls.moveForward);\n  const moveBackward = keys.has(controls.moveBackward);\n  const shoot = keys.has(controls.shoot);\n\n  // Check for shooting actions first (they take priority)\n  if (shoot) {\n    if (moveForward) {\n      return 10; // MOVE_FORWARD_SHOOT\n    } else if (moveBackward) {\n      return 11; // MOVE_BACKWARD_SHOOT\n    } else if (rotateLeft) {\n      return 8; // ROTATE_LEFT_SHOOT\n    } else if (rotateRight) {\n      return 9; // ROTATE_RIGHT_SHOOT\n    }\n    return 5; // SHOOT\n  }\n\n  // Movement actions\n  if (moveForward) {\n    if (rotateLeft) {\n      return 6; // ROTATE_LEFT_FORWARD\n    } else if (rotateRight) {\n      return 7; // ROTATE_RIGHT_FORWARD\n    }\n    return 3; // MOVE_FORWARD\n  } else if (moveBackward) {\n    if (rotateLeft) {\n      return 12; // ROTATE_LEFT_BACKWARD\n    } else if (rotateRight) {\n      return 13; // ROTATE_RIGHT_BACKWARD\n    }\n    return 4; // MOVE_BACKWARD\n  }\n\n  // Rotation-only actions\n  if (rotateLeft) {\n    return 1; // ROTATE_LEFT\n  } else if (rotateRight) {\n    return 2; // ROTATE_RIGHT\n  }\n\n  return 0; // NO_ACTION\n}\n\n/**\n * Convert discrete action number to AIDecision\n * This is the reverse of keysToAction - converts action (0-13) to game decision\n * \n * @param action - Discrete action number (0-13)\n * @param currentAngle - Current tank angle in degrees (not used, but matches Go signature)\n * @returns AIDecision object with angleDelta, moveDirection, and shouldShoot\n */\nexport function actionToDecision(action: number, currentAngle: number): AIDecision {\n  const decision: AIDecision = {\n    angleDelta: 0,\n    moveDirection: 0,\n    shouldShoot: false,\n  };\n\n  switch (action) {\n    case 0: // NO_ACTION\n      // Do nothing\n      break;\n    case 1: // ROTATE_LEFT\n      decision.angleDelta = -ROTATION_SPEED;\n      break;\n    case 2: // ROTATE_RIGHT\n      decision.angleDelta = ROTATION_SPEED;\n      break;\n    case 3: // MOVE_FORWARD\n      decision.moveDirection = 1;\n      break;\n    case 4: // MOVE_BACKWARD\n      decision.moveDirection = -1;\n      break;\n    case 5: // SHOOT\n      decision.shouldShoot = true;\n      break;\n    case 6: // ROTATE_LEFT_FORWARD\n      decision.angleDelta = -ROTATION_SPEED;\n      decision.moveDirection = 1;\n      break;\n    case 7: // ROTATE_RIGHT_FORWARD\n      decision.angleDelta = ROTATION_SPEED;\n      decision.moveDirection = 1;\n      break;\n    case 8: // ROTATE_LEFT_SHOOT\n      decision.angleDelta = -ROTATION_SPEED;\n      decision.shouldShoot = true;\n      break;\n    case 9: // ROTATE_RIGHT_SHOOT\n      decision.angleDelta = ROTATION_SPEED;\n      decision.shouldShoot = true;\n      break;\n    case 10: // MOVE_FORWARD_SHOOT\n      decision.moveDirection = 1;\n      decision.shouldShoot = true;\n      break;\n    case 11: // MOVE_BACKWARD_SHOOT\n      decision.moveDirection = -1;\n      decision.shouldShoot = true;\n      break;\n    case 12: // ROTATE_LEFT_BACKWARD\n      decision.angleDelta = -ROTATION_SPEED;\n      decision.moveDirection = -1;\n      break;\n    case 13: // ROTATE_RIGHT_BACKWARD\n      decision.angleDelta = ROTATION_SPEED;\n      decision.moveDirection = -1;\n      break;\n    default:\n      // Unknown action, do nothing\n      break;\n  }\n\n  return decision;\n}\n\n/**\n * Convert AIDecision to discrete action number\n * This is the reverse of actionToDecision\n * \n * @param decision - AIDecision object\n * @returns Discrete action number (0-13)\n */\nexport function decisionToAction(decision: AIDecision): number {\n  // Check for shooting actions first (they take priority)\n  if (decision.shouldShoot) {\n    if (decision.moveDirection > 0) {\n      return 10; // MOVE_FORWARD_SHOOT\n    } else if (decision.moveDirection < 0) {\n      return 11; // MOVE_BACKWARD_SHOOT\n    } else if (decision.angleDelta < 0) {\n      return 8; // ROTATE_LEFT_SHOOT\n    } else if (decision.angleDelta > 0) {\n      return 9; // ROTATE_RIGHT_SHOOT\n    }\n    return 5; // SHOOT\n  }\n\n  // Movement actions\n  if (decision.moveDirection > 0) {\n    if (decision.angleDelta < 0) {\n      return 6; // ROTATE_LEFT_FORWARD\n    } else if (decision.angleDelta > 0) {\n      return 7; // ROTATE_RIGHT_FORWARD\n    }\n    return 3; // MOVE_FORWARD\n  } else if (decision.moveDirection < 0) {\n    if (decision.angleDelta < 0) {\n      return 12; // ROTATE_LEFT_BACKWARD\n    } else if (decision.angleDelta > 0) {\n      return 13; // ROTATE_RIGHT_BACKWARD\n    }\n    return 4; // MOVE_BACKWARD\n  }\n\n  // Rotation-only actions\n  if (decision.angleDelta < 0) {\n    return 1; // ROTATE_LEFT\n  } else if (decision.angleDelta > 0) {\n    return 2; // ROTATE_RIGHT\n  }\n\n  return 0; // NO_ACTION\n}\n\n// Type alias for DecisionToAction (used in rl-environment.ts)\nexport type DecisionToAction = typeof decisionToAction;\n","/**\n * Observation Space Definition\n * \n * Converts game state into a numerical observation vector for the RL agent.\n * The observation should be normalized and contain all relevant information.\n */\n\nimport type { Tank, Bullet, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport type { AIContext } from './types';\nimport { TANK_SIZE, TANK_SPEED, BULLET_SPEED } from '@/app/games/tank-trouble/config';\n\n// Cache for barrier bounds (barriers are static during gameplay)\ninterface BarrierBounds {\n  left: number;\n  right: number;\n  top: number;\n  bottom: number;\n}\nlet cachedBarrierBounds: BarrierBounds[] | null = null;\nlet cachedBarriersReference: Barrier[] | null = null;\n\n/**\n * Get or compute barrier bounds (cached for performance)\n */\nfunction getBarrierBounds(barriers: Barrier[]): BarrierBounds[] {\n  // Check if barriers array reference changed\n  if (cachedBarrierBounds === null || cachedBarriersReference !== barriers) {\n    cachedBarrierBounds = barriers.map(barrier => ({\n      left: barrier.x,\n      right: barrier.x + barrier.width,\n      top: barrier.y,\n      bottom: barrier.y + barrier.height,\n    }));\n    cachedBarriersReference = barriers;\n  }\n  return cachedBarrierBounds;\n}\n\n/**\n * Observation vector structure\n * \n * This is a flattened array of normalized features:\n * - Tank positions and angles (normalized 0-1)\n * - Enemy positions and angles\n * - Bullet states (fixed-size array)\n * - Sun positions (fixed-size array)\n * - Barrier distances (8 directions)\n * - Game state (lives, time, etc.)\n */\nexport interface Observation {\n  vector: number[];\n  size: number;\n}\n\n// Constants for observation space\nconst MAX_BULLETS = 20; // Maximum bullets to track\nconst MAX_SUNS = 10; // Maximum suns to track\nconst BARRIER_DIRECTIONS = 8; // 8 directions for barrier detection\nconst BULLET_FEATURES = 5; // x, y, vx, vy, owner\nconst SUN_FEATURES = 3; // x, y, size\n\n/**\n * Extract observation from game context\n * \n * Returns a normalized feature vector that the RL agent can use.\n */\nexport function extractObservation(context: AIContext): Observation {\n  const {\n    aiTank,\n    enemyTank,\n    bullets,\n    suns,\n    barriers,\n    mapWidth,\n    mapHeight,\n  } = context;\n\n  const features: number[] = [];\n\n  // 1. AI Tank state (4 features)\n  features.push(normalize(aiTank.x, 0, mapWidth));\n  features.push(normalize(aiTank.y, 0, mapHeight));\n  features.push(normalizeAngle(aiTank.angle));\n  features.push(normalize(aiTank.lives, 0, 3));\n\n  // 2. Enemy Tank state (4 features)\n  features.push(normalize(enemyTank.x, 0, mapWidth));\n  features.push(normalize(enemyTank.y, 0, mapHeight));\n  features.push(normalizeAngle(enemyTank.angle));\n  features.push(normalize(enemyTank.lives, 0, 3));\n\n  // 3. Relative position and distance (3 features)\n  const dx = enemyTank.x - aiTank.x;\n  const dy = enemyTank.y - aiTank.y;\n  const distance = Math.sqrt(dx * dx + dy * dy);\n  const maxDistance = Math.sqrt(mapWidth * mapWidth + mapHeight * mapHeight);\n  \n  features.push(normalize(dx, -mapWidth, mapWidth));\n  features.push(normalize(dy, -mapHeight, mapHeight));\n  features.push(normalize(distance, 0, maxDistance));\n\n  // 4. Angle to enemy (1 feature)\n  const angleToEnemy = (Math.atan2(dy, dx) * 180) / Math.PI;\n  const angleDiff = normalizeAngleDifference(angleToEnemy - aiTank.angle);\n  features.push(angleDiff);\n\n  // 5. Bullet states (MAX_BULLETS * BULLET_FEATURES features)\n  // Optimized: single pass to collect active bullets (avoid filter + slice creating intermediate array)\n  const activeBullets: Bullet[] = [];\n  for (let i = 0; i < bullets.length && activeBullets.length < MAX_BULLETS; i++) {\n    const bullet = bullets[i];\n    if (!bullet.exploding) {\n      activeBullets.push(bullet);\n    }\n  }\n  \n  for (let i = 0; i < MAX_BULLETS; i++) {\n    if (i < activeBullets.length) {\n      const bullet = activeBullets[i];\n      features.push(normalize(bullet.x, 0, mapWidth));\n      features.push(normalize(bullet.y, 0, mapHeight));\n      features.push(normalize(bullet.vx, -BULLET_SPEED * 2, BULLET_SPEED * 2));\n      features.push(normalize(bullet.vy, -BULLET_SPEED * 2, BULLET_SPEED * 2));\n      features.push(bullet.owner === aiTank.color ? 1 : 0); // Owner (0 or 1)\n    } else {\n      // Pad with zeros\n      features.push(0, 0, 0, 0, 0);\n    }\n  }\n\n  // 6. Sun states (MAX_SUNS * SUN_FEATURES features)\n  const activeSuns = (suns || []).slice(0, MAX_SUNS);\n  for (let i = 0; i < MAX_SUNS; i++) {\n    if (i < activeSuns.length) {\n      const sun = activeSuns[i];\n      features.push(normalize(sun.x, 0, mapWidth));\n      features.push(normalize(sun.y, 0, mapHeight));\n      features.push(normalize(sun.size, 0, 100));\n    } else {\n      features.push(0, 0, 0);\n    }\n  }\n\n  // 7. Barrier distances in 8 directions (BARRIER_DIRECTIONS features)\n  const barrierDistances = getBarrierDistances(\n    aiTank.x + TANK_SIZE / 2,\n    aiTank.y + TANK_SIZE / 2,\n    barriers,\n    mapWidth,\n    mapHeight\n  );\n  features.push(...barrierDistances.map(d => normalize(d, 0, Math.max(mapWidth, mapHeight))));\n\n  // 8. Game state (2 features)\n  features.push(normalize(context.tickTime % 10000, 0, 10000)); // Time modulo\n  features.push(normalize(mapWidth, 0, 2000)); // Map size indicator\n\n  // Total: 4 + 4 + 3 + 1 + (20 * 5) + (10 * 3) + 8 + 2 = 152 features\n\n  return {\n    vector: features,\n    size: features.length,\n  };\n}\n\n/**\n * Normalize a value to [0, 1] range\n */\nfunction normalize(value: number, min: number, max: number): number {\n  if (max === min) return 0.5;\n  return Math.max(0, Math.min(1, (value - min) / (max - min)));\n}\n\n/**\n * Normalize angle to [0, 1] range (0-360 degrees -> 0-1)\n */\nfunction normalizeAngle(angle: number): number {\n  // Normalize angle to 0-360\n  let normalized = angle % 360;\n  if (normalized < 0) normalized += 360;\n  return normalized / 360;\n}\n\n/**\n * Normalize angle difference to [-1, 1] range\n */\nfunction normalizeAngleDifference(angleDiff: number): number {\n  // Normalize to -180 to 180\n  while (angleDiff > 180) angleDiff -= 360;\n  while (angleDiff < -180) angleDiff += 360;\n  return angleDiff / 180; // Normalize to -1 to 1\n}\n\n/**\n * Get distances to nearest barriers in 8 directions\n * Optimized with pre-computed barrier bounds\n */\nfunction getBarrierDistances(\n  x: number,\n  y: number,\n  barriers: Barrier[],\n  mapWidth: number,\n  mapHeight: number\n): number[] {\n  const directions = [\n    { dx: 1, dy: 0 },   // Right\n    { dx: 1, dy: 1 },   // Down-right\n    { dx: 0, dy: 1 },   // Down\n    { dx: -1, dy: 1 },  // Down-left\n    { dx: -1, dy: 0 },  // Left\n    { dx: -1, dy: -1 }, // Up-left\n    { dx: 0, dy: -1 },  // Up\n    { dx: 1, dy: -1 },  // Up-right\n  ];\n\n  // Get cached barrier bounds (only recomputed if barriers array reference changes)\n  const barrierBounds = getBarrierBounds(barriers);\n\n  const step = 5; // Check every 5 pixels\n  const maxDistance = Math.max(mapWidth, mapHeight);\n\n  return directions.map(dir => {\n    let distance = 0;\n\n    while (distance < maxDistance) {\n      const testX = x + dir.dx * distance;\n      const testY = y + dir.dy * distance;\n\n      // Check if out of bounds\n      if (testX < 0 || testX > mapWidth || testY < 0 || testY > mapHeight) {\n        break;\n      }\n\n      // Use pre-computed bounds for faster barrier check\n      // Early exit when barrier found\n      let hitBarrier = false;\n      for (const bounds of barrierBounds) {\n        if (\n          testX >= bounds.left &&\n          testX <= bounds.right &&\n          testY >= bounds.top &&\n          testY <= bounds.bottom\n        ) {\n          hitBarrier = true;\n          break;\n        }\n      }\n\n      if (hitBarrier) {\n        break;\n      }\n\n      distance += step;\n    }\n\n    return distance;\n  });\n}\n\n/**\n * Get observation size (for model initialization)\n */\nexport function getObservationSize(): number {\n  return 4 + 4 + 3 + 1 + (MAX_BULLETS * BULLET_FEATURES) + (MAX_SUNS * SUN_FEATURES) + BARRIER_DIRECTIONS + 2;\n}\n\n","/**\n * RL Model Interface\n * \n * Defines the interface for RL models and provides a way to load/use\n * trained models. Supports both TensorFlow.js models and custom implementations.\n */\n\nimport type { Observation } from './rl-observation';\nimport type { AIDecision } from './types';\nimport { actionToDecision } from './rl-actions';\nimport { NUM_DISCRETE_ACTIONS } from './rl-actions';\nimport { getObservationSize } from './rl-observation';\n\n/**\n * RL Model interface\n * \n * Any RL model implementation should implement this interface.\n */\nexport interface RLModel {\n  /**\n   * Check if model is loaded and ready\n   */\n  isLoaded(): boolean;\n\n  /**\n   * Load model from URL or path\n   */\n  load(path: string): Promise<void>;\n\n  /**\n   * Predict action from observation\n   * \n   * @param observation - Current game observation\n   * @param currentAngle - Current tank angle (for action conversion)\n   * @returns Promise that resolves to decision for the tank\n   * \n   * Note: Made async to support TensorFlow.js operations which are inherently async\n   */\n  predict(observation: Observation, currentAngle: number): Promise<AIDecision>;\n\n  /**\n   * Get model info\n   */\n  getInfo(): ModelInfo;\n}\n\nexport interface ModelInfo {\n  name: string;\n  type: 'discrete' | 'continuous';\n  observationSize: number;\n  actionSize: number;\n  version?: string;\n}\n\n/**\n * Simple rule-based model (for testing/fallback)\n * \n * This can be used as a baseline or fallback when RL model isn't available.\n */\nexport class RuleBasedRLModel implements RLModel {\n  private loaded = true;\n\n  isLoaded(): boolean {\n    return this.loaded;\n  }\n\n  async load(_path: string): Promise<void> {\n    this.loaded = true;\n  }\n\n  async predict(observation: Observation, currentAngle: number): Promise<AIDecision> {\n    // Simple rule-based decision based on observation\n    // This is just a placeholder - in practice, you'd use a trained model\n    \n    // Extract some key features\n    const enemyX = observation.vector[4];\n    const enemyY = observation.vector[5];\n    const angleToEnemy = observation.vector[11]; // Normalized angle difference\n    \n    // Simple strategy: rotate toward enemy and shoot\n    let angleDelta = 0;\n    let moveDirection = 0;\n    let shouldShoot = false;\n\n    // Rotate toward enemy\n    if (Math.abs(angleToEnemy) > 0.1) {\n      angleDelta = angleToEnemy > 0 ? 5 : -5;\n    }\n\n    // Move forward if roughly facing enemy\n    if (Math.abs(angleToEnemy) < 0.2) {\n      moveDirection = 1;\n      shouldShoot = true;\n    }\n\n    return {\n      angleDelta,\n      moveDirection,\n      shouldShoot,\n    };\n  }\n\n  getInfo(): ModelInfo {\n    return {\n      name: 'Rule-Based Fallback',\n      type: 'discrete',\n      observationSize: getObservationSize(), // From rl-observation.ts\n      actionSize: NUM_DISCRETE_ACTIONS,\n    };\n  }\n}\n\n/**\n * TensorFlow.js model wrapper\n * \n * This is a placeholder for when you implement TensorFlow.js integration.\n * To use this, you'll need to:\n * 1. Install @tensorflow/tfjs\n * 2. Train a model (Python or TypeScript)\n * 3. Export it in a format TensorFlow.js can load\n * 4. Implement the predict method\n */\n// Extended interface for models that need additional properties\n// This properly extends RLModel with all required methods\nexport interface ExtendedRLModel extends RLModel {\n  // Additional properties for agent integration\n  agent?: unknown;\n}\n\nexport class TensorFlowJSModel implements RLModel {\n  private loaded = false;\n  private model: unknown = null; // tf.LayersModel when implemented\n  private info: ModelInfo;\n\n  constructor(info: ModelInfo) {\n    this.info = info;\n  }\n\n  isLoaded(): boolean {\n    return this.loaded && this.model !== null;\n  }\n\n  async load(path: string): Promise<void> {\n    try {\n      // TODO: Implement TensorFlow.js model loading\n      // Example:\n      // const tf = await import('@tensorflow/tfjs');\n      // this.model = await tf.loadLayersModel(path);\n      // this.loaded = true;\n      \n      // Removed warning logs\n      this.loaded = false;\n    } catch (error) {\n      // Removed error log\n      this.loaded = false;\n      throw error;\n    }\n  }\n\n  async predict(observation: Observation, currentAngle: number): Promise<AIDecision> {\n    if (!this.isLoaded()) {\n      throw new Error('Model not loaded');\n    }\n\n    // TODO: Implement TensorFlow.js prediction\n    // Example:\n    // const tf = await import('@tensorflow/tfjs');\n    // const input = tf.tensor2d([observation.vector]);\n    // const output = this.model.predict(input) as tf.Tensor;\n    // const action = await output.data();\n    // return actionToDecision(action[0], currentAngle);\n\n    throw new Error('TensorFlow.js prediction not yet implemented');\n  }\n\n  getInfo(): ModelInfo {\n    return this.info;\n  }\n}\n\n/**\n * Model manager\n * \n * Manages the current RL model and provides a unified interface.\n */\nexport class RLModelManager {\n  private model: RLModel | null = null;\n  private fallbackModel: RLModel;\n\n  constructor() {\n    this.fallbackModel = new RuleBasedRLModel();\n  }\n\n  /**\n   * Set the active model\n   */\n  setModel(model: RLModel | ExtendedRLModel): void {\n    this.model = model;\n  }\n\n  /**\n   * Get the active model (or fallback)\n   */\n  getModel(): RLModel | ExtendedRLModel {\n    return this.model && this.model.isLoaded() ? this.model : this.fallbackModel;\n  }\n\n  /**\n   * Check if RL model is active\n   */\n  isRLActive(): boolean {\n    return this.model !== null && this.model.isLoaded();\n  }\n\n  /**\n   * Load model from path\n   */\n  async loadModel(path: string): Promise<void> {\n    if (!this.model) {\n      throw new Error('No model set. Call setModel() first.');\n    }\n    await this.model.load(path);\n  }\n}\n\n// Global model manager instance\nexport const rlModelManager = new RLModelManager();\n\n","import type { Tank, Bullet, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport type { AIContext, AIDecision, AIConfig } from './types';\nimport { assessThreats, isPositionSafe, findEscapeDirection } from './threat-assessment';\nimport { calculateOptimalShotAngle } from './sun-calculations';\nimport { calculateOptimalPosition, findSafeDodgePosition } from './navigation';\nimport { predictTankPosition } from './prediction';\nimport { TANK_SPEED, ROTATION_SPEED, TANK_SIZE, MAX_BULLETS_PER_TANK } from '@/app/games/tank-trouble/config';\nimport { canMoveTo } from '@/app/games/tank-trouble/utils/collision';\nimport { rlModelManager } from './rl-model';\nimport { extractObservation } from './rl-observation';\nimport { URGENT_THREAT_THRESHOLD, ENEMY_PREDICTION_TIME_MS, MOVE_FORWARD_ANGLE_TOLERANCE, MOVE_BACKWARD_ANGLE_TOLERANCE } from '@/app/games/tank-trouble/constants/game-constants';\nimport { getTankCenter } from '@/app/games/tank-trouble/utils/tank-utils';\nimport { normalizeAngleDifference, angleToPoint } from '@/app/games/tank-trouble/utils/math';\nimport { countBulletsByOwner } from '@/app/games/tank-trouble/utils/bullet-optimization';\n\n/**\n * Main AI controller - decides what actions the AI tank should take\n * \n * Supports both RL-based and rule-based decision making.\n * If an RL model is loaded, it will be used; otherwise falls back to rules.\n * \n * Made async to support TensorFlow.js model predictions which are inherently async.\n */\nexport async function makeAIDecision(context: AIContext): Promise<AIDecision> {\n  const {\n    aiTank,\n    enemyTank,\n    bullets,\n    barriers,\n    suns,\n    mapWidth,\n    mapHeight,\n    tickTime,\n    config,\n  } = context;\n\n  // Skip if tank is respawning or exploding\n  if (aiTank.respawning || aiTank.exploding || aiTank.lives <= 0) {\n    return {\n      angleDelta: 0,\n      moveDirection: 0,\n      shouldShoot: false,\n    };\n  }\n\n  // Try to use RL model if available\n  // Note: This function is now async to support async model predictions\n  if (rlModelManager.isRLActive()) {\n    try {\n      const model = rlModelManager.getModel();\n      const observation = extractObservation(context);\n      const decision = await model.predict(observation, aiTank.angle);\n      return decision;\n    } catch (error) {\n      // Removed warning log\n      // Fall through to rule-based AI\n    }\n  }\n\n  // Fall back to rule-based AI\n  return makeRuleBasedDecision(context);\n}\n\n/**\n * Rule-based decision making (original implementation)\n */\nfunction makeRuleBasedDecision(context: AIContext): AIDecision {\n  const {\n    aiTank,\n    enemyTank,\n    bullets,\n    barriers,\n    suns,\n    mapWidth,\n    mapHeight,\n    config,\n  } = context;\n\n  // Assess threats\n  const threats = assessThreats(\n    aiTank,\n    bullets,\n    suns,\n    barriers,\n    mapWidth,\n    mapHeight,\n    config.maxPredictionTime\n  );\n\n  // More aggressive: only dodge if threat is truly imminent (very high threat level)\n  // This encourages movement toward enemy even when under moderate threat\n  const hasUrgentThreat = threats.length > 0 && threats[0].threatLevel > URGENT_THREAT_THRESHOLD;\n\n  // Decision making: only dodge for truly urgent threats, otherwise always attack\n  if (hasUrgentThreat) {\n    return handleDodge(context, threats);\n  }\n\n  // Otherwise, pursue and attack aggressively\n  return handleAttack(context);\n}\n\n/**\n * Handle dodging from threats\n */\nfunction handleDodge(\n  context: AIContext,\n  threats: ReturnType<typeof assessThreats>\n): AIDecision {\n  const {\n    aiTank,\n    enemyTank,\n    barriers,\n    suns,\n    mapWidth,\n    mapHeight,\n    config,\n    bullets,\n  } = context;\n\n  // Find escape direction\n  const escape = findEscapeDirection(\n    aiTank,\n    threats,\n    barriers,\n    suns,\n    mapWidth,\n    mapHeight\n  );\n\n  // Find safe position to dodge to\n  const dodgePos = findSafeDodgePosition(\n    aiTank,\n    escape.angle,\n    config.dodgeMargin * 2,\n    barriers,\n    suns,\n    [aiTank, enemyTank],\n    mapWidth,\n    mapHeight,\n    1 // AI is tank index 1\n  );\n\n  let angleDelta = 0;\n  let moveDirection = 0;\n\n    if (dodgePos) {\n    // Calculate angle to dodge position\n    const aiCenter = getTankCenter(aiTank);\n    const targetAngle = angleToPoint(aiCenter, dodgePos);\n\n    // Calculate angle difference\n    let angleDiff = normalizeAngleDifference(targetAngle - aiTank.angle);\n\n    // Rotate toward target\n    if (Math.abs(angleDiff) > ROTATION_SPEED) {\n      angleDelta = angleDiff > 0 ? ROTATION_SPEED : -ROTATION_SPEED;\n    } else {\n      angleDelta = angleDiff;\n    }\n\n    // Move forward\n    moveDirection = 1;\n  } else {\n    // Can't dodge to position, just rotate away from threat\n    let angleDiff = normalizeAngleDifference(escape.angle - aiTank.angle);\n\n    if (Math.abs(angleDiff) > ROTATION_SPEED) {\n      angleDelta = angleDiff > 0 ? ROTATION_SPEED : -ROTATION_SPEED;\n    } else {\n      angleDelta = angleDiff;\n    }\n\n    // Try to move backward\n    moveDirection = -1;\n  }\n\n  // Even while dodging, try to shoot if possible (more aggressive)\n  // But prioritize dodging movement\n  return {\n    angleDelta,\n    moveDirection,\n    shouldShoot: false, // Still don't shoot while dodging to focus on survival\n  };\n}\n\n/**\n * Handle attacking the enemy\n */\nfunction handleAttack(context: AIContext): AIDecision {\n  const {\n    aiTank,\n    enemyTank,\n    bullets,\n    barriers,\n    suns,\n    mapWidth,\n    mapHeight,\n    tickTime,\n    config,\n  } = context;\n\n  // Predict enemy position\n  const predictedEnemyPos = predictTankPosition(enemyTank, ENEMY_PREDICTION_TIME_MS, TANK_SPEED);\n\n  // Calculate optimal shot\n  const shot = calculateOptimalShotAngle(\n    aiTank,\n    predictedEnemyPos,\n    suns,\n    barriers,\n    mapWidth,\n    mapHeight,\n    config.sunSkill\n  );\n\n  // Calculate optimal position\n  const optimalPos = calculateOptimalPosition(\n    aiTank,\n    enemyTank,\n    config.aggressiveness,\n    barriers,\n    suns,\n    mapWidth,\n    mapHeight\n  );\n\n  // Calculate movement decision - always aggressive\n  let angleDelta = 0;\n  let moveDirection = 0;\n\n  // Always rotate toward enemy/shot angle (prioritize shooting over positioning)\n  const targetAngle = shot.angle; // Always prioritize shooting angle\n\n  let angleDiff = normalizeAngleDifference(targetAngle - aiTank.angle);\n\n  if (Math.abs(angleDiff) > ROTATION_SPEED) {\n    angleDelta = angleDiff > 0 ? ROTATION_SPEED : -ROTATION_SPEED;\n  } else {\n    angleDelta = angleDiff;\n  }\n\n  // Always move toward enemy (aggressive behavior - move forward whenever possible)\n  // Calculate angle directly to enemy\n  const aiCenter = getTankCenter(aiTank);\n  const enemyCenter = getTankCenter(enemyTank);\n  const moveAngle = angleToPoint(aiCenter, enemyCenter);\n\n  const normalizedMoveDiff = normalizeAngleDifference(moveAngle - aiTank.angle);\n\n  // Always move forward toward enemy if facing roughly the right direction (wider tolerance)\n  if (Math.abs(normalizedMoveDiff) < MOVE_FORWARD_ANGLE_TOLERANCE) {\n    moveDirection = 1; // Forward\n  } else if (Math.abs(normalizedMoveDiff) > MOVE_BACKWARD_ANGLE_TOLERANCE) {\n    moveDirection = -1; // Backward (to quickly reorient)\n  } else {\n    // Even if not perfectly aligned, still move forward if somewhat close\n    moveDirection = 1; // Always move forward aggressively\n  }\n\n  // Decide whether to shoot - more aggressive shooting\n  let shouldShoot = false;\n  let shootAngle: number | undefined;\n\n  // Check if we have bullets available (use optimized counting)\n  const bulletCounts = countBulletsByOwner(bullets);\n  const bulletCount = bulletCounts.get(aiTank.color) || 0;\n  const canShoot = bulletCount < MAX_BULLETS_PER_TANK;\n\n  // More aggressive shooting: lower confidence threshold, wider angle tolerance\n  if (canShoot && shot.confidence > 0.2 - config.accuracyPenalty) { // Reduced from 0.3\n    // Apply accuracy penalty\n    const adjustedConfidence = shot.confidence * (1 - config.accuracyPenalty);\n    \n    // Shoot if confidence is reasonable and angle is somewhat close (wider tolerance)\n    if (adjustedConfidence > 0.15 && Math.abs(angleDiff) < 45) { // Reduced confidence from 0.2 to 0.15, increased angle from 30 to 45\n      shouldShoot = true;\n      shootAngle = shot.angle;\n    }\n  }\n\n  return {\n    angleDelta,\n    moveDirection,\n    shouldShoot,\n    shootAngle,\n  };\n}\n\n\n","import type { AIConfig } from './types';\n\n/**\n * Default AI configuration\n * Adjust these values to balance difficulty\n * More aggressive settings to reduce stalemates during training\n */\nexport const DEFAULT_AI_CONFIG: AIConfig = {\n  reactionDelay: 30, // 30ms reaction time (reduced from 50ms for faster reactions)\n  accuracyPenalty: 0.08, // 8% accuracy penalty (reduced from 15% to shoot more)\n  aggressiveness: 0.85, // 85% aggressive (increased from 70% to encourage closer engagement)\n  sunSkill: 0.65, // 65% skill at using suns (slightly increased)\n  maxPredictionTime: 3000, // Predict up to 3 seconds ahead\n  dodgeMargin: 25, // Keep 25 pixels away from predicted bullet paths (reduced from 30 for more aggressive positioning)\n};\n\n/**\n * Easy difficulty AI config\n */\nexport const EASY_AI_CONFIG: AIConfig = {\n  reactionDelay: 150,\n  accuracyPenalty: 0.3,\n  aggressiveness: 0.4,\n  sunSkill: 0.3,\n  maxPredictionTime: 2000,\n  dodgeMargin: 40,\n};\n\n/**\n * Hard difficulty AI config\n */\nexport const HARD_AI_CONFIG: AIConfig = {\n  reactionDelay: 20,\n  accuracyPenalty: 0.05,\n  aggressiveness: 0.9,\n  sunSkill: 0.85,\n  maxPredictionTime: 4000,\n  dodgeMargin: 20,\n};\n\n\n","/**\n * Reward Configuration\n * \n * Defines reward constants that match the shared game-config.json\n * This ensures consistency between TypeScript and Go implementations\n */\n\nexport interface RewardConfig {\n  timeoutPenalty: number;\n  maxEpisodeTimeMs: number;\n  survivalRewardPerTick: number;\n  hitEnemyReward: number;\n  gotHitPenalty: number;\n  optimalDistanceToEnemy: number;\n  inactivityThresholdMs: number;\n  significantMovementThreshold: number;\n  aggressionCheckIntervalMs: number;\n  dodgeRewardPerBullet: number;\n  recentBulletThresholdMs: number;\n  positionHistorySize: number;\n  positionRepeatThreshold: number;\n  threatDistance: number;\n  bulletMatchDistance: number;\n  movementAwayThreshold: number;\n  shotAccuracyMaxDistance: number;\n  movementRewardMax: number;\n  movementRewardMultiplier: number;\n  stagnationPenalty: number;\n  stalematePenalty: number;\n  repetitiveActionPenalty: number;\n  positionDiversityReward: number;\n  lifeAdvantageReward: number;\n  inactivityBasePenalty: number;\n  inactivityMaxPenalty: number;\n  inactivityScalingFactor: number;\n  lackOfAggressionPenalty: number;\n}\n\n/**\n * Default reward config matching shared/config/game-config.json\n */\nexport const DEFAULT_REWARD_CONFIG: RewardConfig = {\n  timeoutPenalty: -100,\n  maxEpisodeTimeMs: 60000,\n  survivalRewardPerTick: 0.01,\n  hitEnemyReward: 100,\n  gotHitPenalty: -100,\n  optimalDistanceToEnemy: 120,\n  inactivityThresholdMs: 1500,\n  significantMovementThreshold: 5,\n  aggressionCheckIntervalMs: 2000,\n  dodgeRewardPerBullet: 10,\n  recentBulletThresholdMs: 100,\n  positionHistorySize: 10,\n  positionRepeatThreshold: 30,\n  threatDistance: 50,\n  bulletMatchDistance: 10,\n  movementAwayThreshold: 10,\n  shotAccuracyMaxDistance: 50,\n  movementRewardMax: 0.15,\n  movementRewardMultiplier: 0.0015,\n  stagnationPenalty: -0.1,\n  stalematePenalty: -0.2,\n  repetitiveActionPenalty: -0.03,\n  positionDiversityReward: 0.02,\n  lifeAdvantageReward: 0.02,\n  inactivityBasePenalty: -0.3,\n  inactivityMaxPenalty: -0.5,\n  inactivityScalingFactor: 0.1,\n  lackOfAggressionPenalty: -0.15,\n};\n\n","/**\n * Reward Function\n * \n * Calculates rewards for the RL agent based on game state transitions.\n * Reward shaping is critical for RL success - rewards should guide the agent\n * toward desired behaviors.\n */\n\nimport type { Tank, Bullet } from '@/app/games/tank-trouble/types';\nimport type { AIDecision } from './types';\nimport { TANK_SIZE } from '@/app/games/tank-trouble/config';\nimport { distance } from '@/app/games/tank-trouble/utils/math';\nimport { getTankCenter } from '@/app/games/tank-trouble/utils/tank-utils';\nimport { MAX_EPISODE_TIME_MS } from '@/app/games/tank-trouble/constants/game-constants';\nimport type { RewardConfig } from './rl-reward-config';\nimport { DEFAULT_REWARD_CONFIG } from './rl-reward-config';\n\nexport interface PreviousState {\n  aiTank: Tank;\n  enemyTank: Tank;\n  bullets: Bullet[];\n  aiLives: number;\n  enemyLives: number;\n  tickTime: number;\n  aiPositionHistory?: Array<{ x: number; y: number; tickTime: number }>; // Track position history for stalemate detection\n  lastMovementTime?: number; // Track when tank last moved significantly (for inactivity penalty)\n  lastShotTime?: number; // Track when tank last shot (for aggression penalty)\n  episodeStartTime?: number; // Track episode start time for timeout penalty\n  timeoutApplied?: boolean; // Track if timeout penalty has been applied\n}\n\nexport interface CurrentState {\n  aiTank: Tank;\n  enemyTank: Tank;\n  bullets: Bullet[];\n  aiLives: number;\n  enemyLives: number;\n  tickTime: number;\n}\n\nexport interface RewardInfo {\n  reward: number;\n  breakdown: {\n    survival?: number;\n    hitEnemy?: number;\n    gotHit?: number;\n    distanceReward?: number;\n    dodgedBullet?: number;\n    shotAccuracy?: number;\n    lifeAdvantage?: number;\n    movement?: number;\n    stagnationPenalty?: number;\n    stalematePenalty?: number;\n    repetitiveActionPenalty?: number;\n    timeoutPenalty?: number;\n    inactivityPenalty?: number;\n    lackOfAggressionPenalty?: number;\n  };\n}\n\n/**\n * Calculate reward based on state transition\n * \n * This function implements reward shaping to guide the agent:\n * - Dense rewards for intermediate behaviors (dodging, positioning)\n * - Sparse rewards for major events (hits, deaths)\n * - Automatic penalties for timeout, inactivity, and lack of aggression\n */\nexport function calculateReward(\n  previous: PreviousState,\n  current: CurrentState,\n  action: AIDecision,\n  maxEpisodeTimeMs: number = MAX_EPISODE_TIME_MS,\n  config: RewardConfig = DEFAULT_REWARD_CONFIG\n): RewardInfo {\n  let totalReward = 0;\n  const breakdown: RewardInfo['breakdown'] = {};\n  \n  // Apply timeout penalty if episode exceeded max episode time (only once)\n  if (previous.episodeStartTime && !previous.timeoutApplied) {\n    const episodeElapsed = current.tickTime - previous.episodeStartTime;\n    if (episodeElapsed >= maxEpisodeTimeMs) {\n      const timeoutPenalty = config.timeoutPenalty;\n      totalReward += timeoutPenalty;\n      breakdown.timeoutPenalty = timeoutPenalty;\n    }\n  }\n\n  // 1. Survival reward (small positive per tick)\n  // Encourages staying alive\n  const survivalReward = config.survivalRewardPerTick;\n  totalReward += survivalReward;\n  breakdown.survival = survivalReward;\n\n  // 2. Hit enemy (large positive)\n  // Check if enemy lost a life\n  if (current.enemyLives < previous.enemyLives) {\n    const hitReward = config.hitEnemyReward;\n    totalReward += hitReward;\n    breakdown.hitEnemy = hitReward;\n  }\n\n  // 3. Got hit (large negative)\n  // Check if AI lost a life\n  if (current.aiLives < previous.aiLives) {\n    const hitPenalty = config.gotHitPenalty;\n    totalReward += hitPenalty;\n    breakdown.gotHit = hitPenalty;\n  }\n\n  // 4. Distance to enemy (shaped reward)\n  // Reward maintaining optimal distance (not too close, not too far)\n  // Optimal distance reasoning:\n  // - Too close (< 80px): Hard to dodge, easy to get hit, bullets travel too fast\n  // - Too far (> 200px): Hard to hit enemy, bullets take too long, less pressure\n  // - Sweet spot (100-150px): Good balance - can dodge, can hit, maintains engagement\n  // - Based on: map size (480x360), tank size (24px), bullet speed (~2px/tick)\n  // - At 150px: ~75 ticks for bullet to travel, gives ~1 second reaction time at 72 FPS\n  const prevDistance = getDistance(previous.aiTank, previous.enemyTank);\n  const currDistance = getDistance(current.aiTank, current.enemyTank);\n  const optimalDistance = config.optimalDistanceToEnemy;\n  \n  const prevDistanceError = Math.abs(prevDistance - optimalDistance) / optimalDistance;\n  const currDistanceError = Math.abs(currDistance - optimalDistance) / optimalDistance;\n  \n  // Reward getting closer to optimal distance\n  const distanceImprovement = prevDistanceError - currDistanceError;\n  const distanceReward = distanceImprovement * 2; // Scale factor\n  totalReward += distanceReward;\n  breakdown.distanceReward = distanceReward;\n\n  // 5. Dodged bullet (positive)\n  // Check if a bullet that was threatening is now gone or missed\n  const dodgedReward = checkDodgedBullet(previous, current, config);\n  if (dodgedReward > 0) {\n    totalReward += dodgedReward;\n    breakdown.dodgedBullet = dodgedReward;\n  }\n\n  // 6. Shot accuracy (reward for shots that get close to enemy)\n  if (action.shouldShoot) {\n    // Find bullets that were just created (within threshold)\n    const recentBulletThresholdMs = config.recentBulletThresholdMs;\n    \n    for (const bullet of current.bullets) {\n      // Check owner and recency in single pass\n      if (bullet.owner === current.aiTank.color && \n          current.tickTime - bullet.createdAt < recentBulletThresholdMs) {\n        const closestApproach = getClosestBulletApproach(bullet, current.enemyTank);\n        // Reward inversely proportional to closest approach\n        const accuracyReward = Math.max(0, 5 * (1 - closestApproach / config.shotAccuracyMaxDistance));\n        totalReward += accuracyReward;\n        breakdown.shotAccuracy = (breakdown.shotAccuracy || 0) + accuracyReward;\n      }\n    }\n  }\n\n  // 7. Life advantage (encourage maintaining/improving life advantage)\n  // Only reward maintaining advantage, not changes (changes are handled by hit rewards above)\n  const prevLifeDiff = previous.aiLives - previous.enemyLives;\n  const currLifeDiff = current.aiLives - current.enemyLives;\n  \n  // Small bonus for having life advantage (maintains incentive when ahead)\n  if (currLifeDiff > 0) {\n    const lifeAdvantageReward = config.lifeAdvantageReward;\n    totalReward += lifeAdvantageReward;\n    breakdown.lifeAdvantage = lifeAdvantageReward;\n  }\n\n  // 8. Movement reward (encourage active movement, penalize staying still)\n  // Cache distance calculation to avoid redundant sqrt operations\n  const movementDistance = getDistance(previous.aiTank, current.aiTank);\n  const moved = movementDistance > 0.1;\n  \n  if (moved) {\n    // Reward proportional to distance moved (encourage significant movement)\n    const movementReward = Math.min(config.movementRewardMax, movementDistance * config.movementRewardMultiplier);\n    totalReward += movementReward;\n    breakdown.movement = movementReward;\n  } else {\n    // Increased penalty for not moving (stalling) - stronger penalty to encourage movement\n    const stagnationPenalty = config.stagnationPenalty;\n    totalReward += stagnationPenalty;\n    breakdown.stagnationPenalty = stagnationPenalty;\n    breakdown.movement = stagnationPenalty;\n  }\n\n  // 9. Stalemate detection (both tanks in similar positions, not making progress)\n  // Cache distance calculations to avoid redundant sqrt operations\n  const tankDistance = getDistance(current.aiTank, current.enemyTank);\n  const prevTankDistance = getDistance(previous.aiTank, previous.enemyTank);\n  const distanceChange = Math.abs(tankDistance - prevTankDistance);\n  \n  // Check if both tanks are in a stalemate situation\n  // Stalemate: tanks aren't changing relative positions much, and AI isn't moving much\n  // This catches both close-range standoffs and long-range circling\n  const isStalemate = \n    distanceChange < 5 && // Distance between tanks isn't changing much\n    movementDistance < 2; // AI tank isn't moving much\n  \n  if (isStalemate) {\n    // Stronger penalty for stalemate - encourages breaking out of deadlock\n    const stalematePenalty = config.stalematePenalty;\n    totalReward += stalematePenalty;\n    breakdown.stalematePenalty = stalematePenalty;\n  }\n\n  // 10. Repetitive action penalty (shooting without movement or progress)\n  // Penalize if shooting repeatedly without moving or making progress\n  if (action.shouldShoot && !moved && current.bullets.length >= previous.bullets.length) {\n    // Shooting but not moving and bullet count isn't decreasing (bullets colliding or missing)\n    const repetitiveActionPenalty = config.repetitiveActionPenalty;\n    totalReward += repetitiveActionPenalty;\n    breakdown.repetitiveActionPenalty = repetitiveActionPenalty;\n  }\n\n  // 11. Position diversity reward (encourage exploring different positions)\n  // Track if tank has been in similar position recently (if history available)\n  if (previous.aiPositionHistory && previous.aiPositionHistory.length > 0) {\n    const positionRepeatThreshold = config.positionRepeatThreshold;\n    const positionHistorySize = config.positionHistorySize;\n    \n    // Only check recent positions (avoid full array slice if history is large)\n    const startIdx = Math.max(0, previous.aiPositionHistory.length - positionHistorySize);\n    const currentPos = { x: current.aiTank.x, y: current.aiTank.y };\n    \n    // Check if current position is similar to recent positions (early exit optimization)\n    let isRepeatingPosition = false;\n    for (let i = startIdx; i < previous.aiPositionHistory.length; i++) {\n      const pos = previous.aiPositionHistory[i];\n      const dist = distance(currentPos.x, currentPos.y, pos.x, pos.y);\n      if (dist < positionRepeatThreshold) {\n        isRepeatingPosition = true;\n        break; // Early exit when repeat found\n      }\n    }\n    \n    if (!isRepeatingPosition && moved) {\n      // Reward for moving to a new area\n      const diversityReward = config.positionDiversityReward;\n      totalReward += diversityReward;\n      breakdown.movement = (breakdown.movement || 0) + diversityReward;\n    }\n  }\n\n  // 12. Inactivity penalty (tank sitting still for more than 1.5 seconds)\n  const inactivityThreshold = config.inactivityThresholdMs;\n  const significantMovementThreshold = config.significantMovementThreshold;\n  \n  if (moved && movementDistance >= significantMovementThreshold) {\n    // Tank moved significantly, update last movement time\n    // This will be tracked in the environment state\n  } else {\n    // Tank didn't move significantly, check if it's been inactive too long\n    const lastMovementTime = previous.lastMovementTime || previous.episodeStartTime || previous.tickTime;\n    const timeSinceLastMovement = current.tickTime - lastMovementTime;\n    \n    if (timeSinceLastMovement >= inactivityThreshold) {\n      // Stronger penalty that scales with inactivity duration\n      const inactivityDuration = timeSinceLastMovement - inactivityThreshold;\n      const scalingPenalty = Math.min(\n        config.inactivityMaxPenalty,\n        config.inactivityBasePenalty - (inactivityDuration / 1000) * config.inactivityScalingFactor\n      );\n      totalReward += scalingPenalty;\n      breakdown.inactivityPenalty = scalingPenalty;\n    }\n  }\n\n  // 13. Lack of aggression penalty\n  // Penalize if tank is not being aggressive enough (not shooting, not moving toward enemy, etc.)\n  const aggressionCheckInterval = config.aggressionCheckIntervalMs;\n  const timeSinceLastShot = previous.lastShotTime ? current.tickTime - previous.lastShotTime : Infinity;\n  \n  // Check if tank is being passive:\n  // - Not shooting for a while (more than 2 seconds)\n  // - Moving away from enemy\n  // - Not closing distance to enemy\n  const isPassive = \n    timeSinceLastShot > aggressionCheckInterval && // Not shooting\n    !action.shouldShoot && // Not about to shoot\n    movementDistance < 2; // Not moving much\n  \n  // Also check if moving away from enemy\n  const distanceToEnemyChange = currDistance - prevDistance;\n  const isMovingAway = distanceToEnemyChange > config.movementAwayThreshold;\n  \n  if (isPassive || (isMovingAway && !action.shouldShoot)) {\n    const lackOfAggressionPenalty = config.lackOfAggressionPenalty;\n    totalReward += lackOfAggressionPenalty;\n    breakdown.lackOfAggressionPenalty = lackOfAggressionPenalty;\n  }\n\n  return {\n    reward: totalReward,\n    breakdown,\n  };\n}\n\n/**\n * Get Euclidean distance between two tanks\n * Uses utility function for consistency\n */\nfunction getDistance(tank1: Tank, tank2: Tank): number {\n  return distance(tank1.x, tank1.y, tank2.x, tank2.y);\n}\n\n/**\n * Check if AI successfully dodged a bullet\n * \n * Returns reward if a bullet that was close to AI is now gone or far away\n * Optimized to use Map for O(1) lookups instead of O(n) searches\n */\nfunction checkDodgedBullet(previous: PreviousState, current: CurrentState, config: RewardConfig): number {\n  const threatDistance = config.threatDistance;\n  const bulletMatchDistance = config.bulletMatchDistance;\n  \n  // Find bullets that were threatening AI in previous state\n  const threateningBullets: Bullet[] = [];\n  for (const bullet of previous.bullets) {\n    if (bullet.owner === previous.aiTank.color || bullet.exploding) {\n      continue; // Ignore own bullets and exploding bullets\n    }\n    \n    const dist = getDistanceToTank(bullet, previous.aiTank);\n    if (dist < threatDistance) {\n      threateningBullets.push(bullet);\n    }\n  }\n\n  // Create a Map of current bullets by owner for faster lookup\n  // Key: owner, Value: array of bullets from that owner\n  const currentBulletsByOwner = new Map<'blue' | 'red', Bullet[]>();\n  for (const bullet of current.bullets) {\n    if (!bullet.exploding) {\n      const bullets = currentBulletsByOwner.get(bullet.owner) || [];\n      bullets.push(bullet);\n      currentBulletsByOwner.set(bullet.owner, bullets);\n    }\n  }\n\n  // Check if any threatening bullets are now gone or far away\n  let dodgedCount = 0;\n  const aiTankCenter = getTankCenter(current.aiTank);\n  \n  for (const prevBullet of threateningBullets) {\n    const ownerBullets = currentBulletsByOwner.get(prevBullet.owner) || [];\n    \n    // Check if a similar bullet still exists (matching by position)\n    let stillThreatening = false;\n    for (const currBullet of ownerBullets) {\n      const dist = distance(currBullet.x, currBullet.y, prevBullet.x, prevBullet.y);\n      if (dist < bulletMatchDistance) {\n        stillThreatening = true;\n        break;\n      }\n    }\n\n    if (!stillThreatening) {\n      // Bullet is gone - check if closest bullet from same owner is now far away\n      let minDistance = Infinity;\n      for (const currBullet of ownerBullets) {\n        const dist = distance(currBullet.x, currBullet.y, aiTankCenter.x, aiTankCenter.y);\n        if (dist < minDistance) {\n          minDistance = dist;\n        }\n      }\n      \n      if (minDistance > threatDistance) {\n        dodgedCount++;\n      }\n    }\n  }\n\n  return dodgedCount * config.dodgeRewardPerBullet;\n}\n\n/**\n * Get distance from bullet to tank center\n * Uses utility functions for consistency and performance\n */\nfunction getDistanceToTank(bullet: Bullet, tank: Tank): number {\n  const tankCenter = getTankCenter(tank);\n  return distance(bullet.x, bullet.y, tankCenter.x, tankCenter.y);\n}\n\n/**\n * Calculate closest approach distance of bullet to tank\n * \n * This is a simplified calculation - in reality, we'd need to account for\n * bullet trajectory and tank movement.\n */\nfunction getClosestBulletApproach(bullet: Bullet, tank: Tank): number {\n  // Simplified: just use current distance\n  // In a full implementation, we'd predict the bullet path\n  return getDistanceToTank(bullet, tank);\n}\n\n","/**\n * RL Environment Wrapper\n * \n * Wraps the Tank Trouble game as a reinforcement learning environment.\n * Converts game state to observations, executes actions, and calculates rewards.\n */\n\nimport type { Tank, Bullet, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport type { AIContext } from './types';\nimport { extractObservation, Observation } from './rl-observation';\nimport { calculateReward, RewardInfo } from './rl-reward';\nimport { actionToDecision, DecisionToAction } from './rl-actions';\nimport type { AIDecision } from './types';\nimport { MAX_EPISODE_TIME_MS } from '@/app/games/tank-trouble/constants/game-constants';\nimport { DEFAULT_REWARD_CONFIG } from './rl-reward-config';\n\nexport interface RLEnvironmentState {\n  observation: Observation;\n  reward: number;\n  done: boolean;\n  info: RewardInfo['breakdown'] & {\n    episodeLength: number;\n    totalReward: number;\n    aiLives: number;\n    enemyLives: number;\n  };\n}\n\nexport interface PreviousState {\n  aiTank: Tank;\n  enemyTank: Tank;\n  bullets: Bullet[];\n  aiLives: number;\n  enemyLives: number;\n  tickTime: number;\n  aiPositionHistory?: Array<{ x: number; y: number; tickTime: number }>;\n  lastMovementTime?: number;\n  lastShotTime?: number;\n  episodeStartTime?: number;\n  timeoutApplied?: boolean;\n}\n\n/**\n * RL Environment for Tank Trouble\n * \n * This class wraps the game state and provides a standard RL interface:\n * - reset(): Initialize/reset environment\n * - step(action): Execute action and return next state\n * - getObservation(): Get current observation\n */\nexport class TankTroubleRLEnv {\n  private previousState: PreviousState | null = null;\n  private episodeStartTime: number = 0;\n  private episodeLength: number = 0;\n  private totalReward: number = 0;\n  private positionHistory: Array<{ x: number; y: number; tickTime: number }> = [];\n  private maxEpisodeTimeMs: number;\n\n  constructor(maxEpisodeTimeMs: number = MAX_EPISODE_TIME_MS) {\n    this.maxEpisodeTimeMs = maxEpisodeTimeMs;\n  }\n\n  /**\n   * Reset the environment to initial state\n   */\n  reset(context: AIContext): RLEnvironmentState {\n    const observation = extractObservation(context);\n    \n    // Reset position history\n    this.positionHistory = [{ x: context.aiTank.x, y: context.aiTank.y, tickTime: context.tickTime }];\n    \n    // Store initial state\n    this.episodeStartTime = context.tickTime;\n    this.previousState = {\n      aiTank: { ...context.aiTank },\n      enemyTank: { ...context.enemyTank },\n      bullets: context.bullets.map(b => ({ ...b })),\n      aiLives: context.aiTank.lives,\n      enemyLives: context.enemyTank.lives,\n      tickTime: context.tickTime,\n      aiPositionHistory: [],\n      lastMovementTime: context.tickTime, // Initialize movement tracking\n      lastShotTime: 0, // Initialize shot tracking\n      episodeStartTime: context.tickTime, // Track episode start for timeout\n      timeoutApplied: false,\n    };\n    \n    this.episodeLength = 0;\n    this.totalReward = 0;\n\n    return {\n      observation,\n      reward: 0,\n      done: false,\n      info: {\n        episodeLength: 0,\n        totalReward: 0,\n        aiLives: context.aiTank.lives,\n        enemyLives: context.enemyTank.lives,\n      },\n    };\n  }\n\n  /**\n   * Step the environment with an action\n   * \n   * @param action - Action from RL agent (discrete or continuous)\n   * @param context - Current game context\n   * @param decision - The decision that was executed (for reward calculation)\n   * @returns Next state, reward, done flag, and info\n   */\n  step(\n    action: number | DecisionToAction,\n    context: AIContext,\n    decision: AIDecision\n  ): RLEnvironmentState {\n    if (!this.previousState) {\n      // If not initialized, reset first\n      return this.reset(context);\n    }\n\n    // Calculate reward based on state transition (no boolean arguments needed)\n    const rewardInfo = calculateReward(\n      this.previousState,\n      {\n        aiTank: context.aiTank,\n        enemyTank: context.enemyTank,\n        bullets: context.bullets,\n        aiLives: context.aiTank.lives,\n        enemyLives: context.enemyTank.lives,\n        tickTime: context.tickTime,\n      },\n      decision,\n      this.maxEpisodeTimeMs,\n      DEFAULT_REWARD_CONFIG\n    );\n\n    this.totalReward += rewardInfo.reward;\n    this.episodeLength++;\n\n    // Check if episode is done\n    const done = this.isDone(context);\n\n    // Extract new observation\n    const observation = extractObservation(context);\n\n    // Update position history (keep last 20 positions)\n    this.positionHistory.push({ x: context.aiTank.x, y: context.aiTank.y, tickTime: context.tickTime });\n    if (this.positionHistory.length > 20) {\n      this.positionHistory.shift();\n    }\n    \n    // Track movement and shooting for inactivity/aggression penalties\n    const movementDistance = Math.sqrt(\n      Math.pow(context.aiTank.x - this.previousState.aiTank.x, 2) +\n      Math.pow(context.aiTank.y - this.previousState.aiTank.y, 2)\n    );\n    const SIGNIFICANT_MOVEMENT_THRESHOLD = 5; // pixels\n    const lastMovementTime = movementDistance >= SIGNIFICANT_MOVEMENT_THRESHOLD \n      ? context.tickTime \n      : (this.previousState.lastMovementTime || context.tickTime);\n    \n    const lastShotTime = decision.shouldShoot \n      ? context.tickTime \n      : (this.previousState.lastShotTime || 0);\n    \n    // Check if timeout penalty was applied (check in reward function, but track here)\n    const episodeElapsed = context.tickTime - this.episodeStartTime;\n    const timeoutApplied = episodeElapsed >= this.maxEpisodeTimeMs && !this.previousState?.timeoutApplied;\n    \n    // Update previous state\n    this.previousState = {\n      aiTank: { ...context.aiTank },\n      enemyTank: { ...context.enemyTank },\n      bullets: context.bullets.map(b => ({ ...b })),\n      aiLives: context.aiTank.lives,\n      enemyLives: context.enemyTank.lives,\n      tickTime: context.tickTime,\n      aiPositionHistory: [...this.positionHistory], // Include position history for stalemate detection\n      lastMovementTime, // Track when tank last moved significantly\n      lastShotTime, // Track when tank last shot\n      episodeStartTime: this.episodeStartTime, // Pass episode start time for timeout check\n      timeoutApplied: timeoutApplied || this.previousState?.timeoutApplied || false, // Track if timeout penalty was applied\n    };\n\n    return {\n      observation,\n      reward: rewardInfo.reward,\n      done,\n      info: {\n        episodeLength: this.episodeLength,\n        totalReward: this.totalReward,\n        aiLives: context.aiTank.lives,\n        enemyLives: context.enemyTank.lives,\n        ...rewardInfo.breakdown,\n      },\n    };\n  }\n\n  /**\n   * Get current observation without stepping\n   */\n  getObservation(context: AIContext): Observation {\n    return extractObservation(context);\n  }\n\n  /**\n   * Check if episode is done\n   */\n  private isDone(context: AIContext): boolean {\n    // Episode ends when:\n    // 1. AI tank has no lives left\n    // 2. Enemy tank has no lives left\n    // 3. Episode exceeds max episode time (timeout)\n    if (context.aiTank.lives <= 0 || context.enemyTank.lives <= 0) {\n      return true;\n    }\n    \n    // Check if episode has exceeded max episode time\n    const episodeElapsed = context.tickTime - this.episodeStartTime;\n    if (episodeElapsed >= this.maxEpisodeTimeMs) {\n      return true;\n    }\n    \n    return false;\n  }\n\n  /**\n   * Get episode statistics\n   */\n  getStats() {\n    return {\n      episodeLength: this.episodeLength,\n      totalReward: this.totalReward,\n    };\n  }\n}\n\n","/**\n * Example RL Training Script\n * \n * This is a template for training an RL agent. In practice, you would:\n * 1. Use Python with Stable-Baselines3 for faster training\n * 2. Or use TensorFlow.js for browser-based training (slower but simpler)\n * \n * This example shows the structure but requires actual RL implementation.\n */\n\nimport { TankTroubleRLEnv } from './rl-environment';\nimport { rlModelManager, TensorFlowJSModel } from './rl-model';\nimport { getObservationSize } from './rl-observation';\nimport { NUM_DISCRETE_ACTIONS } from './rl-actions';\nimport type { AIContext } from './types';\n\n/**\n * Example training loop structure\n * \n * NOTE: This is a template. Actual training requires:\n * - A proper RL algorithm (DQN, PPO, etc.)\n * - Experience replay buffer\n * - Model optimization\n * - Hyperparameter tuning\n */\nexport async function trainRLAgent(\n  episodes: number = 1000,\n  modelPath?: string\n) {\n  // Removed debug logs\n\n  // Initialize environment\n  const env = new TankTroubleRLEnv();\n\n  // Initialize model (placeholder - would be actual RL model)\n  const model = new TensorFlowJSModel({\n    name: 'TankTroubleRL',\n    type: 'discrete',\n    observationSize: getObservationSize(),\n    actionSize: NUM_DISCRETE_ACTIONS,\n  });\n\n  rlModelManager.setModel(model);\n\n  if (modelPath) {\n    try {\n      await model.load(modelPath);\n      // Model loaded\n    } catch (error) {\n      // No existing model found, starting fresh\n    }\n  }\n\n  // Training statistics\n  const stats = {\n    episode: 0,\n    totalReward: 0,\n  };\n\n  // Example training loop structure\n  for (let episode = 0; episode < episodes; episode++) {\n    stats.episode = episode;\n\n    // Reset environment (would get initial game state)\n    // const initialState = getInitialGameState();\n    // let state = env.reset(initialState);\n\n    let episodeReward = 0;\n    let done = false;\n    let stepCount = 0;\n\n    // Episode loop\n    while (!done && stepCount < 10000) {\n      // TODO: Implement actual RL algorithm\n      // 1. Select action (epsilon-greedy, policy, etc.)\n      // 2. Execute action in environment\n      // 3. Observe reward and next state\n      // 4. Store experience in replay buffer\n      // 5. Update model (if batch ready)\n\n      stepCount++;\n    }\n\n    // Log episode statistics (removed console.log)\n    // TODO: Save model periodically\n    if (episode % 1000 === 0 && modelPath) {\n      // await model.save(modelPath);\n    }\n  }\n  return stats;\n}\n\n/**\n * Example: How to use trained model in game\n */\nexport function useTrainedModel(modelPath: string) {\n  const model = new TensorFlowJSModel({\n    name: 'TankTroubleRL',\n    type: 'discrete',\n    observationSize: getObservationSize(),\n    actionSize: NUM_DISCRETE_ACTIONS,\n  });\n\n  rlModelManager.setModel(model);\n\n  // Load model\n  model.load(modelPath)\n    .then(() => {\n      // Model loaded successfully\n    })\n    .catch((error) => {\n      // Failed to load model, falling back to rule-based AI\n    });\n}\n\n/**\n * Python Training Example (Recommended)\n * \n * For actual training, use Python with Stable-Baselines3:\n * \n * ```python\n * from stable_baselines3 import PPO\n * from stable_baselines3.common.env_util import make_vec_env\n * from tank_trouble_env import TankTroubleEnv\n * \n * # Create environment\n * env = make_vec_env(TankTroubleEnv, n_envs=4)\n * \n * # Create and train model\n * model = PPO(\"MlpPolicy\", env, verbose=1)\n * model.learn(total_timesteps=1_000_000)\n * \n * # Save model\n * model.save(\"tank_ai_ppo\")\n * \n * # Export for TensorFlow.js (requires conversion)\n * # See: https://www.tensorflow.org/js/guide/conversion\n * ```\n */\n\n","/**\n * AI Tank System - Main Entry Point\n * \n * This module exports the main AI tank update function and configuration\n */\n\nimport type { Tank, Bullet, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport type { UpdateTankResult, UpdateTankParams } from '@/app/games/tank-trouble/utils/tank';\nimport type { AIConfig, AIContext, AIDecision } from './types';\nimport { makeAIDecision } from './controller';\nimport { DEFAULT_AI_CONFIG } from './config';\nimport { TANK_SPEED, ROTATION_SPEED, MAX_BULLETS_PER_TANK, GAME_CONFIG } from '@/app/games/tank-trouble/config';\nimport { canMoveTo } from '@/app/games/tank-trouble/utils/collision';\nimport { createBullet } from '@/app/games/tank-trouble/utils/bullet-creation';\nimport { clampTankPosition } from '@/app/games/tank-trouble/utils/tank-utils';\nimport { degToRad } from '@/app/games/tank-trouble/utils/math';\nimport { countBulletsByOwner } from '@/app/games/tank-trouble/utils/bullet-optimization';\nimport type { RLTrainingManager } from './rl-training-manager';\n\n/**\n * Update AI tank - similar to updatePlayer1Tank/updatePlayer2Tank\n * \n * Made async to support async AI decision making (TensorFlow.js predictions)\n */\nexport async function updateAITank(\n  params: UpdateTankParams,\n  aiConfig: AIConfig = DEFAULT_AI_CONFIG,\n  trainingManager?: RLTrainingManager | null,\n  gameId?: string\n): Promise<UpdateTankResult & { decision?: AIDecision }> {\n  const {\n    tank,\n    tankIndex,\n    tickTime,\n    lastShotTime,\n    bullets,\n    mapWidth,\n    mapHeight,\n    barriers,\n    suns,\n    allTanks,\n  } = params;\n\n  // Find enemy tank - optimized O(1) lookup instead of O(n) find\n  // Tanks array is always [blue, red], so use index directly\n  let enemyTank: Tank | undefined;\n  if (allTanks.length >= 2 && tankIndex !== undefined) {\n    // Direct index lookup: enemy is the other tank\n    const enemyIndex = tankIndex === 0 ? 1 : 0;\n    enemyTank = allTanks[enemyIndex];\n    \n    // Validate enemy tank exists and has lives\n    if (!enemyTank || enemyTank.lives <= 0) {\n      // Fallback: try the other index if current enemy is invalid\n      const fallbackIndex = enemyIndex === 0 ? 1 : 0;\n      enemyTank = allTanks[fallbackIndex] || enemyTank;\n    }\n  } else {\n    // Fallback to find if array structure is unexpected (defensive)\n    enemyTank = allTanks.find((t) => t && t.color !== tank.color && t.lives > 0) ||\n                allTanks.find((t) => t && t !== tank);\n  }\n  \n  // If still no enemy tank, use a dummy tank at center of map (shouldn't happen in normal gameplay)\n  if (!enemyTank) {\n    enemyTank = {\n      x: mapWidth / 2,\n      y: mapHeight / 2,\n      angle: 0,\n      lives: 3,\n      color: tank.color === 'blue' ? 'red' : 'blue',\n    };\n  }\n\n  // Create AI context\n  const context: AIContext = {\n    aiTank: tank,\n    enemyTank,\n    bullets,\n    barriers,\n    suns,\n    mapWidth,\n    mapHeight,\n    tickTime,\n    config: aiConfig,\n  };\n\n  // Get AI decision (async)\n  const decision = await makeAIDecision(context);\n\n  // If training, collect step (async, don't wait)\n  if (trainingManager && trainingManager.getIsTraining()) {\n    trainingManager.step(context, decision, undefined, gameId).catch(() => {\n      // Silently handle errors\n    });\n  }\n\n  // Apply decision to tank\n  let newAngle = tank.angle + decision.angleDelta;\n  let newX = tank.x;\n  let newY = tank.y;\n  const newBullets: Bullet[] = [];\n  let newLastShotTime = lastShotTime;\n\n  // Handle movement\n  if (decision.moveDirection !== 0) {\n    const rad = degToRad(newAngle);\n    const speed = decision.moveDirection > 0 ? TANK_SPEED : -TANK_SPEED * 0.7; // Backward is slower\n    const dx = Math.cos(rad) * speed;\n    const dy = Math.sin(rad) * speed;\n    const testX = newX + dx;\n    const testY = newY + dy;\n\n    if (canMoveTo(testX, testY, mapWidth, mapHeight, barriers, allTanks, suns, tankIndex)) {\n      newX = testX;\n      newY = testY;\n    }\n  }\n\n  // Handle shooting\n  if (\n    decision.shouldShoot &&\n    tickTime - lastShotTime > GAME_CONFIG.game.shootingCooldown\n  ) {\n    const bulletCounts = countBulletsByOwner(bullets);\n    const bulletCount = bulletCounts.get(tank.color) || 0;\n    if (bulletCount < MAX_BULLETS_PER_TANK) {\n      const shootAngle = decision.shootAngle ?? newAngle;\n      const bullet = createBullet(\n        { ...tank, x: newX, y: newY, angle: shootAngle },\n        shootAngle,\n        tickTime,\n        tank.color\n      );\n      newBullets.push(bullet);\n      newLastShotTime = tickTime;\n    }\n  }\n\n  // Clamp position\n  const clamped = clampTankPosition(newX, newY, mapWidth, mapHeight);\n  newX = clamped.x;\n  newY = clamped.y;\n\n  return {\n    updatedTank: { ...tank, x: newX, y: newY, angle: newAngle },\n    newBullets,\n    lastShotTime: newLastShotTime,\n    decision, // Include decision for training\n  };\n}\n\n// Export types and config for external use\nexport type { AIConfig, AIContext } from './types';\nexport { DEFAULT_AI_CONFIG, EASY_AI_CONFIG, HARD_AI_CONFIG } from './config';\n\n// Export RL components\nexport { rlModelManager, type RLModel, type ModelInfo } from './rl-model';\nexport { TankTroubleRLEnv, type RLEnvironmentState } from './rl-environment';\nexport { extractObservation, getObservationSize, type Observation } from './rl-observation';\nexport { calculateReward, type RewardInfo } from './rl-reward';\nexport { actionToDecision, NUM_DISCRETE_ACTIONS, decisionToAction } from './rl-actions';\nexport { ACTION_DEFINITIONS, ACTION_BY_ID, ACTION_BY_NAME } from './rl-action-config';\nexport type { DiscreteAction, ContinuousAction, DecisionToAction, ActionDefinition } from './rl-actions';\nexport { useTrainedModel } from './rl-training-example';\n\n\n","import React, { useCallback, useRef, useEffect } from 'react';\nimport type { Tank, Bullet, Barrier, Sun, TankTroubleMapData } from '@/app/games/tank-trouble/types';\nimport { TICK_INTERVAL, GAME_CONFIG } from '@/app/games/tank-trouble/config';\nimport { updatePlayer1Tank, updatePlayer2Tank } from '@/app/games/tank-trouble/utils/tank';\nimport { updateBullets } from '@/app/games/tank-trouble/utils/bullet';\nimport { generateRandomSpawnPosition } from '@/app/games/tank-trouble/utils/spawn';\nimport { updateAITank, type AIConfig } from '@/app/games/tank-trouble/ai-tank';\nimport type { RLTrainingManager } from '@/app/games/tank-trouble/ai-tank/rl-training-manager';\nimport { MAX_EPISODE_TIME_MS } from '@/app/games/tank-trouble/constants/game-constants';\n\nexport interface GameInstance {\n  id: number;\n  tanks: Tank[];\n  bullets: Bullet[];\n  lastShotTimes: { blue: number; red: number };\n  gameMode: 'ai' | 'person-vs-ai';\n  gameId: string;\n  isPaused: boolean;\n  speedMultiplier: number;\n  episodeStartTime?: number;\n  keysRef: React.MutableRefObject<Set<string>>;\n}\n\ninterface MultiGameLogicProps {\n  mapData: TankTroubleMapData;\n  barriers: Barrier[];\n  suns: Sun[];\n  aiConfig?: AIConfig;\n  trainingManager?: RLTrainingManager | null;\n  maxEpisodeTimeMs?: number;\n  gameInstances: GameInstance[];\n  onTanksUpdate: (gameId: number, tanks: Tank[]) => void;\n  onBulletsUpdate: (gameId: number, bullets: Bullet[]) => void;\n  onLastShotTimesUpdate: (gameId: number, times: { blue: number; red: number }) => void;\n  onGameOver: (gameId: number, winner: 'blue' | 'red' | null) => void;\n}\n\ninterface GameTickOptions {\n  skipIntervalCheck?: boolean;\n  gameId?: number; // Optional: tick specific game, otherwise tick all\n}\n\n/**\n * Multi-game logic hook - handles game ticks for multiple game instances\n * This replaces the previous pattern of calling useGameLogic multiple times (which violated Rules of Hooks)\n */\nexport function useMultiGameLogic({\n  mapData,\n  barriers,\n  suns,\n  aiConfig,\n  trainingManager,\n  maxEpisodeTimeMs = MAX_EPISODE_TIME_MS,\n  gameInstances,\n  onTanksUpdate,\n  onBulletsUpdate,\n  onLastShotTimesUpdate,\n  onGameOver,\n}: MultiGameLogicProps) {\n  // Track game over states per game\n  const gameOverTriggeredRefs = useRef<Map<number, boolean>>(new Map());\n  \n  // Track last tick times per game\n  const lastTickRefs = useRef<Map<number, number>>(new Map());\n  \n  // Track tank/bullet refs per game\n  const tanksRefs = useRef<Map<number, Tank[]>>(new Map());\n  const bulletsRefs = useRef<Map<number, Bullet[]>>(new Map());\n  \n  // Store latest gameInstances in ref for access in callback (avoid stale closure)\n  const gameInstancesRef = useRef(gameInstances);\n  \n  // Create a Map for O(1) lookup by gameId instead of O(n) filter\n  const gameInstancesMapRef = useRef<Map<number, GameInstance>>(new Map());\n  \n  useEffect(() => {\n    gameInstancesRef.current = gameInstances;\n    // Update Map for efficient lookups\n    const map = new Map<number, GameInstance>();\n    gameInstances.forEach(instance => {\n      map.set(instance.id, instance);\n    });\n    gameInstancesMapRef.current = map;\n  }, [gameInstances]);\n  \n  // Initialize refs for all games\n  useEffect(() => {\n    gameInstances.forEach((instance) => {\n      if (!tanksRefs.current.has(instance.id)) {\n        tanksRefs.current.set(instance.id, instance.tanks);\n      }\n      if (!bulletsRefs.current.has(instance.id)) {\n        bulletsRefs.current.set(instance.id, instance.bullets);\n      }\n    });\n  }, [gameInstances]);\n  \n  // Update refs when state changes\n  useEffect(() => {\n    gameInstances.forEach((instance) => {\n      const prevTanks = tanksRefs.current.get(instance.id);\n      tanksRefs.current.set(instance.id, instance.tanks);\n      bulletsRefs.current.set(instance.id, instance.bullets);\n      \n      // Reset game over flag when tanks are reset (new game started)\n      if (instance.tanks.length >= 2 && \n          instance.tanks[0]?.lives === GAME_CONFIG.tank.lives && \n          instance.tanks[1]?.lives === GAME_CONFIG.tank.lives) {\n        gameOverTriggeredRefs.current.set(instance.id, false);\n      }\n    });\n  }, [gameInstances]);\n\n  const gameTick = useCallback(async (options?: GameTickOptions) => {\n    // Use ref to get latest game instances (avoid stale closure)\n    const currentGameInstances = gameInstancesRef.current;\n    const gamesToTick = options?.gameId !== undefined \n      ? (() => {\n          // Use Map for O(1) lookup instead of O(n) filter\n          const instance = gameInstancesMapRef.current.get(options.gameId);\n          return instance ? [instance] : [];\n        })()\n      : currentGameInstances;\n\n    // Use for...of instead of forEach to support async/await\n    for (const instance of gamesToTick) {\n      // Skip if paused\n      if (instance.isPaused) {\n        continue;\n      }\n      \n      const now = Date.now();\n      const lastTickTime = lastTickRefs.current.get(instance.id) || 0;\n      \n      // Check interval (unless skipIntervalCheck is true)\n      if (!options?.skipIntervalCheck) {\n        const adjustedTickInterval = TICK_INTERVAL / instance.speedMultiplier;\n        if (now - lastTickTime < adjustedTickInterval) {\n          return;\n        }\n      }\n      \n      const tickTime = now;\n      lastTickRefs.current.set(instance.id, tickTime);\n\n      const currentTanks = [...(tanksRefs.current.get(instance.id) || [])];\n      const currentBullets = [...(bulletsRefs.current.get(instance.id) || [])];\n      let newLastShotTimes = { ...instance.lastShotTimes };\n      const keys = instance.keysRef.current;\n      \n      // Validate tanks exist\n      if (!currentTanks || currentTanks.length < 2) {\n        continue;\n      }\n\n      // Update Player 1 (Blue)\n      if (currentTanks[0]?.lives > 0) {\n        let result;\n        \n        if (instance.gameMode === 'person-vs-ai') {\n          result = updatePlayer1Tank({\n            tank: currentTanks[0],\n            tankIndex: 0,\n            keys,\n            tickTime,\n            lastShotTime: instance.lastShotTimes.blue,\n            bullets: currentBullets,\n            mapWidth: mapData.width,\n            mapHeight: mapData.height,\n            barriers,\n            suns,\n            allTanks: currentTanks,\n          });\n        } else if (trainingManager && trainingManager.getIsTraining() && instance.gameMode === 'ai') {\n          result = await updateAITank(\n            {\n              tank: currentTanks[0],\n              tankIndex: 0,\n              keys,\n              tickTime,\n              lastShotTime: instance.lastShotTimes.blue,\n              bullets: currentBullets,\n              mapWidth: mapData.width,\n              mapHeight: mapData.height,\n              barriers,\n              suns,\n              allTanks: currentTanks,\n            },\n            aiConfig,\n            trainingManager,\n            `${instance.gameId}-blue`\n          );\n        } else {\n          result = updatePlayer1Tank({\n            tank: currentTanks[0],\n            tankIndex: 0,\n            keys,\n            tickTime,\n            lastShotTime: instance.lastShotTimes.blue,\n            bullets: currentBullets,\n            mapWidth: mapData.width,\n            mapHeight: mapData.height,\n            barriers,\n            suns,\n            allTanks: currentTanks,\n          });\n        }\n        \n        currentTanks[0] = result.updatedTank;\n        currentBullets.push(...result.newBullets);\n        newLastShotTimes.blue = result.lastShotTime;\n      }\n\n      // Update Player 2 (Red)\n      if (currentTanks[1]?.lives > 0) {\n        // Always use AI for red tank (simplified logic - removed duplicate branch)\n        const result = await updateAITank(\n          {\n            tank: currentTanks[1],\n            tankIndex: 1,\n            keys,\n            tickTime,\n            lastShotTime: instance.lastShotTimes.red,\n            bullets: currentBullets,\n            mapWidth: mapData.width,\n            mapHeight: mapData.height,\n            barriers,\n            suns,\n            allTanks: currentTanks,\n          },\n          aiConfig,\n          trainingManager,\n          instance.gameId\n        );\n        \n        currentTanks[1] = result.updatedTank;\n        currentBullets.push(...result.newBullets);\n        newLastShotTimes.red = result.lastShotTime;\n      }\n\n      // Update bullets\n      const bulletResult = updateBullets({\n        bullets: currentBullets,\n        tickTime,\n        mapWidth: mapData.width,\n        mapHeight: mapData.height,\n        barriers,\n        suns,\n        tanks: currentTanks,\n      });\n\n      const gameOverTriggered = gameOverTriggeredRefs.current.get(instance.id) || false;\n\n      // Check for timeout\n      if (!gameOverTriggered && instance.episodeStartTime) {\n        const episodeElapsed = tickTime - instance.episodeStartTime;\n        if (episodeElapsed >= maxEpisodeTimeMs) {\n          gameOverTriggeredRefs.current.set(instance.id, true);\n          const blueTank = bulletResult.updatedTanks[0];\n          const redTank = bulletResult.updatedTanks[1];\n          \n          let winner: 'blue' | 'red' | null = null;\n          if (blueTank && redTank) {\n            if (blueTank.lives > redTank.lives) {\n              winner = 'blue';\n            } else if (redTank.lives > blueTank.lives) {\n              winner = 'red';\n            }\n          }\n          \n          bulletResult.updatedBullets = [];\n          bulletResult.updatedTanks[0] = {\n            ...blueTank,\n            exploding: false,\n            explosionStartTime: undefined,\n            respawning: false,\n            respawnStartTime: undefined,\n            respawnTargetX: undefined,\n            respawnTargetY: undefined,\n            respawnTargetAngle: undefined,\n            invincibleUntil: undefined,\n          };\n          bulletResult.updatedTanks[1] = {\n            ...redTank,\n            exploding: false,\n            explosionStartTime: undefined,\n            respawning: false,\n            respawnStartTime: undefined,\n            respawnTargetX: undefined,\n            respawnTargetY: undefined,\n            respawnTargetAngle: undefined,\n            invincibleUntil: undefined,\n          };\n          \n          onTanksUpdate(instance.id, bulletResult.updatedTanks);\n          onBulletsUpdate(instance.id, bulletResult.updatedBullets);\n          onGameOver(instance.id, winner);\n          return;\n        }\n      }\n\n      // Check for game over (tank reached 0 lives)\n      const blueTankAfterBullets = bulletResult.updatedTanks[0];\n      const redTankAfterBullets = bulletResult.updatedTanks[1];\n      \n      if (!gameOverTriggered && blueTankAfterBullets && redTankAfterBullets) {\n        if (blueTankAfterBullets.lives <= 0 || redTankAfterBullets.lives <= 0) {\n          gameOverTriggeredRefs.current.set(instance.id, true);\n          const winner = blueTankAfterBullets.lives <= 0 ? 'red' : 'blue';\n          \n          bulletResult.updatedBullets = [];\n          bulletResult.updatedTanks[0] = {\n            ...blueTankAfterBullets,\n            exploding: false,\n            explosionStartTime: undefined,\n            respawning: false,\n            respawnStartTime: undefined,\n            respawnTargetX: undefined,\n            respawnTargetY: undefined,\n            respawnTargetAngle: undefined,\n            invincibleUntil: undefined,\n          };\n          bulletResult.updatedTanks[1] = {\n            ...redTankAfterBullets,\n            exploding: false,\n            explosionStartTime: undefined,\n            respawning: false,\n            respawnStartTime: undefined,\n            respawnTargetX: undefined,\n            respawnTargetY: undefined,\n            respawnTargetAngle: undefined,\n            invincibleUntil: undefined,\n          };\n          \n          onTanksUpdate(instance.id, bulletResult.updatedTanks);\n          onBulletsUpdate(instance.id, bulletResult.updatedBullets);\n          onGameOver(instance.id, winner);\n          return;\n        }\n      }\n\n      // Handle respawning\n      for (let i = 0; i < bulletResult.updatedTanks.length; i++) {\n        const tank = bulletResult.updatedTanks[i];\n        const originalTank = currentTanks[i];\n        \n        if (tank.lives < originalTank.lives && tank.lives > 0) {\n          const tankColor = tank.color;\n          // Optimized: build new array instead of filter (more explicit, same complexity but clearer intent)\n          const filteredBullets: typeof bulletResult.updatedBullets = [];\n          for (const bullet of bulletResult.updatedBullets) {\n            if (bullet.owner !== tankColor) {\n              filteredBullets.push(bullet);\n            }\n          }\n          bulletResult.updatedBullets = filteredBullets;\n          \n          const spawn = generateRandomSpawnPosition(\n            mapData,\n            barriers,\n            bulletResult.updatedTanks,\n            suns,\n            i === 0 ? bulletResult.updatedTanks[1] : bulletResult.updatedTanks[0]\n              ? { x: bulletResult.updatedTanks[i === 0 ? 1 : 0].x, y: bulletResult.updatedTanks[i === 0 ? 1 : 0].y }\n              : undefined\n          );\n          \n          // Set invincibility for 2 seconds after respawn\n          const INVINCIBILITY_DURATION_MS = 2000; // 2 seconds\n          bulletResult.updatedTanks[i] = {\n            ...tank,\n            x: spawn.x,\n            y: spawn.y,\n            angle: spawn.angle,\n            exploding: false,\n            explosionStartTime: undefined,\n            respawning: false,\n            respawnStartTime: undefined,\n            respawnTargetX: undefined,\n            respawnTargetY: undefined,\n            respawnTargetAngle: undefined,\n            invincibleUntil: tickTime + INVINCIBILITY_DURATION_MS,\n          };\n        }\n        \n        if (tank.exploding || tank.respawning) {\n          bulletResult.updatedTanks[i] = {\n            ...tank,\n            exploding: false,\n            explosionStartTime: undefined,\n            respawning: false,\n            respawnStartTime: undefined,\n            respawnTargetX: undefined,\n            respawnTargetY: undefined,\n            respawnTargetAngle: undefined,\n            // Don't clear invincibleUntil here - it may still be active\n          };\n        }\n        \n        // Clear invincibility if it has expired\n        if (tank.invincibleUntil !== undefined && tickTime >= tank.invincibleUntil) {\n          bulletResult.updatedTanks[i] = {\n            ...tank,\n            invincibleUntil: undefined,\n          };\n        }\n      }\n\n      if (!gameOverTriggered) {\n        onTanksUpdate(instance.id, bulletResult.updatedTanks);\n        onBulletsUpdate(instance.id, bulletResult.updatedBullets);\n        onLastShotTimesUpdate(instance.id, newLastShotTimes);\n      }\n    }\n  }, [\n    mapData,\n    barriers,\n    suns,\n    aiConfig,\n    trainingManager,\n    maxEpisodeTimeMs,\n    onTanksUpdate,\n    onBulletsUpdate,\n    onLastShotTimesUpdate,\n    onGameOver,\n  ]);\n\n  return { gameTick };\n}\n","import { useRef, useEffect } from 'react';\nimport type { Tank, Bullet, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport { GAME_CONFIG, TANK_SIZE, SUN_INFLUENCE_RADIUS, BULLET_MAX_AGE } from '@/app/games/tank-trouble/config';\n\ninterface GameCanvasProps {\n  width: number;\n  height: number;\n  tanks: Tank[];\n  bullets: Bullet[];\n  barriers: Barrier[];\n  suns: Sun[];\n  isPaused: boolean;\n  tankImages: { blue: HTMLImageElement | null; red: HTMLImageElement | null };\n  gameOverWinner: 'blue' | 'red' | null;\n  scale?: number; // Optional scale factor for display\n}\n\nexport function GameCanvas({\n  width,\n  height,\n  tanks,\n  bullets,\n  barriers,\n  suns,\n  isPaused,\n  tankImages,\n  gameOverWinner,\n  scale = 1,\n}: GameCanvasProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  // Auto-focus canvas on mount to enable immediate keyboard input\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas) {\n      // Focus the canvas so keyboard events work immediately\n      canvas.focus();\n      \n      // Also focus on click to ensure it stays focused\n      const handleCanvasClick = () => {\n        canvas.focus();\n      };\n      \n      canvas.addEventListener('click', handleCanvasClick);\n      \n      return () => {\n        canvas.removeEventListener('click', handleCanvasClick);\n      };\n    }\n  }, []);\n\n  // Render function\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Scale factor for crisp rendering\n    const scale = 2;\n    canvas.width = width * scale;\n    canvas.height = height * scale;\n    \n    // Reset transform matrix and scale the context\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.scale(scale, scale);\n\n    // Clear canvas completely\n    ctx.clearRect(0, 0, width, height);\n    ctx.fillStyle = '#2D3748';\n    ctx.fillRect(0, 0, width, height);\n\n    // Draw barriers\n    ctx.fillStyle = '#4A5568';\n    for (const barrier of barriers) {\n      ctx.fillRect(barrier.x, barrier.y, barrier.width, barrier.height);\n    }\n\n    // Draw gravitational field arrows (before suns so they appear behind)\n    // Skip if sun gravity is disabled via debug flag\n    if (!GAME_CONFIG.debug.disableSunGravity) {\n      ctx.strokeStyle = 'rgba(98, 156, 119, 0.3)';\n      ctx.fillStyle = 'rgba(98, 156, 119, 0.3)';\n      ctx.lineWidth = 1 / scale;\n      for (const sun of suns) {\n      const gridSpacing = 30;\n      const arrowLength = 8;\n      const arrowHeadSize = 3;\n      \n      // Draw arrows in a grid around the sun\n      for (let x = sun.x - SUN_INFLUENCE_RADIUS; x <= sun.x + SUN_INFLUENCE_RADIUS; x += gridSpacing) {\n        for (let y = sun.y - SUN_INFLUENCE_RADIUS; y <= sun.y + SUN_INFLUENCE_RADIUS; y += gridSpacing) {\n          const dx = sun.x - x;\n          const dy = sun.y - y;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n          \n          // Only draw if within influence radius and not too close to sun\n          if (distance > sun.size + 5 && distance < SUN_INFLUENCE_RADIUS) {\n            const angle = Math.atan2(dy, dx);\n            const normalizedDx = dx / distance;\n            const normalizedDy = dy / distance;\n            \n            // Draw arrow line\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n            ctx.lineTo(\n              x + normalizedDx * arrowLength,\n              y + normalizedDy * arrowLength\n            );\n            ctx.stroke();\n            \n            // Draw arrowhead\n            ctx.save();\n            ctx.translate(x + normalizedDx * arrowLength, y + normalizedDy * arrowLength);\n            ctx.rotate(angle);\n            ctx.beginPath();\n            ctx.moveTo(0, 0);\n            ctx.lineTo(-arrowHeadSize, -arrowHeadSize / 2);\n            ctx.lineTo(-arrowHeadSize, arrowHeadSize / 2);\n            ctx.closePath();\n            ctx.fill();\n            ctx.restore();\n          }\n        }\n      }\n      }\n    }\n\n    // Draw suns (skip if disabled via debug flag)\n    if (!GAME_CONFIG.debug.disableSunGravity) {\n      for (const sun of suns) {\n      const gradient = ctx.createRadialGradient(sun.x, sun.y, 0, sun.x, sun.y, sun.size);\n      gradient.addColorStop(0, 'rgba(98, 156, 119, 0.9)');\n      gradient.addColorStop(0.7, 'rgba(98, 156, 119, 0.75)');\n      gradient.addColorStop(1, 'rgba(98, 156, 119, 0)');\n      ctx.fillStyle = gradient;\n      ctx.beginPath();\n      ctx.arc(sun.x, sun.y, sun.size, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Draw sun outline\n      ctx.strokeStyle = 'rgba(98, 156, 119, 0.5)';\n      ctx.lineWidth = 2 / scale;\n      ctx.stroke();\n      }\n    }\n\n    // Draw tanks (no animations)\n    // Only draw valid tanks (exactly 2 tanks expected: blue and red)\n    // Optimized: direct array access instead of filter (tanks are guaranteed to be valid)\n    const validTanks = tanks.length >= 2 \n      ? [tanks[0], tanks[1]] \n      : tanks.slice(0, 2);\n    \n    for (const tank of validTanks) {\n      // Skip tanks with 0 lives or invalid positions\n      if (tank.lives <= 0 || tank.x === undefined || tank.y === undefined) continue;\n\n      ctx.save();\n      \n      // Check if tank is invincible (recently respawned)\n      // Use Date.now() for visual feedback (rendering doesn't need precise tick time)\n      const isInvincible = tank.invincibleUntil !== undefined && Date.now() < tank.invincibleUntil;\n      \n      // Draw golden circle for invincibility (before tank rotation so it stays centered)\n      if (isInvincible) {\n        const tankCenterX = tank.x + TANK_SIZE / 2;\n        const tankCenterY = tank.y + TANK_SIZE / 2;\n        const circleRadius = TANK_SIZE / 2 + 3; // Slightly larger than tank\n        \n        ctx.beginPath();\n        ctx.arc(tankCenterX, tankCenterY, circleRadius, 0, Math.PI * 2);\n        ctx.strokeStyle = '#FFD700'; // Golden color\n        ctx.lineWidth = 2 / scale;\n        ctx.stroke();\n      }\n      \n      ctx.translate(tank.x + TANK_SIZE / 2, tank.y + TANK_SIZE / 2);\n      ctx.rotate((tank.angle * Math.PI) / 180);\n      ctx.translate(-TANK_SIZE / 2, -TANK_SIZE / 2);\n      \n      // Draw tank image\n      const tankImage = tank.color === 'blue' ? tankImages.blue : tankImages.red;\n      if (tankImage) {\n        ctx.drawImage(tankImage, 0, 0, TANK_SIZE, TANK_SIZE);\n      } else {\n        // Fallback: draw colored rectangle if image not loaded\n        ctx.fillStyle = tank.color === 'blue' ? '#3B82F6' : '#EF4444';\n        ctx.fillRect(0, 0, TANK_SIZE, TANK_SIZE);\n        ctx.strokeStyle = tank.color === 'blue' ? '#1E40AF' : '#DC2626';\n        ctx.lineWidth = 2 / scale;\n        ctx.strokeRect(0, 0, TANK_SIZE, TANK_SIZE);\n      }\n\n      ctx.restore();\n\n      // Draw lives indicator\n      ctx.fillStyle = tank.color === 'blue' ? '#3B82F6' : '#EF4444';\n      for (let i = 0; i < tank.lives; i++) {\n        ctx.beginPath();\n        ctx.arc(\n          tank.x + GAME_CONFIG.visual.livesIndicatorOffsetX + i * GAME_CONFIG.visual.livesIndicatorSpacing,\n          tank.y + GAME_CONFIG.visual.livesIndicatorOffsetY,\n          GAME_CONFIG.visual.livesIndicatorRadius,\n          0,\n          Math.PI * 2\n        );\n        ctx.fill();\n      }\n    }\n\n    // Draw bullets (no explosion animations)\n    for (const bullet of bullets) {\n      // Skip exploding bullets (they're removed immediately, no animation)\n      if (bullet.exploding) {\n        continue;\n      }\n      \n      // Calculate fade alpha for bullets that are expiring (after 7 seconds)\n      const age = Date.now() - bullet.createdAt;\n      const fadeDuration = GAME_CONFIG.bullet.fadeDuration;\n      let alpha = 1;\n      \n      if (age > BULLET_MAX_AGE) {\n        // Bullet is fading out\n        const fadeProgress = (age - BULLET_MAX_AGE) / fadeDuration;\n        alpha = Math.max(0, 1 - fadeProgress);\n      }\n      \n      // Only draw if still visible\n      if (alpha > 0) {\n        // Extract RGB values and apply alpha\n        const r = bullet.owner === 'blue' ? 59 : 239;\n        const g = bullet.owner === 'blue' ? 130 : 68;\n        const b = bullet.owner === 'blue' ? 246 : 68;\n        \n        ctx.save();\n        ctx.globalAlpha = alpha;\n        \n        // Draw simple rectangle bullet with rounded corners\n        const bulletLength = 6;\n        const bulletWidth = 3;\n        const radius = 1; // Small border radius\n        const angleRad = (bullet.angle * Math.PI) / 180;\n        \n        // Translate and rotate to bullet position and angle\n        ctx.translate(bullet.x, bullet.y);\n        ctx.rotate(angleRad);\n        \n        // Draw rounded rectangle\n        const x = -bulletLength / 2;\n        const y = -bulletWidth / 2;\n        const w = bulletLength;\n        const h = bulletWidth;\n        \n        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;\n        ctx.beginPath();\n        ctx.moveTo(x + radius, y);\n        ctx.lineTo(x + w - radius, y);\n        ctx.quadraticCurveTo(x + w, y, x + w, y + radius);\n        ctx.lineTo(x + w, y + h - radius);\n        ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);\n        ctx.lineTo(x + radius, y + h);\n        ctx.quadraticCurveTo(x, y + h, x, y + h - radius);\n        ctx.lineTo(x, y + radius);\n        ctx.quadraticCurveTo(x, y, x + radius, y);\n        ctx.closePath();\n        ctx.fill();\n        \n        ctx.restore();\n      }\n    }\n\n    // Draw UI (lives counter removed from bottom-left)\n    \n    // Draw instructions in top-right corner\n    ctx.textAlign = 'right';\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n    ctx.font = `${GAME_CONFIG.visual.uiTextSize - 1}px Inter`;\n    const instructionY = GAME_CONFIG.visual.uiTextOffsetY;\n    const instructionX = width - GAME_CONFIG.visual.uiTextOffsetX;\n    ctx.fillText('Player 1 (Blue): Arrows + Space', instructionX, instructionY);\n    ctx.fillText('Player 2 (Red): WASD + Q', instructionX, instructionY + 12);\n    ctx.textAlign = 'left'; // Reset alignment\n    \n    // Draw game over screen\n    if (gameOverWinner) {\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n      ctx.fillRect(0, 0, width, height);\n      ctx.fillStyle = '#FFFFFF';\n      ctx.font = 'bold 32px Inter';\n      ctx.textAlign = 'center';\n      const winnerText = gameOverWinner === 'blue' ? 'BLUE WINS!' : 'RED WINS!';\n      ctx.fillText(winnerText, width / 2, height / 2 - 20);\n      ctx.font = '20px Inter';\n      ctx.fillText('Press any key to play again', width / 2, height / 2 + 20);\n      ctx.textAlign = 'left'; // Reset alignment\n    }\n    \n    // Draw pause indicator\n    if (isPaused && !gameOverWinner) {\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n      ctx.fillRect(0, 0, width, height);\n      ctx.fillStyle = '#FFFFFF';\n      ctx.font = 'bold 48px Inter';\n      ctx.textAlign = 'center';\n      ctx.fillText('PAUSED', width / 2, height / 2);\n      ctx.textAlign = 'left'; // Reset alignment\n    }\n    \n    // Debug text removed\n  }, [width, height, tanks, bullets, barriers, suns, isPaused, tankImages, gameOverWinner]);\n\n  // Calculate display size: internal resolution is 2x for crisp rendering, then apply scale\n  const displayWidth = width * 2 * scale;\n  const displayHeight = height * 2 * scale;\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className=\"border-2 border-[#4A5568] rounded outline-none\"\n      style={{ \n        width: `${displayWidth}px`, \n        height: `${displayHeight}px`,\n        display: 'block',\n      }}\n      tabIndex={0}\n      onFocus={(e) => e.target.focus()}\n    />\n  );\n}\n\n","/**\n * DQN (Deep Q-Network) Model Implementation\n * \n * Implements a DQN agent using TensorFlow.js for browser-based training.\n * DQN is well-suited for discrete action spaces.\n */\n\nimport * as tf from '@tensorflow/tfjs';\nimport type { Observation } from './rl-observation';\nimport type { AIDecision } from './types';\nimport { actionToDecision, NUM_DISCRETE_ACTIONS } from './rl-actions';\nimport { getObservationSize } from './rl-observation';\nimport { ROTATION_SPEED } from '@/app/games/tank-trouble/config';\nimport { assertType, is2DNumberArray, isError } from '@/lib/type-guards';\n\nexport interface DQNConfig {\n  observationSize: number;\n  actionSize: number;\n  learningRate: number;\n  hiddenLayers: number[];\n  gamma: number; // Discount factor\n  epsilonStart: number;\n  epsilonEnd: number;\n  epsilonDecay: number;\n  batchSize: number;\n  replayBufferSize: number;\n  targetUpdateFrequency: number;\n}\n\nexport const DEFAULT_DQN_CONFIG: DQNConfig = {\n  observationSize: getObservationSize(),\n  actionSize: NUM_DISCRETE_ACTIONS,\n  learningRate: 0.001,\n  hiddenLayers: [128, 128, 64],\n  gamma: 0.99,\n  epsilonStart: 1.0,\n  epsilonEnd: 0.01,\n  epsilonDecay: 0.995,\n  batchSize: 32,\n  replayBufferSize: 10000,\n  targetUpdateFrequency: 100,\n};\n\n/**\n * Step for replay buffer (state, action, reward, nextState, done)\n */\nexport interface Step {\n  state: number[];\n  action: number;\n  reward: number;\n  nextState: number[];\n  done: boolean;\n}\n\n/**\n * DQN Agent\n */\nexport class DQNAgent {\n  private qNetwork: tf.LayersModel | null = null;\n  private targetNetwork: tf.LayersModel | null = null;\n  private config: DQNConfig;\n  private epsilon: number;\n  private stepCount: number = 0;\n  private trainingInProgress: Promise<number> | null = null; // Active training promise - null means no training\n  private isDisposed: boolean = false; // Track if agent has been disposed\n\n  constructor(config: Partial<DQNConfig> = {}) {\n    this.config = { ...DEFAULT_DQN_CONFIG, ...config };\n    this.epsilon = this.config.epsilonStart;\n  }\n\n  /**\n   * Initialize the neural networks\n   */\n  async initialize(): Promise<void> {\n    this.qNetwork = this.createNetwork();\n    this.targetNetwork = this.createNetwork();\n    this.updateTargetNetwork();\n  }\n\n  /**\n   * Create the Q-network architecture\n   */\n  private createNetwork(): tf.LayersModel {\n    const model = tf.sequential();\n\n    // Input layer\n    model.add(\n      tf.layers.dense({\n        inputShape: [this.config.observationSize],\n        units: this.config.hiddenLayers[0],\n        activation: 'relu',\n        kernelInitializer: 'heNormal',\n      })\n    );\n\n    // Hidden layers\n    for (let i = 1; i < this.config.hiddenLayers.length; i++) {\n      model.add(\n        tf.layers.dense({\n          units: this.config.hiddenLayers[i],\n          activation: 'relu',\n          kernelInitializer: 'heNormal',\n        })\n      );\n    }\n\n    // Output layer (Q-values for each action)\n    model.add(\n      tf.layers.dense({\n        units: this.config.actionSize,\n        activation: 'linear',\n        kernelInitializer: 'zeros',\n      })\n    );\n\n    // Compile model\n    model.compile({\n      optimizer: tf.train.adam(this.config.learningRate),\n      loss: 'meanSquaredError',\n    });\n\n    return model;\n  }\n\n  /**\n   * Check if networks are valid and not disposed\n   */\n  private areNetworksValid(): boolean {\n    return !this.isDisposed && this.qNetwork !== null && this.targetNetwork !== null;\n  }\n\n  /**\n   * Select action using epsilon-greedy policy\n   */\n  async selectAction(observation: Observation, training: boolean = true): Promise<number> {\n    if (!this.qNetwork) {\n      throw new Error('Network not initialized. Call initialize() first.');\n    }\n\n    // Exploration: random action\n    if (training && Math.random() < this.epsilon) {\n      return Math.floor(Math.random() * this.config.actionSize);\n    }\n\n    // Exploitation: best action according to Q-network\n    const stateTensor = tf.tensor2d([observation.vector]);\n    const qValuesResult = this.qNetwork.predict(stateTensor);\n    // Type guard for TensorFlow Tensor\n    const qValues = assertType(\n      qValuesResult,\n      (val): val is tf.Tensor => val instanceof tf.Tensor,\n      'Expected Tensor from predict'\n    );\n    const qValuesArray = await qValues.data();\n    stateTensor.dispose();\n    qValues.dispose();\n\n    // Find action with highest Q-value\n    let bestAction = 0;\n    let bestQValue = qValuesArray[0];\n    for (let i = 1; i < qValuesArray.length; i++) {\n      if (qValuesArray[i] > bestQValue) {\n        bestQValue = qValuesArray[i];\n        bestAction = i;\n      }\n    }\n\n    return bestAction;\n  }\n\n  /**\n   * Predict action (for inference, no exploration)\n   */\n  async predict(observation: Observation, currentAngle: number): Promise<AIDecision> {\n    const action = await this.selectAction(observation, false);\n    return actionToDecision(action, currentAngle);\n  }\n\n  /**\n   * Train on a batch of steps\n   * \n   * Note: This method prevents concurrent training calls by using a promise-based lock.\n   * If training is already in progress, this call will wait for it and skip (return 0).\n   */\n  async train(steps: Step[]): Promise<number> {\n    if (!this.areNetworksValid() || steps.length === 0) {\n      return 0;\n    }\n\n    // If training is already in progress, wait for it and skip this call\n    if (this.trainingInProgress) {\n      try {\n        await this.trainingInProgress;\n      } catch (error) {\n        // Ignore errors from previous training - we're just waiting\n      }\n      return 0;\n    }\n\n    // Create and assign the promise SYNCHRONOUSLY before any async work\n    let resolveTraining: ((value: number) => void) | undefined;\n    let rejectTraining: ((error: unknown) => void) | undefined;\n    \n    this.trainingInProgress = new Promise<number>((resolve, reject) => {\n      resolveTraining = resolve;\n      rejectTraining = reject;\n    });\n\n    // Start async training work\n    this.executeTraining(steps, this.trainingInProgress)\n      .then((result) => {\n        this.trainingInProgress = null;\n        if (resolveTraining) resolveTraining(result);\n      })\n      .catch((error) => {\n        this.trainingInProgress = null;\n        if (rejectTraining) rejectTraining(error);\n      });\n\n    try {\n      return await this.trainingInProgress;\n    } catch (error) {\n      // Return 0 on error instead of throwing - training errors shouldn't crash the app\n      return 0;\n    }\n  }\n\n  /**\n   * Internal method that performs the actual training\n   */\n  private async executeTraining(steps: Step[], currentTrainingPromise: Promise<number>): Promise<number> {\n    // Prepare batch\n    const batchSize = Math.min(steps.length, this.config.batchSize);\n    const states: number[][] = [];\n    const actions: number[] = [];\n    const rewards: number[] = [];\n    const nextStates: number[][] = [];\n    const dones: boolean[] = [];\n\n    for (let i = 0; i < batchSize; i++) {\n      const step = steps[i];\n      states.push(step.state);\n      actions.push(step.action);\n      rewards.push(step.reward);\n      nextStates.push(step.nextState);\n      dones.push(step.done);\n    }\n\n    // Create tensors\n    const statesTensor = tf.tensor2d(states);\n    const nextStatesTensor = tf.tensor2d(nextStates);\n    \n    // Track all tensors for cleanup\n    const tensorsToDispose: tf.Tensor[] = [statesTensor, nextStatesTensor];\n\n    try {\n      // Verify we're still the active training call and networks are valid\n      if (!this.areNetworksValid() || this.trainingInProgress !== currentTrainingPromise) {\n        return 0;\n      }\n\n      // Get Q-values from both networks\n      if (!this.qNetwork || !this.targetNetwork) {\n        throw new Error('Networks not initialized');\n      }\n      const currentQValuesResult = this.qNetwork.predict(statesTensor);\n      const nextQValuesResult = this.targetNetwork.predict(nextStatesTensor);\n      \n      // Type guards for TensorFlow Tensors\n      const currentQValues = assertType(\n        currentQValuesResult,\n        (val): val is tf.Tensor => val instanceof tf.Tensor,\n        'Expected Tensor from predict'\n      );\n      const nextQValues = assertType(\n        nextQValuesResult,\n        (val): val is tf.Tensor => val instanceof tf.Tensor,\n        'Expected Tensor from predict'\n      );\n      tensorsToDispose.push(currentQValues, nextQValues);\n\n      // Extract arrays (this is async, but if network is disposed, it will throw)\n      const currentQArrayResult = await currentQValues.array();\n      const nextQArrayResult = await nextQValues.array();\n      \n      // Type guard for 2D number arrays\n      const currentQArray = assertType(\n        currentQArrayResult,\n        is2DNumberArray,\n        'Expected 2D number array from tensor.array()'\n      );\n      const nextQArray = assertType(\n        nextQArrayResult,\n        is2DNumberArray,\n        'Expected 2D number array from tensor.array()'\n      );\n\n      // Verify again after async operation\n      if (!this.areNetworksValid() || this.trainingInProgress !== currentTrainingPromise) {\n        return 0;\n      }\n\n      // Compute target Q-values\n      const targets: number[][] = [];\n      for (let i = 0; i < batchSize; i++) {\n        const target = [...currentQArray[i]];\n        const maxNextQ = Math.max(...nextQArray[i]);\n        const targetQ = rewards[i] + (dones[i] ? 0 : this.config.gamma * maxNextQ);\n        target[actions[i]] = targetQ;\n        targets.push(target);\n      }\n\n      const targetsTensor = tf.tensor2d(targets);\n      tensorsToDispose.push(targetsTensor);\n\n      // Final check before training\n      if (!this.areNetworksValid() || this.trainingInProgress !== currentTrainingPromise) {\n        return 0;\n      }\n\n      // Train the network\n      if (!this.qNetwork) {\n        throw new Error('Network not initialized');\n      }\n      const history = await this.qNetwork.fit(statesTensor, targetsTensor, {\n        epochs: 1,\n        verbose: 0,\n        batchSize: batchSize,\n      });\n\n      // Extract loss value\n      let loss: number = 0;\n      if (Array.isArray(history.history.loss)) {\n        const firstLoss = history.history.loss[0];\n        if (typeof firstLoss === 'number') {\n          loss = firstLoss;\n        }\n      } else if (typeof history.history.loss === 'number') {\n        loss = history.history.loss;\n      } else if (history.history.loss && typeof history.history.loss === 'object') {\n        // Check if it has dataSync method (TensorFlow Tensor)\n        // Use JSON to safely access properties without type assertions\n        try {\n          const jsonString = JSON.stringify(history.history.loss);\n          const parsed = JSON.parse(jsonString);\n          // TensorFlow tensors can't be serialized, so if we get here it's not a tensor\n          // Skip this branch for tensor objects\n        } catch {\n          // If JSON.stringify fails, it might be a TensorFlow tensor\n          // Check for dataSync method using property access\n          // Skip tensor handling to avoid type assertions\n          // In practice, loss should be a number or array, not a tensor\n          // TensorFlow tensors can't be safely handled without type assertions\n        }\n      }\n\n      // Update epsilon\n      this.epsilon = Math.max(\n        this.config.epsilonEnd,\n        this.epsilon * this.config.epsilonDecay\n      );\n\n      // Update target network periodically\n      this.stepCount++;\n      if (this.stepCount % this.config.targetUpdateFrequency === 0) {\n        this.updateTargetNetwork();\n      }\n\n      return loss;\n    } catch (error: unknown) {\n      // If network was disposed, silently return 0\n      // Otherwise, log the error but don't throw (training errors shouldn't crash)\n      const errorMessage = isError(error) ? error.message : String(error);\n      if (!errorMessage.includes('disposed')) {\n      }\n      return 0;\n    } finally {\n      // Always cleanup tensors\n      tensorsToDispose.forEach(tensor => {\n        try {\n          tensor.dispose();\n        } catch (e) {\n          // Ignore disposal errors\n        }\n      });\n    }\n  }\n\n  /**\n   * Copy weights from Q-network to target network\n   */\n  private updateTargetNetwork(): void {\n    if (!this.qNetwork || !this.targetNetwork) {\n      return;\n    }\n\n    const weights = this.qNetwork.getWeights();\n    this.targetNetwork.setWeights(weights);\n  }\n\n  /**\n   * Get current epsilon (for logging)\n   */\n  getEpsilon(): number {\n    return this.epsilon;\n  }\n\n  /**\n   * Save model\n   */\n  async save(path: string): Promise<void> {\n    if (typeof window === 'undefined') {\n      throw new Error('Cannot save model: IndexedDB is only available in the browser (not during SSR)');\n    }\n    \n    if (!this.qNetwork) {\n      throw new Error('Network not initialized. Cannot save model.');\n    }\n    \n    // Verify the model is valid and not disposed\n    if (!this.areNetworksValid()) {\n      throw new Error('Network has been disposed. Cannot save model.');\n    }\n    \n    // Check if IndexedDB is available\n    if (typeof indexedDB === 'undefined') {\n      throw new Error('IndexedDB is not available in this browser. Cannot save model.');\n    }\n    \n    try {\n      \n      // Verify path format - TensorFlow.js expects 'indexeddb://model-name'\n      // Common issue: extra slashes or special characters cause silent failures\n      if (!path.startsWith('indexeddb://')) {\n        throw new Error(`Invalid path format. Expected 'indexeddb://...', got: ${path}`);\n      }\n      \n      const cleanPath = path.replace('indexeddb://', '');\n      \n      // Validate clean path - TensorFlow.js object store names have restrictions\n      // They cannot contain certain characters and should be simple identifiers\n      if (cleanPath.includes('/') || cleanPath.includes('\\\\') || cleanPath.includes(' ')) {\n        throw new Error(`Invalid model name. Object store names cannot contain slashes or spaces. Got: ${cleanPath}`);\n      }\n      \n      if (cleanPath.length === 0) {\n        throw new Error('Invalid model name. Model name cannot be empty.');\n      }\n      \n      \n      // Check browser IndexedDB support and permissions\n      if (typeof indexedDB === 'undefined') {\n        throw new Error('IndexedDB is not available in this browser. Cannot save model.');\n      }\n      \n      // Check if we're in a context where IndexedDB might be restricted\n      // (e.g., Safari private browsing, iframe without permissions)\n      try {\n        const testDbName = '__tfjs_test_db__';\n        const testRequest = indexedDB.open(testDbName);\n        await new Promise<void>((resolve, reject) => {\n          testRequest.onsuccess = () => {\n            testRequest.result.close();\n            indexedDB.deleteDatabase(testDbName);\n            resolve();\n          };\n          testRequest.onerror = () => reject(new Error('IndexedDB open failed - may be restricted'));\n          testRequest.onblocked = () => reject(new Error('IndexedDB is blocked - may need user interaction'));\n        });\n      } catch (testError) {\n        const error = testError instanceof Error ? testError : new Error(String(testError));\n        console.warn('DQNAgent: IndexedDB access test failed:', error.message);\n        throw new Error(`IndexedDB access restricted: ${error.message}. This may be due to browser privacy settings, private browsing mode, or iframe permissions.`);\n      }\n      \n      // Save the model - TensorFlow.js will create the object store automatically\n      // Note: TensorFlow.js save() returns a ModelArtifactsInfo object with modelTopology and weightData\n      let saveResult: any = null;\n      \n      \n      try {\n        // Check model state before saving\n        const weights = this.qNetwork.getWeights();\n        \n        // Try saving - TensorFlow.js should create the object store\n        // Note: model.save() should work for LayersModel, but let's verify it's actually saving\n        // CRITICAL: TensorFlow.js save() can fail silently if:\n        // 1. Model isn't compiled (we check this above)\n        // 2. Path format is wrong (we validate this above)\n        // 3. IndexedDB permissions are restricted (browser issue)\n        // 4. Model hasn't been trained (weights are still initial values)\n        \n        // Verify model is in a saveable state\n        if (!this.qNetwork.optimizer) {\n          throw new Error('Model is not compiled. Cannot save uncompiled model.');\n        }\n        \n        // Check if model has been trained (weights updated from initial values)\n        // TensorFlow.js may have issues saving models that haven't been trained\n        // We check stepCount to see if training has occurred\n        if (this.stepCount === 0) {\n          console.warn('DQNAgent: WARNING - Model has not been trained yet (stepCount = 0). Saving anyway, but this may cause issues.');\n        }\n        \n        // Try saving - wrap in additional error handling\n        try {\n          saveResult = await this.qNetwork.save(path);\n        } catch (saveError) {\n          // Re-throw with more context\n          const error = saveError instanceof Error ? saveError : new Error(String(saveError));\n          console.error('DQNAgent: TensorFlow.js save() threw an error:', error);\n          console.error('DQNAgent: Error details:', {\n            message: error.message,\n            stack: error.stack,\n            path: path,\n            modelCompiled: !!this.qNetwork.optimizer,\n          });\n          throw new Error(`TensorFlow.js save() failed: ${error.message}`);\n        }\n        \n        // Wait a brief moment for IndexedDB transaction to commit\n        // IndexedDB operations are asynchronous and may need time to complete\n        await new Promise(resolve => setTimeout(resolve, 200));\n        \n        // Check what databases exist after saving\n        if (indexedDB.databases) {\n          try {\n            const databasesAfter = await indexedDB.databases();\n            \n            // Look for TensorFlow.js database\n            const tfDb = databasesAfter.find(db => db.name === 'tensorflowjs_models' || (db.name && db.name.includes('tensorflow')));\n            if (tfDb && tfDb.name) {\n              // Try to inspect the database\n              const inspectRequest = indexedDB.open(tfDb.name);\n              inspectRequest.onsuccess = () => {\n                const db = inspectRequest.result;\n                db.close();\n              };\n              inspectRequest.onerror = () => {\n                console.warn('DQNAgent: Could not inspect TensorFlow.js database');\n              };\n            } else {\n              console.warn('DQNAgent: WARNING - No TensorFlow.js database found after save!');\n            }\n          } catch (dbError) {\n            console.warn('DQNAgent: Could not list databases:', dbError);\n          }\n        }\n        \n        // Check if TensorFlow.js can list the model\n        // TensorFlow.js provides tf.io.listModels() to enumerate saved models\n        try {\n          const savedModels = await tf.io.listModels();\n          const modelKeys = Object.keys(savedModels);\n          \n          // Check if our model is in the list\n          const cleanPath = path.replace('indexeddb://', '');\n          const modelInList = modelKeys.some(key => key.includes(cleanPath) || key === path || key.endsWith(cleanPath));\n          \n          if (!modelInList) {\n            console.warn('DQNAgent: WARNING - Model not found in TensorFlow.js list, but save() completed');\n            console.warn('DQNAgent: Expected path:', path);\n            console.warn('DQNAgent: Clean path:', cleanPath);\n          }\n        } catch (listError) {\n          console.warn('DQNAgent: Could not list models (this is okay):', listError);\n        }\n        \n        // Immediately try to load the model to verify it was saved\n        // This is a common pattern to catch silent failures\n        try {\n          const testLoad = await tf.loadLayersModel(path);\n          // Dispose the test load - we don't need it\n          testLoad.dispose();\n        } catch (loadError) {\n          const error = loadError instanceof Error ? loadError : new Error(String(loadError));\n          console.error('DQNAgent: CRITICAL - Model save() completed but cannot be loaded!');\n          console.error('DQNAgent: Load error:', error.message);\n          console.error('DQNAgent: Load error stack:', error.stack);\n          \n          // Try to get more information about what TensorFlow.js sees\n          try {\n            const savedModels = await tf.io.listModels();\n            console.error('DQNAgent: Available models according to TensorFlow.js:', Object.keys(savedModels));\n          } catch (e) {\n            console.error('DQNAgent: Could not list models:', e);\n          }\n          \n          throw new Error(`Model save() completed but verification load failed: ${error.message}. This indicates the model was not actually saved to IndexedDB.`);\n        }\n        \n        if (!saveResult) {\n          console.warn('DQNAgent: WARNING - save() returned null/undefined');\n        }\n        \n        // After saving, check what databases exist now and debug what was created\n        if (typeof indexedDB.databases === 'function') {\n          // Debug: List all databases and their object stores\n          const { debugListAllIndexedDBDatabases } = await import('./rl-model-storage');\n          await debugListAllIndexedDBDatabases();\n        }\n      } catch (saveErr) {\n        const saveError = saveErr instanceof Error ? saveErr : new Error(String(saveErr));\n        console.error('DQNAgent: Error during model.save():', saveError);\n        console.error('DQNAgent: Error message:', saveError.message);\n        console.error('DQNAgent: Error stack:', saveError.stack);\n        throw saveError;\n      }\n      \n      // Wait longer for IndexedDB to sync (TensorFlow.js might be async)\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      // Verify the model was actually saved\n      const { modelExists, listAvailableModelPaths } = await import('./rl-model-storage');\n      \n      // First, check what's actually in the database\n      await listAvailableModelPaths();\n      \n      // Try verification with retries (IndexedDB can be slow to sync)\n      let exists = false;\n      let retries = 0;\n      while (!exists && retries < 5) {\n        exists = await modelExists(path);\n        if (!exists && retries < 4) {\n          // Re-check available paths in case they changed\n          await listAvailableModelPaths();\n          await new Promise(resolve => setTimeout(resolve, 500));\n        }\n        retries++;\n      }\n      \n      if (!exists) {\n        // Final check of what's available\n        const finalPaths = await listAvailableModelPaths();\n        const errorMsg = `Model save() completed but weights were NOT saved to IndexedDB.\\n` +\n          `Expected path: ${path}\\n` +\n          `Clean path: ${cleanPath}\\n` +\n          `Available paths: ${finalPaths.join(', ') || 'none'}\\n` +\n          `This suggests TensorFlow.js save() failed silently or used a different path format.`;\n        console.error('DQNAgent: CRITICAL ERROR:', errorMsg);\n        throw new Error(errorMsg);\n      }\n    } catch (error) {\n      console.error('DQNAgent: Error saving model:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load model\n   */\n  async load(path: string): Promise<void> {\n    if (typeof window === 'undefined') {\n      throw new Error('Cannot load model: IndexedDB is only available in the browser (not during SSR)');\n    }\n    \n    // Wait for any in-progress training to complete before loading new model\n    if (this.trainingInProgress) {\n      await this.trainingInProgress.catch(() => {\n        // Ignore errors from previous training\n      });\n    }\n    \n    // Verify model exists before attempting to load\n    // Note: Dexie stores metadata, but TensorFlow.js stores the actual model weights in IndexedDB\n    const { modelExists, listAvailableModelPaths, listSavedModels } = await import('./rl-model-storage');\n    \n    // First check if model exists in TensorFlow.js IndexedDB (where the weights are stored)\n    const exists = await modelExists(path);\n    \n    if (!exists) {\n      // Check if model exists in Dexie metadata (to provide better error message)\n      const savedModels = await listSavedModels();\n      const modelInMetadata = savedModels.find(m => m.path === path);\n      \n      const availablePaths = await listAvailableModelPaths();\n      const cleanPath = path.replace('indexeddb://', '');\n      \n      let errorMessage = `Cannot find model weights for '${path}'.\\n\\n`;\n      errorMessage += `Note: Model metadata is stored in Dexie DB, but the actual model weights are stored in TensorFlow.js IndexedDB.\\n\\n`;\n      \n      if (modelInMetadata) {\n        errorMessage += `⚠️ Model metadata exists in Dexie, but the model weights are missing from TensorFlow.js IndexedDB.\\n`;\n        errorMessage += `This can happen if:\\n`;\n        errorMessage += `• The model was deleted from IndexedDB but metadata remains\\n`;\n        errorMessage += `• Browser storage was cleared for IndexedDB but not Dexie\\n`;\n        errorMessage += `• There was an error during model save\\n\\n`;\n      }\n      \n      errorMessage += `Looking for TensorFlow.js object store: '${cleanPath}'\\n\\n`;\n      \n      if (availablePaths.length > 0) {\n        errorMessage += `Available models in TensorFlow.js IndexedDB:\\n`;\n        availablePaths.forEach(p => {\n          errorMessage += `  - ${p}\\n`;\n        });\n      } else {\n        errorMessage += `No models found in TensorFlow.js IndexedDB. Make sure you've saved a model first.`;\n      }\n      \n      throw new Error(errorMessage);\n    }\n    \n    try {\n    const newQNetwork = await tf.loadLayersModel(path);\n    \n    // CRITICAL: Models loaded from IndexedDB are NOT compiled.\n    // TensorFlow.js requires models to be compiled before they can be saved.\n    // Compile the loaded model with the same optimizer and loss function.\n    newQNetwork.compile({\n      optimizer: tf.train.adam(this.config.learningRate),\n      loss: 'meanSquaredError',\n    });\n    \n    const newTargetNetwork = this.createNetwork();\n    \n    // Dispose old networks only after new ones are loaded\n    if (this.qNetwork) {\n      this.qNetwork.dispose();\n    }\n    if (this.targetNetwork) {\n      this.targetNetwork.dispose();\n    }\n    \n    this.qNetwork = newQNetwork;\n    this.targetNetwork = newTargetNetwork;\n    this.updateTargetNetwork();\n    } catch (error) {\n      console.error('DQNAgent: Error loading model:', error);\n      \n      // Check for Safari/IndexedDB specific issues\n      const isSafari = typeof window !== 'undefined' && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      \n      let detailedError = `Failed to load model from ${path}: ${errorMessage}`;\n      \n      if (isSafari) {\n        detailedError += '\\n\\nSafari detected. Common issues:\\n';\n        detailedError += '• Private Browsing mode disables IndexedDB - try regular browsing mode\\n';\n        detailedError += '• Safari may require user interaction before accessing IndexedDB\\n';\n        detailedError += '• Check Safari settings: Preferences > Privacy > uncheck \"Prevent cross-site tracking\"';\n      }\n      \n      throw new Error(detailedError);\n    }\n  }\n\n  /**\n   * Load model weights from Supabase JSON format\n   * @param weightsData Array of layer weights in Supabase format: [{weights: number[], biases: number[]}, ...]\n   */\n  async loadWeightsFromJSON(weightsData: Array<{ weights: number[]; biases: number[] }>): Promise<void> {\n    if (typeof window === 'undefined') {\n      throw new Error('Cannot load weights: Only available in browser');\n    }\n\n    // Wait for any in-progress training to complete\n    if (this.trainingInProgress) {\n      await this.trainingInProgress.catch(() => {\n        // Ignore errors from previous training\n      });\n    }\n\n    // Ensure networks are initialized\n    if (!this.qNetwork || !this.targetNetwork) {\n      await this.initialize();\n    }\n\n    if (!this.qNetwork || !this.targetNetwork) {\n      throw new Error('Failed to initialize networks');\n    }\n\n    try {\n      // Convert JSON weights to TensorFlow.js weight format\n      // TensorFlow.js expects: [kernel, bias] for each layer\n      const tfWeights: tf.Tensor[] = [];\n      \n      for (const layer of weightsData) {\n        // Get layer shape from existing network\n        const layerIndex = tfWeights.length / 2; // Each layer has 2 tensors (kernel, bias)\n        const layerConfig = this.qNetwork.layers[layerIndex];\n        \n        if (!layerConfig) {\n          throw new Error(`Layer ${layerIndex} not found in network`);\n        }\n\n        // Get expected shape from layer\n        const kernelShape = layerConfig.getWeights()[0].shape;\n        const biasShape = layerConfig.getWeights()[1].shape;\n\n        // Reshape weights array to match layer shape\n        // Weights are stored as flat array: [inputSize * outputSize]\n        const kernel = tf.tensor2d(\n          layer.weights,\n          kernelShape as [number, number]\n        );\n\n        // Biases are stored as flat array: [outputSize]\n        const bias = tf.tensor1d(layer.biases);\n\n        tfWeights.push(kernel, bias);\n      }\n\n      // Set weights on both networks\n      this.qNetwork.setWeights(tfWeights);\n      this.targetNetwork.setWeights(tfWeights);\n      this.updateTargetNetwork();\n\n      // Dispose temporary tensors\n      tfWeights.forEach(t => t.dispose());\n    } catch (error) {\n      console.error('DQNAgent: Error loading weights from JSON:', error);\n      throw new Error(`Failed to load weights from JSON: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  /**\n   * Dispose resources\n   */\n  dispose(): void {\n    this.isDisposed = true;\n    \n    // Wait for any in-progress training to complete before disposing\n    const disposeNetworks = () => {\n      if (this.qNetwork) {\n        this.qNetwork.dispose();\n      }\n      if (this.targetNetwork) {\n        this.targetNetwork.dispose();\n      }\n    };\n\n    if (this.trainingInProgress) {\n      this.trainingInProgress\n        .then(disposeNetworks)\n        .catch(disposeNetworks); // Dispose even if training fails\n    } else {\n      disposeNetworks();\n    }\n  }\n}\n","/**\n * Step Replay Buffer\n * \n * Stores steps for training the DQN agent.\n * Uses a circular buffer to maintain a fixed-size memory.\n */\n\nimport type { Step } from './rl-dqn-model';\n\nexport class ReplayBuffer {\n  private buffer: Step[] = [];\n  private maxSize: number;\n  private currentIndex: number = 0;\n\n  constructor(maxSize: number = 10000) {\n    this.maxSize = maxSize;\n  }\n\n  /**\n   * Add step to buffer\n   */\n  add(step: Step): void {\n    if (this.buffer.length < this.maxSize) {\n      this.buffer.push(step);\n    } else {\n      // Overwrite oldest step (circular buffer)\n      this.buffer[this.currentIndex] = step;\n      this.currentIndex = (this.currentIndex + 1) % this.maxSize;\n    }\n  }\n\n  /**\n   * Add multiple steps\n   */\n  addBatch(steps: Step[]): void {\n    for (const step of steps) {\n      this.add(step);\n    }\n  }\n\n  /**\n   * Sample a batch of steps\n   */\n  sample(batchSize: number): Step[] {\n    if (this.buffer.length < batchSize) {\n      // Return all steps if buffer is smaller than batch size\n      return [...this.buffer];\n    }\n\n    // Random sampling\n    const indices: number[] = [];\n    const sampled: Step[] = [];\n\n    while (indices.length < batchSize) {\n      const index = Math.floor(Math.random() * this.buffer.length);\n      if (!indices.includes(index)) {\n        indices.push(index);\n        sampled.push(this.buffer[index]);\n      }\n    }\n\n    return sampled;\n  }\n\n  /**\n   * Get current buffer size\n   */\n  size(): number {\n    return this.buffer.length;\n  }\n\n  /**\n   * Check if buffer has enough samples for training\n   */\n  canSample(batchSize: number): boolean {\n    return this.buffer.length >= batchSize;\n  }\n\n  /**\n   * Clear buffer\n   */\n  clear(): void {\n    this.buffer = [];\n    this.currentIndex = 0;\n  }\n\n  /**\n   * Get all steps (for debugging)\n   */\n  getAll(): Step[] {\n    return [...this.buffer];\n  }\n}\n\n","/**\n * RL Training Manager\n * \n * Coordinates the training process, managing episodes, step collection,\n * and model updates. Integrates with the game to collect training data.\n */\n\nimport { DQNAgent, type DQNConfig, DEFAULT_DQN_CONFIG } from './rl-dqn-model';\nimport { ReplayBuffer } from './rl-replay-buffer';\nimport { TankTroubleRLEnv, type RLEnvironmentState } from './rl-environment';\nimport { rlModelManager, TensorFlowJSModel, type ExtendedRLModel } from './rl-model';\nimport { saveModelWithMetadata } from './rl-model-storage';\nimport type { AIContext, AIDecision } from './types';\nimport type { Observation } from './rl-observation';\nimport type { Step } from './rl-dqn-model';\nimport { MAX_EPISODE_TIME_MS } from '@/app/games/tank-trouble/constants/game-constants';\n\nexport interface TrainingStats {\n  episode: number;\n  episodeReward: number;\n  episodeLength: number;\n  totalReward: number;\n  averageReward: number;\n  epsilon: number;\n  loss: number;\n}\n\nexport interface TrainingConfig {\n  dqn: Partial<DQNConfig>;\n  episodes: number;\n  trainEvery: number; // Train every N steps\n  saveEvery: number; // Save model every N episodes\n  selfPlay: boolean;\n  // TODO: Implement headless mode later - this will allow faster training by skipping rendering\n  // When implemented, headless mode will run game logic without rendering UI for faster training\n  headless: boolean;\n  maxEpisodeTimeMs: number; // Maximum episode duration in milliseconds before timeout (default: MAX_EPISODE_TIME_MS = 60 seconds)\n  onEpisodeComplete?: (stats: TrainingStats) => void;\n  onTrainingUpdate?: (stats: Partial<TrainingStats>) => void;\n}\n\nexport class RLTrainingManager {\n  private agent: DQNAgent;\n  private replayBuffer: ReplayBuffer;\n  private env: TankTroubleRLEnv;\n  private config: TrainingConfig;\n  private stats: TrainingStats;\n  private isTraining: boolean = false;\n  private currentEpisode: number = 0;\n  private completedEpisodes: number = 0; // Track completed episodes separately for accurate average calculation\n  private stepCount: number = 0;\n  private hasTrainedAtLeastOnce: boolean = false; // Track if training has occurred at least once\n  // Per-game state tracking\n  private gameStates: Map<string, { observation?: Observation; lastAction?: number; reward?: number }> = new Map();\n  private activeGameEpisodes: Set<string> = new Set(); // Track which games have active episodes\n  private gameEpisodeRewards: Map<string, number> = new Map(); // Track episode reward per game\n  private gameEpisodeLengths: Map<string, number> = new Map(); // Track episode length per game\n\n  constructor(config: Partial<TrainingConfig> = {}) {\n    this.config = {\n      dqn: {},\n      episodes: 1000,\n      trainEvery: 4,\n      saveEvery: 100,\n      selfPlay: true,\n      // TODO: Implement headless mode later - this will allow faster training by skipping rendering\n      // When implemented, set headless: true by default, or use config.headless if provided\n      headless: false, // Currently always false - headless mode not yet implemented\n      maxEpisodeTimeMs: MAX_EPISODE_TIME_MS,\n      ...config,\n    };\n\n    this.agent = new DQNAgent({\n      ...DEFAULT_DQN_CONFIG,\n      ...this.config.dqn,\n    });\n\n    this.replayBuffer = new ReplayBuffer(\n      this.config.dqn.replayBufferSize || DEFAULT_DQN_CONFIG.replayBufferSize\n    );\n\n    this.env = new TankTroubleRLEnv(this.config.maxEpisodeTimeMs);\n\n    this.stats = {\n      episode: 0,\n      episodeReward: 0,\n      episodeLength: 0,\n      totalReward: 0,\n      averageReward: 0,\n      epsilon: 1.0,\n      loss: 0,\n    };\n  }\n\n  /**\n   * Initialize training (create networks, etc.)\n   */\n  async initialize(): Promise<void> {\n    await this.agent.initialize();\n    \n    // Set up model for game and connect agent to model manager\n    // This allows the game to use the trained model during training\n    const model = new TensorFlowJSModel({\n      name: 'TankTroubleRL',\n      type: 'discrete',\n      observationSize: DEFAULT_DQN_CONFIG.observationSize,\n      actionSize: DEFAULT_DQN_CONFIG.actionSize,\n    });\n    \n    // Connect agent to model interface for use in game\n    // This allows the game controller to use the trained model during training\n    // Note: RLModel.predict is synchronous, but agent.predict is async\n    // We use a synchronous wrapper that falls back to rule-based for game loop\n    // The actual RL predictions happen in training step (async)\n    const extendedModel: ExtendedRLModel = {\n      isLoaded: () => model.isLoaded(),\n      load: (path: string) => model.load(path),\n      getInfo: () => model.getInfo(),\n      agent: this.agent,\n      // Synchronous predict for game loop compatibility\n      // Actual RL predictions happen in training step\n      predict: (obs: Observation, angle: number): AIDecision => {\n        // For game loop, return rule-based decision\n        // RL predictions are handled separately in training step\n        // This is a design limitation - ideally controller would be async\n        return {\n          angleDelta: 0,\n          moveDirection: 0,\n          shouldShoot: false,\n        };\n      },\n    };\n    \n    // Set model in global model manager so game controller can use it during training\n    rlModelManager.setModel(extendedModel);\n  }\n\n  /**\n   * Run one training step\n   * \n   * This should be called from the game loop after each game tick.\n   * The decision parameter is the action that was actually taken.\n   * \n   * @param gameId - Unique identifier for the game instance (e.g., \"game-0\", \"game-1\")\n   *                 This allows tracking state per game while sharing the model\n   */\n  async step(context: AIContext, decision: AIDecision, actionTaken?: number, gameId?: string): Promise<void> {\n    if (!this.isTraining) {\n      return;\n    }\n\n    // Get current observation\n    const observation = this.env.getObservation(context);\n\n    // Use gameId to track state per game (default to \"default\" if not provided for backward compatibility)\n    const gameKey = gameId || 'default';\n    \n    // Get or initialize state for this specific game\n    let envState = this.gameStates.get(gameKey);\n    \n    // If this is the first step or state is invalid, reset environment for this game\n    if (!envState || !envState.observation) {\n      envState = this.env.reset(context);\n      this.gameStates.set(gameKey, envState);\n      // Mark this game as having an active episode\n      this.activeGameEpisodes.add(gameKey);\n      // Initialize episode reward and length for this game (reset from previous episode)\n      this.gameEpisodeRewards.set(gameKey, 0);\n      this.gameEpisodeLengths.set(gameKey, 0);\n      // Update shared stats to include this newly active game\n      this.updateSharedStats();\n      return;\n    }\n\n    // Use provided action or select new one\n    let action: number = 0; // Default to action 0 (no-op)\n    if (actionTaken !== undefined && actionTaken !== null) {\n      action = actionTaken;\n    } else {\n      // Select action using epsilon-greedy\n      action = await this.agent.selectAction(envState.observation, true);\n    }\n\n    // Execute action and get next state\n    const nextEnvState = this.env.step(action, context, decision);\n\n    // Ensure we have valid state before storing step\n    if (!envState || !envState.observation || !nextEnvState || !nextEnvState.observation) {\n      // Skip step collection if state is invalid, reset for this game\n      this.gameStates.set(gameKey, nextEnvState || this.env.reset(context));\n      return;\n    }\n\n    // Store step from previous state to current state\n    // All games contribute to the SAME shared replay buffer\n    const step: Step = {\n      state: envState.observation.vector,\n      action: action,\n      reward: nextEnvState.reward,\n      nextState: nextEnvState.observation.vector,\n      done: nextEnvState.done,\n    };\n\n    // Add to shared replay buffer (all games contribute here)\n    this.replayBuffer.add(step);\n    \n    // Track reward and length per game (for proper episode tracking)\n    const currentGameReward = this.gameEpisodeRewards.get(gameKey) || 0;\n    const currentGameLength = this.gameEpisodeLengths.get(gameKey) || 0;\n    this.gameEpisodeRewards.set(gameKey, currentGameReward + nextEnvState.reward);\n    this.gameEpisodeLengths.set(gameKey, currentGameLength + 1);\n    \n    // Update shared stats for display (sum of all active games)\n    this.updateSharedStats();\n    \n    // Debug: Log every 100 steps to verify accumulation\n    if (this.stats.episodeLength % 100 === 0) {\n    }\n\n    // Train periodically on shared model\n    // All games' steps are batched together for training\n    this.stepCount++;\n    if (this.stepCount % this.config.trainEvery === 0 && this.replayBuffer.canSample(32)) {\n      const batch = this.replayBuffer.sample(32); // Sample from ALL games' steps\n      const loss = await this.agent.train(batch); // Train shared model\n      this.stats.loss = loss;\n      \n      // Mark that training has occurred (even if loss is 0, training ran)\n      // This ensures we only save models that have actually been trained\n      this.hasTrainedAtLeastOnce = true;\n\n      if (this.config.onTrainingUpdate) {\n        this.config.onTrainingUpdate({\n          loss,\n          epsilon: this.agent.getEpsilon(),\n        });\n      }\n    }\n\n    // Check if episode is done for this specific game\n    if (nextEnvState.done) {\n      await this.onEpisodeComplete(nextEnvState, gameKey);\n      // Reset state for this game only (other games unaffected)\n      this.gameStates.delete(gameKey);\n      // Note: Don't remove from activeGameEpisodes here - it will be re-added when the game restarts\n      // This prevents the brief window where all games might be \"inactive\" causing premature reset\n      // Note: We also don't clear gameEpisodeRewards/gameEpisodeLengths here - they'll be reset\n      // when the game restarts and step() is called with a fresh state\n    } else {\n      // Update state for this specific game\n      this.gameStates.set(gameKey, nextEnvState);\n    }\n  }\n\n  /**\n   * Update shared stats from per-game rewards and lengths\n   * This sums all active game rewards/lengths for display\n   */\n  private updateSharedStats(): void {\n    let totalReward = 0;\n    let totalLength = 0;\n    \n    for (const [gameKey, reward] of this.gameEpisodeRewards.entries()) {\n      if (this.activeGameEpisodes.has(gameKey)) {\n        totalReward += reward;\n      }\n    }\n    \n    for (const [gameKey, length] of this.gameEpisodeLengths.entries()) {\n      if (this.activeGameEpisodes.has(gameKey)) {\n        totalLength += length;\n      }\n    }\n    \n    this.stats.episodeReward = totalReward;\n    this.stats.episodeLength = totalLength;\n  }\n\n  /**\n   * Increment episode count (called when a new game starts)\n   * This is shared across all 4 games running in parallel\n   * Each game that starts increments the shared counter by 1\n   * \n   * Note: The reward from the completed episode should have already been\n   * added to totalReward in onEpisodeComplete(). This just increments the counter.\n   */\n  incrementEpisode(): void {\n    // Increment episode count\n    this.currentEpisode++;\n    this.stats.episode = this.currentEpisode;\n    this.stats.epsilon = this.agent.getEpsilon();\n    \n    // Update average reward using completed episodes (not currentEpisode which includes in-progress games)\n    // This ensures averageReward reflects only completed games\n    if (this.completedEpisodes > 0) {\n      this.stats.averageReward = this.stats.totalReward / this.completedEpisodes;\n    }\n    \n    // Save model periodically\n    if (this.currentEpisode % this.config.saveEvery === 0) {\n      // Save asynchronously without blocking\n      const timestamp = Date.now();\n      const isoString = new Date(timestamp).toISOString();\n      const evalScore = this.stats.averageReward;\n      this.saveModel(`indexeddb://tank-ai-${timestamp}`, evalScore, isoString).catch((error) => {\n        console.error('Error saving model:', error);\n      });\n    }\n    \n    // Callback to notify listeners\n    if (this.config.onEpisodeComplete) {\n      this.config.onEpisodeComplete({ ...this.stats });\n    }\n  }\n\n  /**\n   * Handle episode completion (simplified - no longer increments episode count)\n   * Episode count is now incremented when a new game starts, not when it ends\n   * \n   * This method adds the completed game's reward to totalReward and cleans up\n   * per-game tracking. The episode counter is incremented separately when\n   * the new game starts.\n   */\n  private async onEpisodeComplete(finalState: RLEnvironmentState, gameKey: string): Promise<void> {\n    // Get the base game key (without \"-blue\" suffix) to combine both tanks' rewards\n    const isBlueTank = gameKey.includes('-blue');\n    const baseGameKey = isBlueTank ? gameKey.replace('-blue', '') : gameKey;\n    \n    // Get rewards from both tanks for this game (blue and red)\n    const redReward = this.gameEpisodeRewards.get(baseGameKey) || 0;\n    const blueReward = this.gameEpisodeRewards.get(`${baseGameKey}-blue`) || 0;\n    const totalGameReward = redReward + blueReward;\n    \n    // Get lengths from both tanks\n    const redLength = this.gameEpisodeLengths.get(baseGameKey) || 0;\n    const blueLength = this.gameEpisodeLengths.get(`${baseGameKey}-blue`) || 0;\n    const totalGameLength = redLength + blueLength;\n    \n    // Add this game's total reward to totalReward (only count once per game, not per tank)\n    // In AI vs AI mode, both tanks call this, but we only want to count once\n    if (!isBlueTank) {\n      this.stats.totalReward += totalGameReward;\n      this.completedEpisodes++;\n      \n      // Update average reward immediately when episode completes\n      // Use completedEpisodes for accurate average (not currentEpisode which includes in-progress games)\n      if (this.completedEpisodes > 0) {\n        this.stats.averageReward = this.stats.totalReward / this.completedEpisodes;\n      }\n    }\n    \n    // Clean up per-game tracking for this game when episode completes\n    // We'll reset these when the game restarts and step() is called with fresh state\n    // Note: We mark as inactive so it doesn't contribute to shared stats\n    this.activeGameEpisodes.delete(baseGameKey);\n    this.activeGameEpisodes.delete(`${baseGameKey}-blue`); // Also remove blue variant if it exists\n    \n    // Update shared stats (will exclude this completed game)\n    this.updateSharedStats();\n  }\n\n  /**\n   * Start training\n   */\n  start(): void {\n    if (!this.isTraining) {\n      this.isTraining = true;\n      this.currentEpisode = 0;\n      this.completedEpisodes = 0;\n      this.stepCount = 0;\n      // Reset episode stats when training starts\n      this.stats.episodeReward = 0;\n      this.stats.episodeLength = 0;\n      this.stats.totalReward = 0;\n      this.stats.averageReward = 0;\n      this.activeGameEpisodes.clear();\n      this.gameEpisodeRewards.clear();\n      this.gameEpisodeLengths.clear();\n    }\n  }\n\n  /**\n   * Stop training\n   */\n  stop(): void {\n    this.isTraining = false;\n  }\n\n  /**\n   * Check if training is active\n   */\n  getIsTraining(): boolean {\n    return this.isTraining;\n  }\n\n  /**\n   * Get current training statistics\n   */\n  getStats(): TrainingStats {\n    return { ...this.stats };\n  }\n\n  /**\n   * Check if model can be saved\n   * Requirements:\n   * 1. Replay buffer has enough steps (32+) for at least one training batch\n   * 2. At least one episode has completed (to have meaningful averageReward)\n   * 3. Training has actually occurred at least once (hasTrainedAtLeastOnce)\n   * \n   * Note: We require hasTrainedAtLeastOnce instead of loss > 0 because:\n   * - Loss might be 0 even after training (if there was an error or loss extraction failed)\n   * - But if training ran, the model weights have been updated, making it worth saving\n   * - This ensures we only save models that have actually been trained, not just initialized\n   */\n  canSaveModel(): boolean {\n    const hasEnoughData = this.replayBuffer.canSample(32);\n    const hasCompletedEpisode = this.currentEpisode > 0; // Need at least one episode for meaningful stats\n    // Require that training has actually occurred (model weights have been updated)\n    return hasEnoughData && hasCompletedEpisode && this.hasTrainedAtLeastOnce;\n  }\n\n  /**\n   * Get replay buffer size\n   */\n  getReplayBufferSize(): number {\n    return this.replayBuffer.size();\n  }\n\n  /**\n   * Save model\n   */\n  async saveModel(path: string, evalScore?: number, displayName?: string): Promise<void> {\n    // Ensure path has indexeddb:// prefix for IndexedDB storage\n    // If path already has the prefix, use it as-is; otherwise add it\n    const fullPath = path.startsWith('indexeddb://') ? path : `indexeddb://${path}`;\n    \n    if (!this.agent) {\n      throw new Error('Agent not initialized. Cannot save model.');\n    }\n    \n    // CRITICAL: Save model weights FIRST and verify they were saved\n    // Only save metadata AFTER we confirm the weights are in IndexedDB\n    // This prevents orphaned metadata entries\n    try {\n      await this.agent.save(fullPath);\n      // agent.save() now includes verification - if it returns, weights are saved\n    } catch (error) {\n      console.error('RLTrainingManager: Model weights save/verification failed:', error);\n      throw new Error(`Failed to save model weights: ${error instanceof Error ? error.message : String(error)}`);\n    }\n    \n    // Only save metadata if weights were successfully saved and verified\n    try {\n      await saveModelWithMetadata(fullPath, evalScore, displayName);\n    } catch (metaError) {\n      // If metadata save fails, log but don't throw - weights are already saved\n      console.warn('RLTrainingManager: Failed to save model metadata (weights are saved):', metaError);\n      // Don't throw - metadata is optional, weights are the important part\n    }\n  }\n\n  /**\n   * Load model\n   */\n  async loadModel(path: string): Promise<void> {\n    await this.agent.load(`indexeddb://${path}`);\n  }\n\n  /**\n   * Reset environment for new episode\n   */\n  resetEpisode(context: AIContext, gameId?: string): void {\n    const gameKey = gameId || 'default';\n    const newState = this.env.reset(context);\n    this.gameStates.set(gameKey, newState);\n  }\n\n  /**\n   * Get max episode time in milliseconds\n   */\n  getMaxEpisodeTimeMs(): number {\n    return this.config.maxEpisodeTimeMs;\n  }\n\n  /**\n   * Dispose resources\n   */\n  dispose(): void {\n    this.stop();\n    this.agent.dispose();\n    this.replayBuffer.clear();\n  }\n}\n\n","/**\n * React Hook for RL Training\n * \n * Provides a hook interface for training that can be used in React components.\n */\n\nimport { useEffect, useRef, useState } from 'react';\nimport { RLTrainingManager, type TrainingStats, type TrainingConfig } from './rl-training-manager';\nimport type { AIContext } from './types';\nimport type { AIDecision } from './types';\nimport { isKeyOf } from '@/lib/type-guards';\n\nexport function useRLTraining(config: Partial<TrainingConfig> = {}) {\n  const [isTraining, setIsTraining] = useState(false);\n  const [stats, setStats] = useState<TrainingStats | null>(null);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const managerRef = useRef<RLTrainingManager | null>(null);\n  const configRef = useRef(config);\n  \n  // Keep config ref up to date\n  useEffect(() => {\n    configRef.current = config;\n  }, [config]);\n\n  // Memoize callbacks to prevent recreation\n  const onEpisodeCompleteRef = useRef(config.onEpisodeComplete);\n  const onTrainingUpdateRef = useRef(config.onTrainingUpdate);\n  \n  useEffect(() => {\n    onEpisodeCompleteRef.current = config.onEpisodeComplete;\n    onTrainingUpdateRef.current = config.onTrainingUpdate;\n  }, [config.onEpisodeComplete, config.onTrainingUpdate]);\n\n  useEffect(() => {\n    const manager = new RLTrainingManager({\n      ...configRef.current,\n      onEpisodeComplete: (episodeStats) => {\n        setStats((prev) => {\n          // Preserve loss value from previous stats if it exists and is non-zero\n          // This prevents loss from being reset to 0 when episodes complete\n          const preservedLoss = (prev?.loss ?? 0) > 0 ? (prev?.loss ?? 0) : episodeStats.loss;\n          return { ...episodeStats, loss: preservedLoss };\n        });\n        if (onEpisodeCompleteRef.current) {\n          onEpisodeCompleteRef.current(episodeStats);\n        }\n      },\n      onTrainingUpdate: (updateStats) => {\n        setStats((prev) => {\n          // Type guard to check if key is valid TrainingStats key\n          const isValidTrainingStatsKey = (key: string): key is keyof TrainingStats => {\n            const validKeys: readonly (keyof TrainingStats)[] = [\n              'episode',\n              'episodeReward',\n              'episodeLength',\n              'totalReward',\n              'averageReward',\n              'epsilon',\n              'loss',\n            ];\n            return typeof key === 'string' && validKeys.includes(key as keyof TrainingStats);\n          };\n          \n          // Filter out undefined values to prevent overwriting with undefined\n          const definedUpdates: Partial<TrainingStats> = {};\n          for (const [key, value] of Object.entries(updateStats)) {\n            if (value !== undefined && isValidTrainingStatsKey(key)) {\n              definedUpdates[key] = value;\n            }\n          }\n          \n          // If prev is null, initialize with default values and merge defined updates\n          if (!prev) {\n            const defaultStats: TrainingStats = {\n              episode: 0,\n              episodeReward: 0,\n              episodeLength: 0,\n              totalReward: 0,\n              averageReward: 0,\n              epsilon: 1.0,\n              loss: 0,\n            };\n            return { ...defaultStats, ...definedUpdates };\n          }\n          // Only update if values actually changed to prevent infinite loops\n          const hasChanges = Object.keys(definedUpdates).some(\n            (key) => {\n              if (isValidTrainingStatsKey(key)) {\n                return prev[key] !== definedUpdates[key];\n              }\n              return false;\n            }\n          );\n          return hasChanges ? { ...prev, ...definedUpdates } : prev;\n        });\n        if (onTrainingUpdateRef.current) {\n          onTrainingUpdateRef.current(updateStats);\n        }\n      },\n    });\n\n    manager.initialize().then(() => {\n      setIsInitialized(true);\n      managerRef.current = manager;\n      // Initialize stats with current manager stats to ensure all fields are present\n      const initialStats = manager.getStats();\n      setStats(initialStats);\n    });\n\n    return () => {\n      if (managerRef.current) {\n        managerRef.current.dispose();\n      }\n    };\n  }, []);\n\n  const startTraining = () => {\n    if (managerRef.current && isInitialized) {\n      managerRef.current.start();\n      setIsTraining(true);\n    }\n  };\n\n  const stopTraining = () => {\n    if (managerRef.current) {\n      managerRef.current.stop();\n      setIsTraining(false);\n    }\n  };\n\n  const step = async (context: AIContext, decision: AIDecision, actionTaken?: number) => {\n    if (managerRef.current && isTraining) {\n      await managerRef.current.step(context, decision, actionTaken);\n    }\n  };\n\n  const saveModel = async (name: string, evalScore?: number, displayName?: string) => {\n    if (managerRef.current) {\n      await managerRef.current.saveModel(name, evalScore, displayName);\n    }\n  };\n\n  const loadModel = async (name: string) => {\n    if (managerRef.current) {\n      await managerRef.current.loadModel(name);\n    }\n  };\n\n  const resetEpisode = (context: AIContext) => {\n    if (managerRef.current) {\n      managerRef.current.resetEpisode(context);\n    }\n  };\n\n  const incrementEpisode = () => {\n    if (managerRef.current) {\n      managerRef.current.incrementEpisode();\n    }\n  };\n\n  const canSaveModel = () => {\n    return managerRef.current ? managerRef.current.canSaveModel() : false;\n  };\n\n  const getReplayBufferSize = () => {\n    return managerRef.current ? managerRef.current.getReplayBufferSize() : 0;\n  };\n\n  return {\n    isTraining,\n    isInitialized,\n    stats,\n    startTraining,\n    stopTraining,\n    step,\n    saveModel,\n    loadModel,\n    resetEpisode,\n    incrementEpisode,\n    canSaveModel,\n    getReplayBufferSize,\n    get manager() {\n      return managerRef.current;\n    },\n  };\n}\n\n","'use client';\n\nimport React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';\nimport mapDataJson from '@/shared/content/games/tank-trouble-map.json';\nimport type { Tank, Bullet, TankTroubleMapData, Barrier, Sun } from '@/app/games/tank-trouble/types';\nimport {\n  isObject,\n  isNumber,\n  isArray,\n  hasPropertyOfType,\n  parseAndValidate,\n} from '@/lib/type-guards';\n\n// Type guard for TankTroubleMapData\nfunction isTankTroubleMapData(data: unknown): data is TankTroubleMapData {\n  if (!isObject(data)) {\n    return false;\n  }\n  \n  return (\n    hasPropertyOfType(data, 'width', isNumber) &&\n    hasPropertyOfType(data, 'height', isNumber) &&\n    hasPropertyOfType(data, 'barriers', (val): val is Barrier[] => isArray(val)) &&\n    hasPropertyOfType(data, 'spawnPoints', (val): val is Array<{ x: number; y: number; angle: number }> => isArray(val)) &&\n    (!('suns' in data) || hasPropertyOfType(data, 'suns', (val): val is Sun[] => isArray(val)))\n  );\n}\n\n// Validate and construct map data without type assertions\nfunction validateMapData(data: unknown): TankTroubleMapData {\n  const parsed = parseAndValidate(\n    data,\n    isTankTroubleMapData,\n    'Invalid map data structure: missing or invalid required properties'\n  );\n  \n  return {\n    width: parsed.width,\n    height: parsed.height,\n    barriers: parsed.barriers,\n    spawnPoints: parsed.spawnPoints,\n    suns: parsed.suns || [],\n  };\n}\n\nconst mapData: TankTroubleMapData = validateMapData(mapDataJson);\n\nimport { useGameInput } from '@/app/games/tank-trouble/hooks/useGameInput';\nimport { useTankImages } from '@/app/games/tank-trouble/hooks/useTankImages';\nimport { useMultiGameLogic, type GameInstance as GameLogicInstance } from '@/app/games/tank-trouble/components/GameLogic';\nimport { GameCanvas } from '@/app/games/tank-trouble/components/GameCanvas';\nimport { getInitialSpawnPositions } from '@/app/games/tank-trouble/utils/spawn';\nimport { DEFAULT_AI_CONFIG, type AIConfig, rlModelManager } from '@/app/games/tank-trouble/ai-tank';\nimport { DQNAgent, DEFAULT_DQN_CONFIG } from '@/app/games/tank-trouble/ai-tank/rl-dqn-model';\nimport { TensorFlowJSModel, type ExtendedRLModel } from '@/app/games/tank-trouble/ai-tank/rl-model';\nimport type { AIDecision } from '@/app/games/tank-trouble/ai-tank/types';\nimport { extractObservation, type Observation } from '@/app/games/tank-trouble/ai-tank/rl-observation';\nimport { keysToAction } from '@/app/games/tank-trouble/ai-tank/rl-actions';\n// import { listSavedModels, type SavedModel } from '@/app/games/tank-trouble/ai-tank/rl-model-storage'; // Commented out - using Supabase instead\nimport { TICK_INTERVAL } from '@/app/games/tank-trouble/config';\n\ninterface PlayYourAIProps {\n  onBack: () => void;\n}\n\nexport function PlayYourAI({ onBack }: PlayYourAIProps) {\n  const typedMapData = mapData;\n  const barriers = typedMapData.barriers || [];\n  const suns: Sun[] = []; // Suns removed from map - always use empty array\n  const aiConfig = DEFAULT_AI_CONFIG;\n\n  // Model loading from Supabase\n  const [isLoadingModel, setIsLoadingModel] = useState(false);\n  const [isModelLoaded, setIsModelLoaded] = useState(false);\n  const [modelError, setModelError] = useState<string | null>(null);\n  const [dqnAgent, setDqnAgent] = useState<DQNAgent | null>(null);\n\n  // Game state\n  const [tanks, setTanks] = useState<Tank[]>(() => {\n    const initialTanks = getInitialSpawnPositions(typedMapData, barriers, suns);\n    return initialTanks;\n  });\n  const [bullets, setBullets] = useState<Bullet[]>([]);\n  const [lastShotTimes, setLastShotTimes] = useState<{ blue: number; red: number }>({ blue: 0, red: 0 });\n  const [gameOverWinner, setGameOverWinner] = useState<'blue' | 'red' | null>(null);\n  const [isPaused, setIsPaused] = useState(false);\n\n  // Demonstration collection state\n  const [demonstrationSteps, setDemonstrationSteps] = useState<Array<{\n    state: number[];\n    action: number;\n    reward: number;\n    nextState: number[];\n    done: boolean;\n  }>>([]);\n  const [previousObservation, setPreviousObservation] = useState<Observation | null>(null);\n  const [previousAction, setPreviousAction] = useState<number | null>(null); // Capture action that was actually taken\n  const [isSavingDemonstrations, setIsSavingDemonstrations] = useState(false);\n  const [demonstrationSaveStatus, setDemonstrationSaveStatus] = useState<string | null>(null);\n\n  const tankImages = useTankImages();\n  const gameInput = useGameInput({ gameOver: gameOverWinner !== null });\n\n  // Load latest model from Supabase\n  const loadLatestModelFromSupabase = useCallback(async () => {\n    setIsLoadingModel(true);\n    setModelError(null);\n    setIsModelLoaded(false);\n\n    try {\n      // Initialize DQN agent if not already done\n      let agentToUse = dqnAgent;\n      if (!agentToUse) {\n        const agent = new DQNAgent(DEFAULT_DQN_CONFIG);\n        await agent.initialize();\n        setDqnAgent(agent);\n        agentToUse = agent;\n        \n        // Set up model for game controller\n        const model = new TensorFlowJSModel({\n          name: 'TankTroubleRL',\n          type: 'discrete',\n          observationSize: DEFAULT_DQN_CONFIG.observationSize,\n          actionSize: DEFAULT_DQN_CONFIG.actionSize,\n        });\n        \n        const extendedModel: ExtendedRLModel = {\n          isLoaded: () => {\n            // Agent is initialized after initialize() is called above\n            return true;\n          },\n          load: async (path: string) => {\n            // This is a placeholder - we load weights directly from Supabase\n            // The path parameter is not used when loading from Supabase\n            if (agentToUse) {\n              await agentToUse.load(path);\n            }\n          },\n          getInfo: () => model.getInfo(),\n          agent: agentToUse,\n          predict: async (obs, angle) => {\n            // Now async! This allows us to properly call the agent's async predict method\n            if (!agentToUse) {\n              console.warn('Agent not initialized, returning default decision');\n              return {\n                angleDelta: 0,\n                moveDirection: 0,\n                shouldShoot: false,\n              };\n            }\n            \n            try {\n              // Call the agent's async predict method\n              const decision = await agentToUse.predict(obs, angle);\n              return decision;\n            } catch (error) {\n              console.error('Error in agent predict:', error);\n              return {\n                angleDelta: 0,\n                moveDirection: 0,\n                shouldShoot: false,\n              };\n            }\n          },\n        };\n        \n        rlModelManager.setModel(extendedModel);\n      }\n\n      // Ensure we have an agent at this point\n      if (!agentToUse) {\n        throw new Error('Failed to initialize DQN agent');\n      }\n\n      // Fetch latest model from API\n      const response = await fetch('/api/backend/models/latest');\n      \n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));\n        throw new Error(errorData.error || `Failed to fetch model: ${response.statusText}`);\n      }\n\n      const modelData = await response.json();\n      \n      // Log model data structure for debugging\n      console.log('Model data received from Supabase:', {\n        layersCount: modelData.layers?.length || 0,\n        hasMetadata: !!modelData.metadata,\n        metadata: modelData.metadata,\n      });\n      \n      // Convert Supabase format to TensorFlow.js format\n      // Supabase format: { layers: [{ weights: number[], biases: number[] }, ...], metadata: {...} }\n      // We need: Array<{ weights: number[], biases: number[] }>\n      const weightsData = modelData.layers.map((layer: any, index: number) => {\n        const weights = layer.weights || layer.Weights || [];\n        const biases = layer.biases || layer.Biases || [];\n        \n        // Log layer info and verify non-zero values\n        const nonZeroWeights = weights.filter((w: number) => Math.abs(w) > 1e-10).length;\n        const nonZeroBiases = biases.filter((b: number) => Math.abs(b) > 1e-10).length;\n        const totalWeights = weights.length;\n        const totalBiases = biases.length;\n        const weightSample = weights.slice(0, 10); // First 10 weights\n        const biasSample = biases.slice(0, 5); // First 5 biases\n        \n        console.log(`Layer ${index}:`, {\n          weightsCount: totalWeights,\n          biasesCount: totalBiases,\n          nonZeroWeights,\n          nonZeroBiases,\n          weightSample,\n          biasSample,\n          allZeros: nonZeroWeights === 0 && nonZeroBiases === 0,\n        });\n        \n        return { weights, biases };\n      });\n\n      // Load weights into the agent\n      await agentToUse.loadWeightsFromJSON(weightsData);\n      \n      // Verify loaded weights by checking a sample prediction\n      // Create a test observation with proper structure\n      const testObs = {\n        vector: new Array(DEFAULT_DQN_CONFIG.observationSize).fill(0.5),\n        size: DEFAULT_DQN_CONFIG.observationSize,\n      };\n      try {\n        const testAction = await agentToUse.selectAction(testObs, false);\n        console.log('Model verification - test action:', testAction, '(should be 0-', DEFAULT_DQN_CONFIG.actionSize - 1, ')');\n        \n        // Also test a full prediction\n        const testDecision = await agentToUse.predict(testObs, 0);\n        console.log('Model verification - test decision:', testDecision);\n      } catch (err) {\n        console.error('Model verification failed:', err);\n      }\n      \n      setIsModelLoaded(true);\n      console.log('Successfully loaded latest model from Supabase', modelData.metadata);\n    } catch (error) {\n      console.error('Failed to load model from Supabase:', error);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      setModelError(errorMessage);\n      setIsModelLoaded(false);\n    } finally {\n      setIsLoadingModel(false);\n    }\n  }, [dqnAgent]);\n\n  // Auto-load latest model on mount\n  useEffect(() => {\n    loadLatestModelFromSupabase();\n  }, [loadLatestModelFromSupabase]);\n\n  // Save demonstrations to backend\n  const saveDemonstrations = useCallback(async () => {\n    if (demonstrationSteps.length === 0) {\n      return;\n    }\n\n    setIsSavingDemonstrations(true);\n    setDemonstrationSaveStatus(null);\n\n    try {\n      const response = await fetch('http://localhost:8080/api/demonstrations', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          steps: demonstrationSteps,\n          isDefault: true,\n          metadata: {\n            episodeLength: demonstrationSteps.length,\n            totalReward: 0, // Not calculated for human demonstrations\n            timestamp: new Date().toISOString(),\n          },\n        }),\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`Failed to save: ${response.status} ${errorText}`);\n      }\n\n      const result = await response.json();\n      setDemonstrationSaveStatus(`✅ Saved ${result.steps} demonstration steps`);\n      \n      // Clear demonstrations after successful save\n      setDemonstrationSteps([]);\n      setPreviousObservation(null);\n      setPreviousAction(null);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      setDemonstrationSaveStatus(`❌ Failed to save: ${errorMessage}`);\n      console.error('Failed to save demonstrations:', error);\n    } finally {\n      setIsSavingDemonstrations(false);\n    }\n  }, [demonstrationSteps]);\n\n  // Reset game\n  const resetGame = useCallback(() => {\n    // Save demonstrations before resetting if game ended\n    if (gameOverWinner !== null && demonstrationSteps.length > 0) {\n      saveDemonstrations();\n    }\n\n    const initialTanks = getInitialSpawnPositions(typedMapData, barriers, suns);\n    setTanks(initialTanks);\n    setBullets([]);\n    setLastShotTimes({ blue: 0, red: 0 });\n    setGameOverWinner(null);\n    setIsPaused(false);\n    // Reset demonstration state\n    setPreviousObservation(null);\n    setPreviousAction(null);\n    // Don't reset demonstrationSteps here - let saveDemonstrations clear them\n  }, [typedMapData, barriers, suns, gameOverWinner, demonstrationSteps, saveDemonstrations]);\n\n  // Game logic instance\n  const gameLogicInstance: GameLogicInstance = useMemo(() => ({\n    id: 0,\n    tanks,\n    bullets,\n    lastShotTimes,\n    gameMode: 'person-vs-ai',\n    gameId: 'play-ai-game',\n    isPaused,\n    speedMultiplier: 1,\n    episodeStartTime: Date.now(),\n    keysRef: gameInput.keysRef,\n  }), [tanks, bullets, lastShotTimes, isPaused, gameInput.keysRef]);\n\n  // No timeout in PlayYourAI mode - games can run indefinitely since we're not training\n  const maxEpisodeTimeMs = Number.MAX_SAFE_INTEGER;\n\n  const gameLogic = useMultiGameLogic({\n    mapData: typedMapData,\n    barriers,\n    suns,\n    aiConfig,\n    trainingManager: null, // No training in play mode\n    maxEpisodeTimeMs,\n    gameInstances: [gameLogicInstance],\n    onTanksUpdate: (gameId, updatedTanks) => {\n      setTanks(updatedTanks);\n      \n      // Check for game over\n      if (updatedTanks[0]?.lives <= 0 || updatedTanks[1]?.lives <= 0) {\n        const winner = updatedTanks[0]?.lives <= 0 ? 'red' : 'blue';\n        setGameOverWinner(winner);\n      }\n    },\n    onBulletsUpdate: (gameId, updatedBullets) => {\n      setBullets(updatedBullets);\n    },\n    onLastShotTimesUpdate: (gameId, times) => {\n      setLastShotTimes(times);\n    },\n    onGameOver: (gameId, winner) => {\n      setGameOverWinner(winner);\n    },\n  });\n\n  // Collect demonstration steps during gameplay\n  // IMPORTANT: We need to capture the action that was actually taken, not current keyboard state\n  // Flow: BEFORE tick -> capture state + action, AFTER tick -> capture nextState\n  useEffect(() => {\n    if (isPaused || !isModelLoaded || gameOverWinner !== null || tanks.length < 2) {\n      return;\n    }\n\n    // Extract observation from blue tank's perspective (human player)\n    const blueTank = tanks[0];\n    const redTank = tanks[1];\n\n    if (!blueTank || !redTank) {\n      return;\n    }\n\n    // Create AIContext from blue tank's perspective\n    const context = {\n      aiTank: blueTank,      // Blue tank is \"AI\" from its perspective\n      enemyTank: redTank,    // Red tank is \"enemy\"\n      bullets: bullets,\n      barriers: barriers,\n      suns: suns,\n      mapWidth: typedMapData.width,\n      mapHeight: typedMapData.height,\n      tickTime: Date.now(),\n      config: DEFAULT_AI_CONFIG,\n    };\n\n    const currentObservation = extractObservation(context);\n\n    // If we have a previous observation AND previous action, we can create a step\n    // This means an action was taken that transitioned from previousObservation to currentObservation\n    if (previousObservation && previousAction !== null) {\n      // Check if game ended (this tick)\n      const done = blueTank.lives <= 0 || redTank.lives <= 0;\n\n      // Create step with reward (0.1 for imitation learning - encourages following expert)\n      // Note: We store observations (normalized feature vectors) which contain all game state information\n      // State = observation before action was applied\n      // Action = action that was actually applied (captured before previous tick)\n      // NextState = observation after action was applied\n      const step = {\n        state: previousObservation.vector,     // Game state (observation) BEFORE action\n        action: previousAction,                 // Action that was applied\n        reward: 0.1,                            // Small positive reward for imitation learning\n        nextState: currentObservation.vector,  // Game state (observation) AFTER action\n        done: done,\n      };\n\n      setDemonstrationSteps((prev) => [...prev, step]);\n    }\n\n    // Capture the action that corresponds to current keyboard state\n    // This action will be applied in the next game tick\n    // Note: Since ticks are frequent (72 FPS = ~14ms) and keys don't change rapidly,\n    // the action we capture here is very close to what was applied during the previous tick\n    const nextAction = keysToAction(gameInput.keysRef.current);\n\n    // Update for next iteration\n    // previousObservation becomes the \"state\" for the next step\n    // previousAction becomes the \"action\" that was applied (or will be applied)\n    setPreviousObservation(currentObservation);\n    setPreviousAction(nextAction);\n  }, [tanks, bullets, barriers, suns, gameInput.keysRef, isPaused, isModelLoaded, gameOverWinner, previousObservation, previousAction, typedMapData]);\n\n  // Save demonstrations when game ends\n  useEffect(() => {\n    if (gameOverWinner !== null && demonstrationSteps.length > 0 && !isSavingDemonstrations) {\n      saveDemonstrations();\n    }\n  }, [gameOverWinner, demonstrationSteps.length, isSavingDemonstrations, saveDemonstrations]);\n\n  // Game loop\n  useEffect(() => {\n    if (isPaused || !isModelLoaded || gameOverWinner !== null) {\n      return;\n    }\n\n    let lastTickTime = Date.now();\n    const gameLoop = async () => {\n      const now = Date.now();\n      if (now - lastTickTime >= TICK_INTERVAL) {\n        await gameLogic.gameTick({ skipIntervalCheck: false });\n        lastTickTime = now;\n      }\n      requestAnimationFrame(gameLoop);\n    };\n\n    const frameId = requestAnimationFrame(gameLoop);\n    return () => cancelAnimationFrame(frameId);\n  }, [isPaused, isModelLoaded, gameOverWinner, gameLogic]);\n\n  // Handle pause\n  useEffect(() => {\n    const handleKeyPress = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        setIsPaused(prev => !prev);\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyPress);\n    return () => window.removeEventListener('keydown', handleKeyPress);\n  }, []);\n\n  const scale = 1.0; // Full size for play mode\n\n  return (\n    <div className=\"flex flex-col items-center gap-4 w-full p-4\">\n      {/* Header */}\n      <div className=\"w-full max-w-4xl flex items-center justify-between\">\n        <h1 className=\"text-2xl font-bold\">Play Your AI</h1>\n        <button\n          onClick={onBack}\n          className=\"px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300\"\n        >\n          Back to Training\n        </button>\n      </div>\n\n      {/* Model Loading Status */}\n      <div className=\"w-full max-w-4xl p-4 bg-white border border-gray-300 rounded shadow\">\n        <div className=\"flex items-center gap-4\">\n          <label className=\"text-sm font-semibold\">AI Model:</label>\n          {isLoadingModel ? (\n            <span className=\"text-sm text-gray-600\">Loading latest model from Supabase...</span>\n          ) : isModelLoaded ? (\n            <span className=\"text-sm text-green-600\">✓ Latest model loaded from Supabase</span>\n          ) : modelError ? (\n            <div className=\"flex flex-col gap-1\">\n              <span className=\"text-sm text-red-600\">✗ Failed to load model</span>\n              <span className=\"text-xs text-gray-500\">{modelError}</span>\n              <button\n                onClick={loadLatestModelFromSupabase}\n                className=\"mt-2 px-3 py-1 text-xs bg-blue-500 text-white rounded hover:bg-blue-600\"\n              >\n                Retry\n              </button>\n            </div>\n          ) : (\n            <span className=\"text-sm text-gray-600\">Ready to load</span>\n          )}\n        </div>\n        \n        {/* Demonstration Collection Status */}\n        <div className=\"mt-3 pt-3 border-t border-gray-200\">\n          <div className=\"flex items-center gap-4\">\n            <label className=\"text-sm font-semibold\">Demonstration Collection:</label>\n            {demonstrationSteps.length > 0 ? (\n              <span className=\"text-sm text-blue-600\">\n                📝 {demonstrationSteps.length} steps collected\n              </span>\n            ) : (\n              <span className=\"text-sm text-gray-500\">Not collecting</span>\n            )}\n            {isSavingDemonstrations && (\n              <span className=\"text-sm text-gray-600\">Saving...</span>\n            )}\n            {demonstrationSaveStatus && (\n              <span className={`text-sm ${demonstrationSaveStatus.startsWith('✅') ? 'text-green-600' : 'text-red-600'}`}>\n                {demonstrationSaveStatus}\n              </span>\n            )}\n          </div>\n        </div>\n        {/* Commented out: IndexedDB model selection\n        <div className=\"flex items-center gap-4\">\n          <label className=\"text-sm font-semibold\">Select AI Model:</label>\n          <select\n            value={selectedModel}\n            onChange={(e) => setSelectedModel(e.target.value)}\n            className=\"px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500\"\n            disabled={isLoadingModels}\n          >\n            <option value=\"\">{isLoadingModels ? 'Loading models...' : '-- Select a model --'}</option>\n            {savedModels.map((model) => (\n              <option key={model.path} value={model.path}>\n                {model.createdAtString}{model.evalScore !== undefined ? ` (Eval: ${model.evalScore.toFixed(2)})` : ''}\n              </option>\n            ))}\n          </select>\n          {isModelLoaded && (\n            <span className=\"text-sm text-green-600\">✓ Model loaded</span>\n          )}\n        </div>\n        */}\n      </div>\n\n      {/* Game Info */}\n      <div className=\"w-full max-w-4xl p-4 bg-white border border-gray-300 rounded shadow\">\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex gap-6\">\n            <div>\n              <span className=\"text-sm text-gray-600\">You (Blue): </span>\n              <span className=\"font-semibold text-blue-600\">{tanks[0]?.lives ?? 0} lives</span>\n            </div>\n            <div>\n              <span className=\"text-sm text-gray-600\">AI (Red): </span>\n              <span className=\"font-semibold text-red-600\">{tanks[1]?.lives ?? 0} lives</span>\n            </div>\n          </div>\n          {isPaused && (\n            <div className=\"text-lg font-semibold text-gray-600\">PAUSED (Press ESC to resume)</div>\n          )}\n          {gameOverWinner && (\n            <div className=\"text-lg font-semibold\">\n              {gameOverWinner === 'blue' ? (\n                <span className=\"text-blue-600\">You Win!</span>\n              ) : (\n                <span className=\"text-red-600\">AI Wins!</span>\n              )}\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Game Canvas */}\n      {isModelLoaded ? (\n        <div className=\"flex justify-center\">\n          <GameCanvas\n            width={typedMapData.width}\n            height={typedMapData.height}\n            tanks={tanks}\n            bullets={bullets}\n            barriers={barriers}\n            suns={suns}\n            isPaused={isPaused}\n            tankImages={tankImages}\n            gameOverWinner={gameOverWinner}\n            scale={scale}\n          />\n        </div>\n      ) : (\n        <div className=\"w-full max-w-4xl p-8 bg-gray-100 border border-gray-300 rounded text-center\">\n          <div className=\"text-lg text-gray-600\">\n            {isLoadingModel ? 'Loading model from Supabase...' : 'Waiting for AI model to load from Supabase'}\n          </div>\n        </div>\n      )}\n\n      {/* Controls */}\n      <div className=\"w-full max-w-4xl p-4 bg-white border border-gray-300 rounded shadow\">\n        <div className=\"text-sm text-gray-600\">\n          <div className=\"font-semibold mb-2\">Controls:</div>\n          <div>Player 1 (Blue - You): Arrow keys to move, Space to shoot</div>\n          <div>Press ESC to pause/resume</div>\n          {gameOverWinner && (\n            <button\n              onClick={resetGame}\n              className=\"mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\"\n            >\n              Play Again\n            </button>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n\n","'use client';\n\nimport { UnifiedTrainingView } from '@/app/games/tank-trouble/components/UnifiedTrainingView';\nimport { PlayYourAI } from '@/app/games/tank-trouble/components/PlayYourAI';\n\ninterface TankTroublePageProps {\n  view: 'training' | 'play';\n  onViewChange: (view: 'training' | 'play') => void;\n}\n\nexport default function TankTroublePage({ view, onViewChange }: TankTroublePageProps) {\n  if (view === 'play') {\n    return <PlayYourAI onBack={() => onViewChange('training')} />;\n  }\n\n  return <UnifiedTrainingView />;\n}\n\n"],"names":[],"mappings":"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"}