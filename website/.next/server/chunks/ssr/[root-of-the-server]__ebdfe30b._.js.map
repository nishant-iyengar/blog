{"version":3,"sources":["../../../../../website/components/Sidebar.tsx/__nextjs-internal-proxy.mjs","../../../../../website/lib/utils.ts","../../../../../node_modules/.pnpm/%40swc%2Bhelpers%400.5.15/node_modules/%40swc/helpers/cjs/_interop_require_default.cjs","../../../../../website/components/SectionLink.tsx/__nextjs-internal-proxy.mjs","../../../../../website/app/photos/page.tsx","../../../../../website/lib/photos.ts","../../../../../website/lib/sections.ts"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/website/components/Sidebar.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/website/components/Sidebar.tsx\",\n    \"default\",\n);\n","/**\n * Converts a string to sentence case (first letter capitalized, rest lowercase)\n */\nexport function toSentenceCase(text: string): string {\n  if (!text) return text;\n  \n  // Trim and convert to lowercase, then capitalize first letter\n  const trimmed = text.trim();\n  if (trimmed.length === 0) return text;\n  \n  return trimmed.charAt(0).toUpperCase() + trimmed.slice(1).toLowerCase();\n}\n\n/**\n * Supported file types for different content categories\n */\nexport enum FileType {\n  JPG = 'jpg',\n  JPEG = 'jpeg',\n  PNG = 'png',\n  GIF = 'gif',\n  WEBP = 'webp',\n  MP4 = 'mp4',\n  MOV = 'mov',\n  PDF = 'pdf',\n}\n\n/**\n * Checks if a file or blob pathname matches one of the provided file types\n * @param filename - The filename or blob pathname to check\n * @param allowedTypes - Array of FileType enums to check against\n * @returns true if the file extension matches one of the allowed types\n */\nexport function isValidFileType(filename: string, allowedTypes: FileType[]): boolean {\n  if (!filename || allowedTypes.length === 0) {\n    return false;\n  }\n\n  // Extract file extension (handle both regular filenames and blob pathnames)\n  const extension = filename\n    .split('.')\n    .pop()\n    ?.toLowerCase()\n    .trim();\n\n  if (!extension) {\n    return false;\n  }\n\n  return allowedTypes.some(type => type.toLowerCase() === extension);\n}\n","\"use strict\";\n\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n}\nexports._ = _interop_require_default;\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/website/components/SectionLink.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/website/components/SectionLink.tsx\",\n    \"default\",\n);\n","import Sidebar from '@/components/Sidebar';\nimport { getPhotosBySection } from '@/lib/photos';\nimport Image from 'next/image';\nimport SectionLink from '@/components/SectionLink';\nimport PhotoLink from '@/components/PhotoLink';\n\n// Force dynamic rendering to ensure blob storage API calls work at runtime\nexport const dynamic = 'force-dynamic';\n\nexport default async function PhotosPage() {\n  const sections = await getPhotosBySection();\n\n  const formatDate = (dateString: string): string => {\n    try {\n      const date = new Date(dateString);\n      if (!isNaN(date.getTime())) {\n        return date.toLocaleDateString('en-US', {\n          year: 'numeric',\n          month: 'long',\n          day: 'numeric',\n        });\n      }\n    } catch (e) {\n      // If not a valid date, return as-is\n    }\n    return dateString;\n  };\n\n  return (\n    <div className=\"min-h-screen bg-[#F7FAFC]\">\n      <div className=\"flex flex-col md:flex-row pt-[60px] md:pt-0 w-full\">\n        <Sidebar />\n        \n        {/* Main Content */}\n        <main className=\"flex-1 min-w-0 px-4 md:px-8 py-8\">\n          <div className=\"max-w-7xl mx-auto\">\n            <header className=\"mb-8 flex justify-end\">\n              <div className=\"text-right\">\n                <div className=\"text-base text-[#4A5568]\">Nishant Iyengar</div>\n                <div className=\"text-sm text-[#718096] mt-1\">iyengar.nish@gmail.com</div>\n              </div>\n            </header>\n\n            <div className=\"space-y-12\">\n            {sections.map((section, sectionIndex) => {\n              const sectionId = `section-${section.date}`;\n              return (\n                <SectionLink key={sectionIndex} id={sectionId} className=\"scroll-mt-8\">\n                  <section>\n                    {/* Section Header */}\n                    <div className=\"mb-6\">\n                      <h2 className=\"text-2xl font-bold text-[#4A5568] mb-2\">\n                        {formatDate(section.date)}\n                      </h2>\n                      {section.description && (\n                        <p className=\"text-sm text-[#718096] leading-5\">\n                          {section.description}\n                        </p>\n                      )}\n                    </div>\n\n                    {/* Photos Grid */}\n                    <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n                      {section.photos.map((photo, photoIndex) => {\n                        // Create a safe ID from filename (remove extension, replace special chars)\n                        const photoId = `photo-${section.date}-${photo.filename.replace(/\\.[^/.]+$/, '').replace(/[^a-z0-9]/gi, '-').toLowerCase()}`;\n                        return (\n                          <PhotoLink\n                            key={photoIndex}\n                            id={photoId}\n                            className=\"group relative overflow-hidden rounded-lg bg-white cursor-pointer transition-transform duration-300 hover:scale-105 shadow-sm\"\n                          >\n                            <div className=\"relative aspect-square w-full\">\n                              <Image\n                                src={photo.src}\n                                alt={photo.alt || photo.caption || 'Photo'}\n                                fill\n                                className=\"object-cover\"\n                                sizes=\"(max-width: 768px) 100vw, (max-width: 1024px) 50vw, 33vw\"\n                              />\n                              <div className=\"absolute inset-0 bg-black/0 group-hover:bg-black/10 transition-colors duration-300\" />\n                            </div>\n                            {photo.caption && (\n                              <div className=\"p-3 bg-white\">\n                                <p className=\"text-sm text-[#718096]\">{photo.caption}</p>\n                              </div>\n                            )}\n                          </PhotoLink>\n                        );\n                      })}\n                    </div>\n                  </section>\n                </SectionLink>\n              );\n            })}\n            </div>\n\n            {sections.length === 0 && (\n            <div className=\"text-center py-12\">\n              <p className=\"text-[#718096]\">No photos yet. Add photos to the content/photos directory.</p>\n            </div>\n          )}\n          </div>\n        </main>\n      </div>\n    </div>\n  );\n}\n","import fs from 'fs';\nimport path from 'path';\nimport { list } from '@vercel/blob';\nimport { getSectionMetadata } from './sections';\nimport { isValidFileType, FileType } from './utils';\n\nconst photosMetadataDirectory = path.join(process.cwd(), 'content/photos');\n\n// Photos support all image types\nconst PHOTOS_ALLOWED_FILE_TYPES = [\n  FileType.JPG,\n  FileType.JPEG,\n  FileType.PNG,\n  FileType.GIF,\n  FileType.WEBP,\n];\n\nexport interface PhotoMetadata {\n  filename: string;\n  section: string; // Required: ISO date (YYYY-MM-DD) matching the sub-directory name\n  date?: string; // Optional: photo date (for sorting)\n  rank?: number; // Optional: photo rank (for sorting)\n  caption?: string;\n  alt?: string;\n}\n\nexport interface Photo extends PhotoMetadata {\n  src: string;\n}\n\nexport interface PhotoSection {\n  date: string; // Section date/identifier\n  description?: string; // Optional section description\n  photos: Photo[];\n}\n\nexport async function getAllPhotos(): Promise<Photo[]> {\n  try {\n    // Check if metadata directory exists\n    if (!fs.existsSync(photosMetadataDirectory)) {\n      console.warn('Photos metadata directory does not exist');\n      return [];\n    }\n\n    // Check if BLOB_READ_WRITE_TOKEN is available\n    if (!process.env.BLOB_READ_WRITE_TOKEN) {\n      console.error('BLOB_READ_WRITE_TOKEN environment variable is not set');\n      return [];\n    }\n\n    // Read photos.json file\n    const photosJsonPath = path.join(photosMetadataDirectory, 'photos.json');\n    if (!fs.existsSync(photosJsonPath)) {\n      console.warn('photos.json file does not exist');\n      return [];\n    }\n\n    const photosJsonContent = fs.readFileSync(photosJsonPath, 'utf8');\n    const photosMetadata: PhotoMetadata[] = JSON.parse(photosJsonContent);\n\n    // Validate that it's an array\n    if (!Array.isArray(photosMetadata)) {\n      console.error('photos.json must contain an array of photo metadata');\n      return [];\n    }\n\n    // Get all blobs in the photos/ folder\n    let blobs;\n    try {\n      const result = await list({ prefix: 'photos/' });\n      blobs = result.blobs;\n    } catch (error) {\n      console.error('Error fetching blobs from Vercel Blob Storage:', error);\n      return [];\n    }\n\n    const photos: Photo[] = [];\n\n    photosMetadata.forEach((metadata) => {\n      // Validate required fields\n      if (!metadata.filename) {\n        console.warn(`Photo is missing required 'filename' property`);\n        return;\n      }\n\n      if (!metadata.section) {\n        console.warn(`Photo ${metadata.filename} is missing required 'section' property`);\n        return;\n      }\n\n      // Validate file type\n      if (!isValidFileType(metadata.filename, PHOTOS_ALLOWED_FILE_TYPES)) {\n        console.warn(`Photo ${metadata.filename} has unsupported file type`);\n        return;\n      }\n\n      // Find the blob that matches the filename\n      // Try to match photos/<section>/filename or photos/filename\n      const matchingBlobs = blobs.filter(blob => {\n        const matchesSectionSubdir = blob.pathname.startsWith(`photos/${metadata.section}/`) && \n                                     blob.pathname.endsWith(metadata.filename);\n        const matchesRoot = blob.pathname === `photos/${metadata.filename}`;\n        const matchesAnySubdir = blob.pathname.endsWith(metadata.filename);\n        \n        return (matchesSectionSubdir || matchesRoot || matchesAnySubdir) && \n               isValidFileType(blob.pathname, PHOTOS_ALLOWED_FILE_TYPES);\n      });\n\n      if (matchingBlobs.length === 0) {\n        console.warn(`Photo ${metadata.filename} not found in blob storage`);\n        return;\n      }\n\n      // If multiple matches, use the most recent one\n      const matchingBlob = matchingBlobs.sort((a, b) => \n        new Date(b.uploadedAt).getTime() - new Date(a.uploadedAt).getTime()\n      )[0];\n\n      photos.push({\n        ...metadata,\n        src: matchingBlob.url,\n      });\n    });\n\n    return photos;\n  } catch (error) {\n    console.error('Error fetching photos:', error);\n    return [];\n  }\n}\n\nexport async function getPhotosBySection(): Promise<PhotoSection[]> {\n  const photos = await getAllPhotos();\n  const sectionsMap = new Map<string, PhotoSection>();\n\n  photos.forEach((photo) => {\n    if (!sectionsMap.has(photo.section)) {\n      const sectionMeta = getSectionMetadata(photo.section);\n      sectionsMap.set(photo.section, {\n        date: photo.section,\n        description: sectionMeta.description,\n        photos: [],\n      });\n    }\n    sectionsMap.get(photo.section)!.photos.push(photo);\n  });\n\n  // Sort photos within each section by date and/or rank\n  sectionsMap.forEach((section) => {\n    section.photos.sort((a, b) => {\n      // First, try to sort by date if both have dates\n      if (a.date && b.date) {\n        const dateA = new Date(a.date).getTime();\n        const dateB = new Date(b.date).getTime();\n        if (!isNaN(dateA) && !isNaN(dateB)) {\n          const dateDiff = dateB - dateA; // Newest first\n          if (dateDiff !== 0) return dateDiff;\n        }\n      }\n      \n      // If dates are equal or one is missing, sort by rank\n      if (a.rank !== undefined && b.rank !== undefined) {\n        return a.rank - b.rank; // Lower rank first\n      }\n      if (a.rank !== undefined) return -1; // Photos with rank come first\n      if (b.rank !== undefined) return 1;\n      \n      // If only one has a date, prioritize it\n      if (a.date && !b.date) return -1;\n      if (b.date && !a.date) return 1;\n      \n      // If both have dates but couldn't parse, try string comparison\n      if (a.date && b.date) {\n        return b.date.localeCompare(a.date);\n      }\n      \n      // Default: maintain original order\n      return 0;\n    });\n  });\n\n  // Convert to array and sort sections by date from sections.json (newest first)\n  const sections = Array.from(sectionsMap.values());\n  sections.sort((a, b) => {\n    const sectionMetaA = getSectionMetadata(a.date);\n    const sectionMetaB = getSectionMetadata(b.date);\n    \n    // Use the date from sections.json metadata if available, otherwise use section identifier\n    const dateAStr = sectionMetaA.date || a.date;\n    const dateBStr = sectionMetaB.date || b.date;\n    \n    // Try to parse section dates for sorting\n    const dateA = new Date(dateAStr).getTime();\n    const dateB = new Date(dateBStr).getTime();\n    if (!isNaN(dateA) && !isNaN(dateB)) {\n      return dateB - dateA; // Newest first\n    }\n    // If not valid dates, sort alphabetically (reverse)\n    return dateBStr.localeCompare(dateAStr);\n  });\n\n  return sections;\n}\n","import fs from 'fs';\nimport path from 'path';\n\nconst sectionsMetadataPath = path.join(process.cwd(), 'content/photos/sections.json');\n\nexport interface SectionMetadata {\n  date: string;\n  description?: string;\n}\n\nlet sectionsCache: Map<string, SectionMetadata> | null = null;\n\nexport function getSectionMetadata(sectionId: string): SectionMetadata {\n  if (sectionsCache === null) {\n    loadSectionsMetadata();\n  }\n  return sectionsCache?.get(sectionId) || { date: sectionId };\n}\n\nfunction loadSectionsMetadata(): void {\n  sectionsCache = new Map();\n  \n  try {\n    if (fs.existsSync(sectionsMetadataPath)) {\n      const fileContents = fs.readFileSync(sectionsMetadataPath, 'utf8');\n      const sections: SectionMetadata[] = JSON.parse(fileContents);\n      \n      sections.forEach((section) => {\n        sectionsCache!.set(section.date, section);\n      });\n    }\n  } catch (error) {\n    console.warn('Error loading sections metadata:', error);\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0,2,3]}